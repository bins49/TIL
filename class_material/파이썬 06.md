### OOP

- **파이썬은 모든게 객체이다.** 

- 객체(컴퓨터과학)
  - 클래에서 정의한 것을 토대로 메모리(실제 저장공간)에 할당된 것
- 객체 지향 프로그래밍
  - 컴퓨터 프로그래밍의 패러다임 중 하나 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 객체들의 모임으로 파악하고자 하는 것이다. (대표적 list.sort())
- 파이썬은 모든 것이 객체(대상의 정보와 동작)
  - (3 + 4j).real (복소수.실수)
  - 리스트라는 클래스에 다양한 내가 만들어 놓은 리스트들, 내가 만들어 놓은 문자열들은 결국 하나의 타입 하나의 종류 클래스(string)
  - 타입(종류) = 클래스, 값(실제 사례)-인스턴스

- 어떠한 타입이 뭐를 한다~ 어떠한 타입이 무엇을 한다

- `객체 지향은 주어 동사이다.`

- **객체는 특정 타입(클래스)의 인스턴스(사례, 예시)이다.**

  - 123, 900, 5는 모두 int의 인스턴스
  - 'hello', 'bye'는 모두 string의 인스턴스
  - [232, 89, 1], []은 모두 list의 인스턴스

  ```python
  a = [1, 2, 3]
  print(a, type(a)) #[1, 2, 3] <class 'list'>
  b = '123'
  print(b, type(b)) # 123 <class 'str'>
  
  ```

- 객체의 특징

  - 타입: 어떤 연산자(operator)와 조작(method)이 가능한가?
  - 속성(변수): 어떤 상태(데이터)를 가지는가? 
  - 메서드(함수): 어떤 행위(함수)를 할 수 있는가? # 객체들 간의 상호작용으로 코드가 구성을 하려고 한다. 그 방향으로 간다. 

- 객체지향 프로그래밍:

  - 프로그램을 여러 개의 독립된 객체들과 그 객체들 간의 상호작용으로 파악하는 프로그래밍 방법
    - `abc.upper()` 
    - `my_list.sort()`  근데 sorted를 쓰려면 `my_list = sorted(my_list)` 
    - 데이터와 기능(메소드) 분리, 추상화된 구조(인터페이스)
    - **현실 세계를 프로그램 설계에 반영(추상화)**
    - 하나의 대상들의 정보들과 메서드를 정리

- 절차지향 프로그래밍:

  - 데이터와 함수로 인한 변화(함수를 작성해서 해결해야만 했다)

- 클래스는 person, lIst, 인스턴스는 아이유, [1,2,3]

- 클래스를 활용해서 여러분이 원하시는 자료구조를 만드실 수 있다고 생각하자

- 리스트, 딕셔너리 모두 클래스로 정의되어 있는 것은 많은 사람들이 만들어 놓으면 편하기 때문에 파이썬에서 대신 만들어 줬다라고 생각

```python
#객체 지향 프로그래밍의 사각형 넓이 구하기
class Recatangle:
  	def __init__(self, x, y):
      	self.x = y
        self.y = y
    
    def area(self): #클래스 내부 정의 함수(메서드)
      	return self.x * self.y
      
    def circumference(self):
      	return 2 * (self.x + self.y)
      
r1 = Rectangle(10, 30)
r1.area()
r1.circumference()

r2 - Rectangle(300, 20)
r2.area()
r2.circumference()
```

- **사각형 - 클래스**
- **각 사각형 - 인스턴스**
- **사각형의 정보 - 속성**
  - 가로 길이, 세로 길이
- **사각형의 행동/기능 - 메소드**
  - 넓이를 구한다. 높이를 구한다.

- 각 인스턴스의 속성들을 메소드를 통해서 활용한다.

- 데이터가 주인이 되서 동작할 수 있는 것
- sum은 함수입니다. <built-in function sum> <class  'builtin_function_or_method'>
- [].sort()는 메서드인데. 리스트가 쓸 수 있는 함수이다.
- name은 str 클래스의 instance(값)인 '홍길동'을 담는 변수일 뿐이다.
- 객체지향의 장점
  - 내가 리스트를 편하게 할 수 있어
  - 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.
  - 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점을 가지고 있다.

## OOP 기초

- 기본 문법

  ```python
  # 클래스 정의 #Camelcase(클래스), snake_case(변수|함수)
  class MyClass:
    	pass
  # 인스턴스 생성
  my_instance = MyClass()
  # 매서드 호출
  my_instance.my_method()
  # 속성
  my_instance.my_attribute
  ```

- 클래스와 인스턴스
  - 클래스: 객체들의 분류(모든 클래스는 type의 종류들이다.)
  - 인스턴스: 하나나의 실체/예(모든 인스턴스는 각자 개별적인 클래스로 표현)
  - 파이썬은 모든 것이 객체, 모든 객체는 특정 타입의 인스턴스
- 속성
  - 특정 데이터 타입/클래스의 객체들이 가지게 될 상태/데이터를 의미
- 메소드(클래스 내부에 정의된 함수)
  - 특정 데이터 타입/클래스의 객체에 공통적으로 적용 가능한 행위(함수)

- 객체 비교하기

  -  ==

    - 동등한(equal)
    - 변수가 참조하는 객체가 동등한(내용이 같은) 경우 True
    - 두 객체가 같아 보이지만 실제로 동일한 대상을 가리키고 있다고 확인해 준 것은 아니다.

  -  is

    - 동일한(identical)
    - 두 변수가 동일한 객체를 가리키는 경우 True

    ```python
    a = [1, 2, 3]
    b = a
    b[0] = 'hi'
    
    print(a) # ['hi', 2, 3] # 변수-메모리 주소값 b = a 서로 같은 메모리 주소값을 바라본다. "얕은 복사"라고 불
    print(b) # ['hi', 2, 3]
    
    c =[3, 4, 5]
    d = list(c) #사실은 list이고 사실은 값도 같지만 다른 메모리 주소 결과를 받아낸다.
    d[0] = 'hi' 
    
    e = [4, 5, 6]
    f = [::]
    f[0] = 'hi'
    
    # 깊은 복사
    a = [[1, 2], 2, 3]
    b = list(a)
    b[0][0] = 'hi'
    
    print(a) #[['hi', 2], 2, 3] # 리스트 안에 담겨 있는것 역시 리스트의 주소가 담겨있어서 같이 바라보기 때문에 바뀌면 다 같이 바뀐다.
    print(b) #[['hi', 2], 2, 3]
    
    import copy
    c =[[1,2], 2, 3]
    b = copy.deepcopy(a)
    b[0][0] = 'hi'
    print(a) #[[1,2],2 ,3]
    print(b) #['hi',2], 2,3]
    #얕은 복사로 1차원 상의 리스트를 나뉘었다. 주소가 달라짐
    ```

    **결국 변수에 저장되어 있는것은 메모리주소이고 메모리 주소에는 어떤것이 담겨져있다. 그래서 그 객체에 타입도 있을 수 있다.** 

  - 객체 비교하기

  ```python
  a = [1, 2, 3] #값은 같지만 주소는 다르다
  b = [1. 2, 3]
  
  print(a == b, a is b) # True, False
  
  a = [1, 2, 3]
  b = a
  
  print(a == b, a is b) # True, True
  ```

- 인스턴스 변수 

  - 인스턴스 변수 접근 및 할당
  - 인스턴스가 개인적으로 가지고 있는 속성
  - 각 인스턴스들의 고유한 변수
  - 생성자 메소드에서 self.<name> 으로 정의
  - 인스턴스가 생성된 이후 <instance>.<name>으로 접근 및 할당

- 인스턴스 메소드(인스턴스 조작을 위한 메서드)

  - 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메소드
  - 클래스 내부에 정의되는 메소드의 기본
  - 호출 시, 첫번째 인자로 인스턴스 자기자신(self)이 전달됨

- self

  - 인스턴스 자기자신

  ```python
  class Person:
    	def greeting(self, name):
        	self.name = name # iu.greeting(): 아이유
          								 # jimin.greeting(): 지민
        #인스턴스 이름을 활용하고 싶다. 
  ```

  

  - 파이썬에서 인스턴스 메소드는 호출 시 첫번째 인자로 인스턴스 자신이 전달되게 설계
    - 매개변수 이름으로 self를 첫번쨰 인자로 정의
    - 다른 단어로 써도 작동하지만, 파이썬의 암묵적인 규칙

  ```python
  class Person:
    	#생성자! 인스턴스가 생성될때 어떠한 작업! 기본적인 변수나 값 세팅하는데 사용돼
      def __init__(self, name):
        	print('응애!')
  				#그 인스턴스의 이름을 nmae으로 해주세요.
          self.name = name
        
  # Person 클래스의 인스턴스인 iu를 생성
  iu = Person('아이유')
  print(iu.name) # init메소드의 name에 들어간다. 
  jimin = Person('지민')
  ```

- 생성자 메소드(init메소드)

  - 인스턴스 객체가 생성될 때 자동으로 호출되는 메소드

  - 인스턴스 변수들의 초기값을 설정

    - 인스턴스 생성
    - __init__ 메서드 자동 호출

    ```python
    class Person:
      	def __init__(self):
          	print("인스턴스가 생성되었습니다.")
        
        person1 = Person() #인스턴스가 생성되었습니다.
    ```

    

```python
class Person:
  	pass
  
# Person 클래스의 인스턴스 iu
iu = Person()

# iu의 인스턴스 변수
iu.name ='아이유'
iu.age = 28
iu.gender = 'F'
#인스턴스 변수 접근
print(iu.name)
print(iu) #<__main__.Person Object at 0x000001E077376F70> #객체가 이런형식으로 되어 있지만 list는 내부적으로 코드를 보여줄게 정의
```

- 소멸자 메소드 (del)

  - 인스턴스 객체가 소멸(파괴)되기 직전에 호출되는 메소드

  ```python
  class Person:
    	
      def __del__(self):
        	print('인스턴스가 사라졌습니다.')
      		
          person1 = Person()
          del person1 #인스턴스가 사라졌습니다.
  ```

  