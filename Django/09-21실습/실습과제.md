1.IP와 도메인은 무엇일까요?

- IP는 인터넷에 연결되어 있는 장치들은 각각의 장치를 식별할 수 있는 주소를 가지고 있다다. 쉽게 생각하면 편지라고 생각을 해보면 편지 안에는 출발하는 사람의 주소, 받는 사람의 주소 그리고 편지 안의 내용으로 구성되어 있다. 이것을 인터넷 프로토콜 즉 IP의 관점에서 보면 보내는 사람의 주소는 출발지의 IP, 받는사람의 주소는 목적지의 IP, 그리고 편지 안의 내용은 전송하고자하는 전송데이터로 볼 수 있다. 그럼 프로토콜은 무엇일까? 우리가 편지를 주고 받을때 보통 우체국이라는 신뢰할만한 중간 매개체를 통해서 주고 받는다. 그래서 인터넷 상에서도 서로 약속을 통해서 일정한 양식과 규칙을 가지고 데이터를 교환한다. 이것이 프로토콜이다. 

- 도메인은 ip는 숫자로 구성되어 있다보니 기억하기 어렵다. 따라서 이를 위해 각 IP에 이름을 부여할 수 있게 했는데 이것을 도메인이라고 한다. 도메인의 구조를 보면 크게 2가지로 구성된다. label과 TLD로 구성되어 있다. TLD를 먼저 보면 Top-Level Domain의 줄임말로써 쉽게 말해서 우리가 도메인 가장 마지막에 위치하는 `.com`,`.org`, `.net` 사실 이러한 TLD 이름들 중에서 꼭 필수적으로 웹서비스에서 써야하는 이름은 따로 존재하지 않는다  그러나 어떠한 TLD의 경우는 그들 자신의 목적에 맞게 사용되기도 한다. 기존의 TLD와 다른 경우도 존재한다. 예를 들어  `.us`,  `.fr`, `ru` 과 같이 특정 국가에서 사용하는 TLD가 있다. 이러한 경우 특정한 언어로 나타내져 있다. 그리고 `gov`는 국가에서 `.edu`는 교육기관에서 사용된다. TLD는 또 라틴어를 포함시킬 수 있고 한개의 TLD의 길이는 최대 63글자까지 사용할 수 있습니다.  

- TLD 전에 오는게 Label(or component)은 대소문자 구별 없이 1~ 63글자까지 쓸 수 있으며 알파벳 숫자 다 가능하다. 도메인 이름은 많은 label들을 가질 수 있다. 꼭 3개의 labels들만 가지지 않아도 된다. 예를 들어 `www.inf.ed.ac.uk`는 유효한 도메인 이름이다. 

https://developer.mozilla.org/ko/docs/Learn/Common_questions/How_does_the_Internet_work

2.클라이언트와 서버는 무엇일까요?

- 클라이언트는 서버와 이어진 모든 단말기(컴퓨터의 경우는 WI-FI, 모바일은 모바일 네트워크에 연결되어 있다)와 단말기에서 이용하는, 웹에 접근하는 소프트웨어를 지칭 쉽게 말해 클라이언트는 서비스를 요청하는 서비스의 소비자의 역할이고
- 보통은 브라우저나 게임과 같이 별도의 클라이언트가 서버랑 호응하는 경우도 있다. 브라우저란 쉽게 말해 인터네셍 접속하기 위한 소프트웨어이다. 사용자의 입력을 주로 처리하고 이를 서버에 요청을 보낸다.
- 서버는 웹페이지, 사이트, 앱을 저장하는 컴퓨터이며, 고객의 요청을 받아서 처리하고 이를 다시 고객한테 응답을 보낸다. 즉, 특정 서비스를 제공하는 서비스 제공자의 역할을 한다. 
- 어떠한 형태로든 클라이언트의 요청을 받아 정보를 제공하면 서버 컴퓨터가 될 수 있다.  

3.정적 웹 사이트와 동적 웹사이트의 차이점은 무엇일까요? DJango는 무엇을 위한 도구인가요?

- 정적 웹 사이트의 경우는 특별한 요청이 들어와도 항상 똑같은 콘텐츠나 정보를 반환한다. 쉽게 말해 공기청정기와 같다. 우리가 공기청정기에 어떠한 짓을 해도 공기청정기는 공기를 청정하게 하는 역할 밖에 하지 않는다.
- 서버에 미리 저장된 HTML 파일 그대로 전달된 웹 페이지나 같은 상황에서 모든 사용자에게 동일한 정보를 표시한다. 
- 동적 웹 사이트는 반대로 특별한 요청이 들어오면 추가적인 수정이 되어 고객들한테 전달된다. 쉽게 말해 어떤 고객이냐에 따라 다른 정보를 제공한다. 예를 들어, 핸드폰 멤버쉽 제도를 보면 등급에 따라 다른 혜택을 제공 받는다. 이와 비슷하다. 서버에서 웹 페이지의 내용을 바꿔준다. 
- 동적 웹사이트를 지원하는 코드는 서버에서 실행 되어야 하기 때문에 서버 사이드 프로그래밍(파이썬, 자바 등) 이 사용된다.   
- Django는 웹 프로그램을 쉽고 빠르게 만들 수 있도록 도와주는 웹 프레임워크이다. 특히 장고는 보안 공격을 기본으로 아주 잘 막아준다. SQL 인젝션, XSS, CSRF, 클릭재킹과 같은 보안 공격을 기본으로 막아준다.  

4.HTTP는 무엇이고 요청과 응답 메시지 구성은 어떻게 되나요?

- HTTP는 하이퍼텍스트 전송 프로토콜의 약자이며 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜입니다. 월드 와이드 웹(WWE)에 내제된 프로토콜이며 HTTP는 인터넷에서 데이터를 주고 받을 수 있는 프로토콜이다. 웹 페이지를 방문할 때마다 컴퓨터는 HTTP를 사용하여 인터넷 어딘가에 있는 다른 컴퓨터에서 해당 페이지를 다운로드한다.
- HTTP는 클라이언트-서버 프로토콜이다. 
  - 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조로 이루어져 있다. 이것을 Request response 구조라고 한다.
  - 클라이언트는 서버에 요청을 보내고 응답을 대기하며 서버가 요청에 대한 결과를 만들어 응답한다.
- HTTP의 특징을 보면 
  - 1.클라이언트 서버 구조
    - 클라이언트가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조로 이루어져 있다.
  - 2.무상태 프로토콜
    - 서버가 클라이언트 상태를 보존하지 않는다
    - 예를 들어 고객이 서버한테 저녁에 치킨먹자고 말했고 서버가 "그래"라고 답했다. 저녁이 되어 고객은 서버에게 "먹으러 가자"고 말했고 서버는 대답했다. " 뭘"?
    - 장점: 서버 확장이 높다 (스케일 아웃)- 무상태는 응답 서버를 쉽게 바꿀 수 있기 때문에 무한한 서버 증설이 가능하다. , 아무 서버나 호출해도 된다, 만약 서버에 장애가 생기도라도 다른 서버에서 응답을 전달하면 되기 때문에 클라이언트는 다시 요청할 필요가 없다. 
    - 단점: 클라이언트가 추가 데이터 전송
    - 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다.
    - 무상태는 로그인이 필요없는 단순한 서비스 소개 화면이고 상태 유지는 로그인이 필요한 서비스에 적합하다.
    - 로그인한 사용자의 경우 로그인했다는 생태를 서버에 유지(브라우저 쿠키, 서버 세션, 토큰 등)
    - 상태 유지는 최소한만 사용
  - 3.비 연결성
    - HTTP는 기본이 연결을 유지하지 않는 모델
      - HTTP 1.0 기준으로 HTTP는 연결을 유지하지 않는 모델이다.
    - 일반적으로 초 단위 이하의 빠른 속도로 응답
      - 트래픽이 많지 않고, 빠른 응답을 제공할 수 있는 경우에 비 연결성의 특징은 효율적으로 작동한다.
      - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십 개로 매우 작음
        - 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다.
      - 트래픽이 많고 큰 규모의 서비스를 운영할 때는 비 연결성은 한계를 보인다. 

- HTTP 메시지는 클라이언트와 서버 사이에서 데이터가 교환되는 방식이다. 

- HTTP 메시지는 몇 줄의 텍스트 정보로 구성된다. 구성 파일, API, 기타 인터페이스에서 HTTP 메시지를 자동으로 완성한다. 

- 요청과 응답 메시지의 공통적인 구조를 살펴보면

  - Start line
    - start line에는 요청이나 응답의 상태를 나타낸다.
    - 항상 첫 번째 줄을 위치합니다
    - 응답에서는 status line이라고 부릅니다.
  - HTTP headers
    - 요청을 지정하거나, 메시지에 포함된 본문을 설명하는 헤더의 집합이다.
  - empty line
    - 헤더와 본문을 구분하는 빈 줄이 있다. 그 줄을 말한다.
  - body
    - 요청과 관련된 데이터나 응답과 관련된 데이터 또는 문서를 포함한다.
    - 요청과 응답의 유형에 따라 선택적으로 사용한다. 
  - Start line과 HTTP headers를 묶어 요청이나 응답의 헤드라고 이야기한다. payload(전송되는 데이터)는 body라고 이야기한다. 

- 요청부분을 살펴보면

  - Start line에는 세 가지 요소가 있다.

    - 첫 번쨰 요소

      - HTTP method를 나타낸다
      - HTTP method는 수행할 작업(GET, PUT, POST 등) 이나 방식(HEAD or OPTIONS)을 설명한다
      - 예를 들어 GET method는 리소스를 받아야 하고, POST method는 데이터를 서버로 전송한다. 

    - 두 번째 요소

      - 요청 대상(일반적으로 URL이나 URI) 또는 프로토콜, 포트, 도메인의 절대 경로는 요청 컨텍스트에 작성된다. 

      - 이 요청 형식은 HTTP method 마다 다르다.

    - origin 형식

      - ?와 쿼리 문자열이 붙는 절대 경로이다.
      - POST, GET, HEAD, OPTIONS 등의 method와 함께 사용한다.
      - POST / HTTP 1.1GET / background.png HTTP / 1.0 HEAD / test.html?query=alibaba HTTP / 1.1OPTIONS / anypage.html HTTP/ 1.0

    - absolute 형식

      - 완전한 URL 형식으로, 프록시에 연결하는 경우 대부분 GET method와 함께 사용한다.
      - `GET <http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages> HTTP/1.1`

    - authority 형식

      - 도메인 이름과 포트 번호로 이루어진 URL의 authority component 이다.
      - HTTP 터널을 구축하는 경우, `CONNCET` 와 함께 사용할 수 있다.
      - `CONNECT developer.mozilla.org:80 HTTP/1.1`

    - asterisk 형식

      - `OPTIONS` 와 함께 별표(*) 하나로 서버 전체를 표현한다.
      - `OPTIONS * HTTP/1. 1`

    - 마지막 요소

      - HTTP 버전은 메시지의 다른 구조를 결정한다.
      - 이를 위해 HTTP 버전을 함께 입력한다.

      

      

      

      ​		

  - Headers:

    - 요청의 Headers는 기본 구조를 따른다
    - 대소문자 구분 없는 문자열과 콜론(:), 값을 입력한다.
    - 여러 종류의 헤더가 있고, 값은 헤더에 따라 다르다.
    - 헤더를 크게 3가지 그룹으로 나눌 수 있다.
      - request headers:
        - User-Agent, Accept-Type, Accept-Language과 같은 헤더는 요청을 보다 구체화한다.
        - Referer처럼 컨텍스트를 제공하거나 if-None과 같이 조건에 따라 제약을 추가할 수 있다.
      - General headers
        - 메시지 전체에 적용된다.
      - Entity headers
        - Content-Length와 같은 헤더는 body에 적용된다.
        - body가 비어있는 경우, entity headers는 전송되지 않는다.

  - Body:

    - 요청의 본문은 HTTP messages 구조의 마지막에 위치한다.
    - 모든 요청에 body가 필요한 것은 아니다
    - GET, HEAD, DELETE, OPTIONS처럼 서버에 리소스를 요청하는 경우에는 본문이 필요하지 않다.
    - POST나 PUT과 같은 일부 요청은 데이터를 업데이트하기 위해 사용한다. 

    - body는 두 종류로 나뉜다
      - Single-resource bodies(단일-리소스 방문)
        - 헤더 두 개(content-type과 content-length)로 정의된 단일 파일로 구성된다.
      - Multiple-resource bodies(다중-리소스 본문)
        - 여러 파트로 구성된 본문에서는 각 파트마다 다른 정보를 지닌다.
        - 보통 HTML form과 관련이 있다.

- 응답 부분을 더 디테일하게 살펴 보면 

  - status line(응답의 첫 줄은 Status line이라고 부르며, 다음의 정보를 포함한다.)

    1. 현재 프로토콜의 버전(HTTP/1.1)
    2. 상태 코드 - 요청의 결과를 나타냅니다. (200, 302, 404 등)
    3. 상태 텍스트 - 상태 코드에 대한 설명
       - Status line은 `HTTP/1. 1 404 Not Found.`처럼 생겼다.

  - Headers

    - 응답에 들어가는 HTTP headers는 요청 헤더와 동일한 구조를 가지고 있다.
    - 대소문자 구분 없는 문자열과 콜론(:), 값을 입력한다.
    - 값은 헤더에 따라 다르다.
    - 요청의 헤더와 마찬가지로 몇 그룹으로 나눌 수 있다.
      - General headers
        - 메시지 전체에 적용된다.
      - Response headers
        - Vary, Accept-Ranges와 같이 상태 줄에 넣기에는 공간이 부족했던 추가 정보를 제공한다.
      - Entity headers
        - Content-Length와 같은 헤더는 body에 적용된다.
        - body가 비어있는 경우, entity headers는 전송되지 않는다.

  - Body

    - 응답의 본문은 HTTP messages 구조의 마지막에 위치한다.

    - 모든 응답에 body가 필요한 것은 아니다.

    - 201, 204와 같은 상태 코드를 가지는 응답에는 본문이 필요하지 않다.

    - 응답의 body는 다음과 같이 두 종류로 나눌 수 있다.

      - Single-resource bodies(단일-리소스 본문)

        - 길이가 알려진 단일-리소스 본문은 두 개의 헤더(content-type, content-length)로 정의한다.

        - 길이를 모르는 단일 파일로 구성된 단일-리소스 본문은 Transfer-Encoding이 `chunked`로 설정되어 있으며, 파일은 chunk로 나뉘어 인코딩되어 있다. 

      - Multiple-resource bodies(다중-리소스 본문)

        - 서로 다른 정보를 담고 있는 body이다.

5.프레임워크는 무엇일까요? 

- 프레임워크는 개발하는 것을 도와주는 역할을 한다. 프레임워크는 기본적인 기능을 갖추고 있어서 개발자가 필요한 기능을 구현하는 데만 집중할 수 있다.  쉽게 말해서 밀키트를 생각하면 쉽다. 밀키트는 다른 것들을 할 필요없이 간단히 조리만 해주면 끝난다. 우리는 중요한 조리과정에만 집중하면 된다

- 중복된 작업들에 대해서는 굳이 여러 번 반복할 필요가 없다.  
- 다양한 프레임워크가 존재하는데 애플에서 제공하는 코코아 프레임워크가 있다. 애플 앱스토어에 들어갈 앱을 만드는 데 도움을 주는 프레임워크다. 버튼, UI, 앱의 동작 등 여러 기능들을 구현하기 위한 코드를 제공하고 있다.
- 구글도 안드로이드 프레임워크를 제공하고 있다. 자바, 코틀린 언어에 대한 프레임워크를 제공해 쉽고 빠르게 앱을 개발하도록 돕는다.
- 웹 개발을 위한 프레임워크에서 사용자 인터페이스(UI)를 담당하는 프론트엔드 개발에는 주로 자바스크립트 언어가 사용된다. 자바스크립트에 대한 프레임워크인 Angular, React, Vue가 있다. 반면에 백엔드 개발에는 자바, 파이썬 루비 언어가 사용된다. 스프링, 장고, 익스프레스 등 서버를 쉽고 빠르게 개발할 수 있는 프레임워크가 있다.