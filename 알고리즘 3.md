```python
#파리퇴치
기준행 = 1
기준열 = 1
M = 2
영역합 = 0
for 기준행 in range(기준행, 기준행 + M):
  for 기준열 in range(기준열, 기준열 + M):
    	영역합 += 리스트[행][열]
      
if 영역합 > 최대영역합:
  최대영역합 = 영역합
최대영역합 = 0  
# 이중 리스트를 순회하는 이중 반복문
for 기준행 in range(N - M +1):
  	for 기준열 in range(N - M + 1):
      	#각 기준 좌표에서의 영역의 합 계산
        영역합 = 0
       	for 행 in range(기준행, 기준행 + M):
          	for 열 in range(기준열, 기준열 + M):
              	영역합 += list_[행][열]
                
            if 영역합 > 최대영역합:
              	최대영역합 = 영역합
```

```python
#어디에 들어갈 수 있을까
#벽 이전의 빈공간의 수가 K라면 단어가 들어갈 수 있는 자리의 수 + 1
#중간에 벽이 있으면 빈공간의 수를 초기화한다.
자리의 수 = 0
for 행 in range(5):
  	빈공간의 수 = 0
    for 열 in range(5):
      	if 리스트[행][열] == 벽:
          빈공간의수 = 0
          if 빈공간의수 == K:
            	자리의수 += 1
              
#이차원 리스트를 순회하기 위한 이중 반복문
for 행 in range(N):
  	빈공간의 수 = 0
  	for 열 in range(N):
      	if list_[행][열] == 빈공간:
          	빈공간의수 += 1
        if list_[행][열] == 벽:
          	# 1. 빈공간의수를 초기화하고 자리의 수 조건 보기
            #빈공간의 수 = 0
            #if 빈공간의수 == K:
              	#자리의 수 += 1
            #2. 자리의 수 조건을 보고 빈공간의 수를 초기화
            if 빈공간의수 == K:
              	자리의수 += 1
            빈공간의 수 = 0
    #하나의 행을 다 탐색하고 나서 
    #빈공간의 수가 K라면 단어가 들어갈 수 있는 자리의 수 + 1
    if 빈공간의수 == K:
      	자리의 수 += 1
        
        

for 열 in range(N):
  	for 행 in range(N):
      	if list_[행][열] == 빈공간:
          	빈공간의수 += 1
        if list_[행][열] == 벽:
          	# 1. 빈공간의수를 초기화하고 자리의 수 조건 보기
            #빈공간의 수 = 0
            #if 빈공간의수 == K:
              	#자리의 수 += 1
            #2. 자리의 수 조건을 보고 빈공간의 수를 초기화
            if 빈공간의수 == K:
              	자리의수 += 1
            빈공간의 수 = 0
    #하나의 행을 다 탐색하고 나서 
    #빈공간의 수가 K라면 단어가 들어갈 수 있는 자리의 수 + 1
    if 빈공간의수 == K:
      	자리의 수 += 1
        
print(자리의 수)
```

### 회전

문제에서 이차원 리스트를 왼쪽, 오른쪽으로 90도 회전하는 경우가 존재한다.

1. 왼쪽으로 90도 회전하기

```python
matrix = [
  [1, 2, 3]
  [4, 5, 6]
  [7, 8, 9]
]

n = 3
rotated_matrix = [[0] * n for _ in range(n)]

for i in range(n):
  	for j in range(n):
      	rotated_matrix[i][j] = matrix[j][n-i-1]
```

2.오른쪽으로 90도 회전하기

```python
matrix = [
  [1, 2, 3]
  [4, 5, 6]
  [7, 8, 9]
]

n = 3
#새로운 2차원 리스트를 만들어야
rotated_matrix = [[0] * n for _ in range(n)]

for _ in range(2): # 180도 회전 270도 회전시 3번 돌아야
  for i in range(n):
      for j in range(n):
          rotated_matrix[i][j] = matrix[n-j-i][i]
```

### 완전탐색 1(Exhaustive Search)

- 무식하게 다해보기(Brute-force)
  - Brute_force는 모든 경우의 수를 탐색하여 문제를 해결하는 방식이다.
    - 브루트포스라고도 하며, 무식하게 밀어붙인다는 뜻이다
    - 가장 단순한 풀이 기법이며, 단순 조건문과 반복문을 이용해서 풀 수 있다
    - 복잡한 알고리즘 보다는, 아이디어를 어떻게 코드로 구현할 것인지가 중요하다.

```python
##블랙잭 카드
for i in range(n - 2):
  #0, 1, 2
  	for j in range(j+1, n +1):
      #1, 2, 3
      	for k in range(j+1, n):
          	#2, 3, 4
            total = cards[i] + cards[j] + cards[k]
            
            #현재 가장 큰 합보다는 크고, m을 넘지 않아야 갱신
            if max_total < total <= m:
              max_total = total
            #합과 m이 같으면 더이상 탐색하는 의미가 없으므로 종료
            if total == m:
              	return total
return total
          	
```

### 델타탐색

- 지금까지는 모든 경우의 수를 따지는 일반적인 완전탐색을 알아보았다. 이차원 리스트의 완전탐색에서 많이 등장하는 유형인 델타 탐색(상하좌우 탐색)을 알아보자.
- (0,0)에서부터 이차원 리스트의 모든 원소를 순회하며(완전탐색) 각 지점에서 상하좌우에 위차한 다른 지점을 조회하거나 이동하는 방식이다.

- 이차원 리스트의 인덱스의 조작을 통해서 상하좌우 탐색을 한다. 이때 행과 열의 변량인 -1, +1을 **델타값**이라 한다. 

- 델타값을 이용해 상하좌우로 이동하기
- 조합을 만드는 과정

```python
1)행을 x, 열을 y로 표현
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

2)행을 r, 열을 c로 표현
dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

3) delta = [(-1, 0), (1,0), (0,-1), (0, 1)]


#상(X-1, y)
nx = x + dx[0]
ny = y + dy[0]

#하(x+1, y)
nx = x + dx[1]
ny = x + dy[1]

#for문을 이용해서 상하좌우 이동을 간단히 표현할 수 있다.
for i in range(4):
  	nx = x + dx[i]
    ny = y + dy[i]
    
delta = [(-1, 0), (1,0), (0,-1), (0,1)]    
for d in delta:
  	nx = x + d[0]
    ny = y + d[1]
```

- 상하좌우로 이동 후 범위를 벗어나지 않는지 확인 및 갱신하기

```python
#1.델타값을 이용해 상하좌우 이동
for i in range(4):
  	nx = x + dx[i]
    ny = y + dy[i]
    
	#2. 범위를 벗어나지 않으면 갱신
  if 0 <= nx and 0 <= ny < 3:
    	x = nx
      y = ny 
      
```



```python
1)행을 x, 열을 y로 표현
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


for i in range(n):
  	for j in range(m):
      
      	
        for k in range(4):
          	nx = x + dx[i]
            ny = y + dy[i]
            
            if 0 <= nx < n and 0 <= ny < m:
              	x = nx 
                y = ny
```

1.델타설정

2.델타순회

3.경계값

``` python
#상, 하, 좌, 우, 좌상, 좌하, 우상, 우하
dx = [-1, 1, 0, 0, -1, 1, -1, 1]
dy = [0, 0, -1, 1, -1, -1, 1, 1]
```

