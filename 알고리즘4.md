```python
## 오목 문제(델타서치)
우, 하, 우하, 우상 방향으로 오목 방향을 (가장 왼쪽에 있는 바둑알의 위치를 출력하기 위해서) 우하와 우상을 탐색해야한다.
#우, 하, 우하, 우상
dy = [0, 1, -1, 1]
dx = [1, 0, 1, 1]
black = 1
white = 2
N = 19

board = []
#오목판 상황 입력
for _ in range(N):
  #하나의 행을 입력
  	temp_list = list(map(int, input().split()))
  	board.append(temp_list)

answer = 0

for y in range(N):
  	for x in range(N):
      if board[y][x] == 1 or board[y][x] == 2:
        for d in range(4):
          ny = y + dy[d]
          nx = x + dx[d]
          #방향이 바뀔 때마다 돌의 개수가 갱신
          stone_count = 1
          #while문을 사용해서 몇 번 이동해야할지 모르니까 ny, nx지속적으로 변해야해
          while True:
            조건 1 범위를 벗어나면 안 돼
            if not(-1 < ny < N and -1 < nx < N):
              break

            조건 2 같은 색 돌이 나와야한다.
            if not(board[y][x] == board[ny][nx]):
              break

            #같은 값이고 범위를 벗어나지 않으면

            stone_count += 1

            #같은 방향 다음 좌표 검색
            ny = ny + dy[d]
            nx = nx + dx[d]

            #돌의개수가 5개면 육목인지 판단해야한다. 1.육목 중 가장 왼쪽에 다른 돌이면 같은돌 5개니까 된다. 이전좌표가 범위가 만족해야한다.
          if count == 5:
             #이전좌표를 구한다. 
             prev_ㅛ = y - dy[d]
             prev_x = x - dx[d]

             #기준 1. 좌표의 이전 좌표가 범위를 벗어나면 오목
             if not(-1 < prev_y < N and -1 < prev_x < N):

             # 육목인지 판단
             # 조건 1. 이전좌표가 범위를 벗어나면 오목
             # if not(-1 < prev_y < N and -1 < prev_x < N):

             # 조건 2. 기준 좌표의 값과 이전 좌표의 값이 다르면 오목
             # if board[y][x] != board[prev_y][prev_x]

             #조건 2. 기준 좌표의 값과 이전 좌표의 값이 다르면 오목
             if not(-1 < prev_y < N and -1 < prev_x < N) or board[y][x] != board[prev_y][prev_x]:
                #answer 값 갱신
                 answer = board[y][x]
                 #현재 돌의 색 출력
                 print(board[y][x])
                 #현재 돌의 좌표를 출력(현실 오목판은 19 * 19니까)
                 print(y + 1, x + 1)

#전체를 반복했는데 무승부
if answer == 0:
  	print(answer)
```



### 그래프(Graph)

- 그래프에 대한 이해
  - 정점(=노드)과 이를 연결하는 간선들의 집합으로 이루어진 비선형 자료구조
    - 소셜 네트워크와 지하철 노선도 같이, 현실에 있는 개체 간의 관계를 나타내기 위해 사용한다.
    - 점과 선으로 구성
- 그래프 관련 용어
  - 정점(vertax):간선으로 연결되는 객체이며, 노드라고도 한다.
  - 간선(edge):정점 간의 관계(연결)를 표현하는 선을 의미한다.
  - 경로(path): 시작 정점부터 도착 정점까지 거치는 정점을 나열한 것을 의미한다.
  - 인접(adjacency ): 두 개의 정점이 하나의 간선으로 직접 연결된 상태를 의미한다.
- 그래프의 종류
  - 무방향 그래프
    - 간선의 방향이 없는 가장 일반적인 그래프
    - 간선을 통해 양방향의 정점 이동 가능
    - 차수(Degree): 하나의 정점에 연결된 간선의 개수
    - 모든 정점의 차수의 합 = 간선 수 * 2(엣지의 수가 기본적으로 2개라서)
  - 유뱡향 그래프
    - 간선의 방향이 있는 그래프
    - 간선의 방향이 가리키는 정점으로 이동 가능
    - 뒤로가기 안 돼 
    - 차수(degree): 진입 차수와 진출 차수로 나누어짐
      - 진입 차수: 외부 정점에서 한 정점으로 들어오는 간선의 수
      - 진출 차수: 한 정점에서 외부 정점으로 나가는 간선의 수 

- 그래프의 표현

  ```python
  grpah ={
    0: [1, 4],
    1: [0, 3, 4],
    2: [0, 4, 5],
    3: [1],
    4: [1, 2, 6],
    5: [2],
    6: [4]
  }
  
  subway = {
    'yeoksam' = ["gangnam", "seonlueng"]
    'seoleung': ['yeoksam', 'samsung', 'sunjeongleung', 'hanti']
  }
  # graph[0][0] => 1
  
  graph = [
    [1,2],
    [0, 3, 4],
    [0, 4, 5],
    [1],
    [1, 2, 6],
    [2],
    [4]
    
  ]
  
  # graph[0][0] => 1 -> 인접 리스트 
  ```

  - 인접 행렬(Adjancent matrix)

    - 두 정점을 연결하는 간선이 없으면 0, 있으면 1을 가지는 행렬로 표현하는 방식 0을 기준으로 데칼코마니

    - 무방향 그래프(서로 무조건 연결되니까) * 2

    - |      | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 0    | 0    | 1    | 1    | 0    | 0    | 0    | 0    |
      | 1    | 1    | 0    | 0    | 1    | 1    | 0    | 0    |
      | 2    | 1    | 1    | 0    | 0    | 1    | 1    | 0    |
      | 3    | 0    | 1    | 0    | 0    | 0    | 0    | 0    |
      | 4    | 0    | 1    | 1    | 0    | 0    | 0    | 1    |
      | 5    | 0    | 0    | 1    | 0    | 0    | 0    | 0    |
      | 6    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |

      ```python
      #인접 행렬 만들기
      n = 7 # 정점 개수 
      m = 7 # 간선 개수
      
      edges = [
        [0,1],
        [0,2],
        [1,3],
        [1,4],
        [2,4],
        [2,5],
        [4,6]
      ]
      set(*edges) #비구조화(flatten) unpacking operator
      
      # n x n 행렬 초기화
      graph = [[0] * n for _ in range(n)]
      
      for _ in range(m):
        v1, v2 = map(int, input().split())
        graph[v1][v2] = 1
        #양방향 그래프니까 서로 연결되어야 한다. 
        graph[v2][v1] = 1
      ```

      - 인접 리스트

        - 리스트를 통해 각 정점에 대한 인접 정점들을 순차적으로 표현하는 방식

        ```python
        #인접 리스트 만들기
        n = 7 # 정점 개수 
        m = 7 # 간선 개수
        
        # n x n 행렬 초기화
        graph = [[] * n for _ in range(n)]
        
        for _ in range(m):
          v1, v2 = map(int, input().split())
          graph[v1].append(v2)
          #양방향 그래프니까 서로 연결되어야 한다. 
          graph[v2].append(v1)
        ```

      - 인접 행렬 vs 인접 리스트
        - 인접 행렬은 직관적이고 만들기 편하지만, 불필요하게 공간이 낭비된다.
        - **인접 리스트는 연결된 정점만 저장하여 효율적이므로 자주 사용된다. **