### 리액트 시작

- 리액트 이해

  - 리액트는 자바스크립트 라이브러리로 사용자 인터페이스를 만드는 데 사용한다.
  - 구조가 MVC, MVW 등인 프레임워크와 달리, 오직 **V(view)만 신경 쓰는 라이브러리**이다.
  - 컴포넌트는 **특정 부분이 어떻게 생길지 정하는 선언체**, 재사용이 가능한 API로 수많은 기능들을 내장하고 있다. 
  - 사용자 화면에 뷰를 보여 주는 것을 렌더링이라고 한다. 

  - 초기 렌더링
    - 맨 처음에 어떻게 보일지를 정하는 초기 렌더링이 필요하다. 리액트에서는 이를 다루는 render 함수가 있다. 
    - render()는 **뷰가 어떻게 생겼는지 어떻게 작동하는지 객체를 반환한다.** 
      - 뷰가 어떻게 생겼고 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환한다. 
    - 최상위 컴포넌트의 렌더링 작업 => HTML 마크업을 만들고 => 실제 페이지의 DOM 요소 안에 주입한다. 
    - 컴포넌트를 실제 페이지에 렌더링할 때는 분리된 두 가지 절차를 따르는데, 문자열 형태의 HTML 코드 생성 후 특정 DOM에 해당 내용을 주입하면 이벤트가 적용된다. 
  - 조화 과정
    - 리액트에서 뷰를 업데이트할 때는 업데이트라는 단어보다는 조화 과정을 거친다라고 하는 것이 더 정확한 표현이다. 
      - 변화에 따라 뷰가 변형되는 것처럼 보이지만, 사실은 새로운 요소로 갈아 끼우기 떄문이다. 
      - **컴포넌트는 데이터를 업데이트 했을 때 단순히 업데이트한 값을 수정하는 것이 아니라, 새로운 데이터를 가지고 render 함수를 또 다시 호출한다** 
      - render 함수가 곧바로 DOM에 반영하지 않고, 이전에 **render 함수가 만들었던 컴포넌트 정보와 현재 render함수가 만든 컴포넌트 정보를 비교한다**.
        - **최소한의 연산으로 비교한 후, 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트한다. **
      - 최적의 자원을 사용하여 이를 수행한다.

- 리액트의 특징

  - DOM은? 

    - DOM은 Document Object Model의 약자이다. 
    - 객채로 문서 구조를 표현하는 방법으로 XML이나 HTML로 작성한다.
    - 웹 브라우저는 DOM을 활용하여 객체에 자바스크립트와 CSS를 적용한다. DOM은 트리 형태라서 특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입할 수 있다. 
    - DOM은 동적 UI가 최적화되어 있지 않다. HTML 자체로는 정적인데, 자바스크립트를 사용하여 이를 동적으로 만들 수 있다. 
    - DOM 자체는 빠르다, 그러나 웹 브라우저 단에서 DOM에 변화가 일어나면 웹 브라우저가 CSS를 다시 연산하고, 레이아웃을 구성하고, 페이지를 리페인트한다. 이 과정에서 시간이 허비되는 것이다. 
    - 업데이트가 너무 잦으면 성능이 저하되므로 DOM을 최소한으로 조작하여 작업을 처리해야한다. 
    - 그래서 react의 가상돔 방식을 사용해서 DOM 업데이트를 추상화함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행한다.

  - Virtual DOM

    - 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용한다. 마치 **실제 DOM 가벼운 사본과 비슷하다**.
    - 리액트에서 데이터 변화 후 웹 브라우저에 실제 DOM을 업데이트 하는 절차
      - 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링한다. 
      - 이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다.
      - 바뀐 부분만 실제 DOM에 적용한다. 
    - 무조건 가상돔을 사용한다고 해서 사용하지 않을 때와 비교하여 무조건 빠른 것이 아니다. 

    > 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축하기

    - **리액트를 사용하지 않고 코드 최적화를 열심히 하면 DOM 작업이 느려지는 문제를 개선할 수 있고, 또 작업이 매우 간단할 때는 오히려 리액트를 사용하지 않는 편이 더 나은 성능을 보이기도 한다.** 
    - 리액트와 가상돔이 언제나 제공할 수 있는 것은 바로 **업데이트 처리 간결성**이다. 쉽게 업데이트에 접근할 수 있다.

  - 기타 특징

    - 리액트는 프레임워크가 아닌 라이브러리이다. 
    - 다른 웹 프레임워크가 Ajax, 데이터 모델링, 라우팅 등과 같은 기능을 내장하고 있는 반면, 리액트는 정말 뷰만 신경 쓰는 라이브러리이므로 기타 기능은 직접 구현하여 사용해야 한다. 
    - 리액트는 다른 웹 프레임워크나 라이브러리와 혼용할 수 있다. 
    - 대신 여러 라이브러리를 접해야 한다는 단점도 있다. 

  - 작업 환경 설정

    - Node.js 웹 브라우저 환경이 아닌 곳에서도 자바스크립트를 사용하여 연산할 수 있다. 
    - 크롬 V8 자바스크립트 엔진으로 빌드한 자바스크립트 런타임
    - vs코드는 모든 운영체제를 지원한다. 

  - 리액트 프로젝트 생성하기 

    `yarn create react-app 프로젝트 이름`

    `cd 프로젝트 이름` - 프로젝트 디렉토리 이동

    `yarn start` - 개벌 전용 서버 구동





### JSX

- 코드 이해하기

  - 우리가 import를 할 수 있는건 node_modules 디렉터리에 react 모듈이 설치되어 있기 때문이다. 
  - 이렇게 **모듈을 불러와서 사용하는 것은 원래 브라우저에는 없던 기능**이다. Node.js에서 지원하는 기능
  - Node.js는 require라는 구문으로 패키지를 불러올 수 있다. 
  - 이러한 기능을 **브라우저에서 사용하기 위해 bundler를 사용**한다. 
  - 리액트에서 webpack을 사용하는 이유는 **편의성과 확장성** 때문이다.
  - 번들러 도구를 사용하면 **import로 모듈을 불러왔을 때 불러온 모듈을 모두 합쳐서 하나의 파일을 생성해 준다**. 

  ```react
  import logo from "./logo.svg";
  import "./App.css";
  ```

  - 웹팩을 사용하면 SVG, CSS 파일을 불러와서 사용할 수 있는데 이것은 웹팩의 loader라는 기능이 담당한다. 
    - css-loader, file-loader, babel-loader가 있다. 
  - 웹팩 로더는 직접 설치하고 설정해야 하지만 `create-react-app`이 번거로운 작업을 다 해주는 것이다. 

- JSX란?

  - JSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼다. 
  - 작성한 코드는 바벨을 사용하여 코드가 번들링되는 과정에서 일반 자바스크립트 형태의 코드로 변환된다. 

  - 예시(변환 전 코드- JSX)

  ```react
  function App() {
    return (
      <div>
        Hello <b>react</b>
      </div>
    )
  }
  ```

  - 예시(변환 후 코드 - JS)

  ```js
  function App() {
    return React.createElement("div", null, "Hello", React.createElement("b", null, "react"));
  }
  ```

  - 매번 React.createElement 함수를 사용한다면 불편하다. 그래서 JSX를 사용하면 html를 좀 더 쉽게 작성할 수 있고 편하게 UI를 렌더링할 수 있다. 
  - JSX는 리액트로 프로젝트를 개발할 때 사용되므로 공식적인 자바스크립트 문법이 아니다. 

- JSX의 장점?

  - 보기 쉽고 익숙하다
    - 가독성도 높고 작성하기도 쉽다. 
  - 더욱 높은 활용도
    - JSX는 우리가 알고 있는 HTML 태그를 사용할 수 있을 뿐만 아니라, 앞으로 만들 컴포넌트도 JSX 안에서 작성할 수 있다. 

- JSX 문법

  - 감싸인 요소 
    - 컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 한다. 
  - 예시(부모요소가 없어 잘못된 케이스)

  ```react
  function App() {
    return (
        <h1>리액트 안녕</h1>
        <h2>잘 작동하니?</h2>
    );
  }
  
  export default App;
  ```

  - 예시(옳은 케이스)

  ```react
  function App() {
    return (
      <div>
        <h1>리액트 안녕</h1>
        <h2>잘 작동하니?</h2>
      </div>
    );
  }
  
  export default App;
  ```

  - 이렇게 하는 이유는 **가상돔에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져 있어야 한다는 규칙이 존재**

  - div가 사용하기 싫으면 React v16 이상부터 도입된 Fragment라는 기능을 사용하면 된다.

  - 예시

  ```react
  function App() {
    return (
      <>
        <h1>리액트 안녕</h1>
        <h2>잘 작동하니?</h2>
      </>
    );
  }
  
  export default App;
  ```

- 자바스크립트 표현

  - JSX 안에서 자바스크립트 표현식 사용 가능하다.
  - 변수 선언은 return문 위에서 하고  
  - JSX 내부에서 코드를 `{}`감싸면 된다.
  - 예시

  ```react
  function App() {
    const name = "리액트";
    return (
      <>
        <h1>{name} 안녕</h1>
        <h2>잘 작동하니?</h2>
      </>
    );
  }
  
  export default App;
  ```

- if 문 대신 조건부 연산자

  - JSX 내부에서는 If문을 사용할 수 없다. JSX 밖에서 사용하거나 아니면 `{}`중괄를호 사용하여 조건부 연산자를 사용하고 `()`소괄호 안에 구문에 해당 할 때 보여주고 싶은 값을 넣으면 된다.  
  - 조건부 연산자의 또 다른 이름은 **삼항 연산자**이다. 

  - 예시

  ```react
  function App() {
    const name = "리액트";
    return (
      <>
        {name === "리액트" ? (
          <h1>리액트입니다.</h1>
        ) : (
          <h2>리액트가 아닙니다.</h2>
        )}
      </>
    );
  }
  
  export default App;
  ```

- AND 연산자(&&)를 사용한 조건부 렌더링

  - 특정 조건을 만족할 때 내용을 보여 주고, 만족하지 않을 때 아무것도 렌더링하지 않아야 하는 상황이 올 수 있다.

  ```react
  function App() {
    const name = "리액트";
    return (
      <>
        {name === "리액트" && <h1>리액트입니다.</h1>}
      </>
    );
  }
  
  export default App;
  ```

  - name이 react일 때만 문구가 보인다.
  - 한 가지 예외사항은 **falsy한 값인 0은 예외적으로 화면에 나타난다.**

  ```react
  function App() {
    const number = 0;
    return (
      <>
        {number && <h1>리액트입니다.</h1>}
      </>
    );
  }
  
  export default App;
  ```

  - jsx는 주로 여러 줄로 작성할 때 괄호로 감싸고, 한 줄로 표현할 수 있는 JSX는 감싸지 않는다. 필수 사항이 아니다. 

  

  

- undefined를 렌더링하지 않기

  - 리액트 컴포넌트에서는 함수에서 undefined만 반환하여 렌더링하는 상황을 만들면 안 된다. 

  - OR 연산자를 사용하거나 JSX 내부에 undefined를 렌더링하는 것은 괜찮다. 

  

- 인라인 스타일링

  - 리액트 DOM 요소에 스타일 적용할 때는 문자열 형태로 넣는 것이 아니라 객체 형태로 넣어 주어야 한다. 
  - 이름 - 문자를 없애고 camelCase으로 작성해야 한다. 

  ```react
  function App() {
    const name = "리액트";
    const style = {
      backgroundColor: "black",
      color: "aqua",
      fontSize: "48px",
      fontWeight: "bold",
      padding: 16
    }
  
    return <div style={style}>{name}</div>
  }
  
  export default App;
  ```

- class 대신 className

  - App.css에서 style 작성 후에 App.css에서 css 클래스를 불러와서 사용한다.

  ```css
  .react {
    background: aqua;
    color: black;
    font-size: "48px";
    font-weight: "bold";
    padding: 16px;
  }
  ```

  ```react
  import React from "react";
  import "./App.css"
  
  function App() {
    const name = "리액트";
    return <div className="react">{name}</div>
  }
  
  export default App;
  ```

  - class라고 쓰면 경고창 뜬다.  className 사용하자.

- 꼭 닫아야 하는 태그 

  - HTML에서는 input를 그냥 써도 되는데 JSX는 태그 작성할 때 반드시 닫는 태그가 있어야 한다. 
  - 예시1

  ```react
  import React from "react";
  import "./App.css"
  
  function App() {
    const name = "리액트";
    return (
      <>
       <div className="react">{name}</div>
       <input></input>
      </>
    )
  }
  
  export default App;
  ```

  - 예시2 

    - 태그 사이에 별도의 내용이 들어가지 않으면 self-closing 태그를 사용해서 선언 동시에 닫을 수 있다.

    ```react
    import React from "react";
    import "./App.css"
    
    function App() {
      const name = "리액트";
      return (
        <>
         <div className="react">{name}</div>
         <input />
        </>
      )
    }
    
    export default App;
    ```

- 주석

  - JSX 안에서 주석을 작성하는 방법은 일반 자바스크립트에서 작성할 때와 조금 다르다.
  - `{/* 주석 */}` 이렇게 작성하자

  ```react
  import React from "react";
  import "./App.css"
  
  function App() {
    const name = "리액트";
    return (
      <>
       {/* 주석은 이렇게 작성한다. */}
       <div className="react">{name}</div>
       <input></input>
      </>
    )
  }
  
  export default App;
  ```

  

- Prettier 설정

  - 프로젝트의 root directory(src, public)에서 `.prettierrc`라는 파일 생성 후에 커스터 마이징을 한다. 

  ```react
  {
    "singleQuote" : true,
    "semi" : true,
    "useTabs" : false,
    "tabWidth": 2
  }
  ```

  