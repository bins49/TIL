### 리액트 시작

- 리액트 이해

  - 리액트는 자바스크립트 라이브러리로 사용자 인터페이스를 만드는 데 사용한다.

  - 구조가 MVC, MVW 등인 프레임워크와 달리, 오직 **V(view)만 신경 쓰는 라이브러리**이다.

  - 컴포넌트는 **특정 부분이 어떻게 생길지 정하는 선언체**, 재사용이 가능한 API로 수많은 기능들을 내장하고 있다. 

  - 사용자 화면에 뷰를 보여 주는 것을 렌더링이라고 한다. 

- 초기 렌더링

  - 맨 처음에 어떻게 보일지를 정하는 초기 렌더링이 필요하다. 리액트에서는 이를 다루는 render 함수가 있다. 
  - render()는 **뷰가 어떻게 생겼는지 어떻게 작동하는지 객체를 반환한다.** 
    - 뷰가 어떻게 생겼고 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환한다. 
  - 최상위 컴포넌트의 렌더링 작업 => HTML 마크업을 만들고 => 실제 페이지의 DOM 요소 안에 주입한다. 
  - 컴포넌트를 실제 페이지에 렌더링할 때는 분리된 두 가지 절차를 따르는데, 문자열 형태의 HTML 코드 생성 후 특정 DOM에 해당 내용을 주입하면 이벤트가 적용된다. 

  #### 조화 과정

  - 리액트에서 뷰를 업데이트할 때는 업데이트라는 단어보다는 조화 과정을 거친다라고 하는 것이 더 정확한 표현이다. 
    - 변화에 따라 뷰가 변형되는 것처럼 보이지만, 사실은 새로운 요소로 갈아 끼우기 떄문이다. 
    - **컴포넌트는 데이터를 업데이트 했을 때 단순히 업데이트한 값을 수정하는 것이 아니라, 새로운 데이터를 가지고 render 함수를 또 다시 호출한다** 
    - render 함수가 곧바로 DOM에 반영하지 않고, 이전에 **render 함수가 만들었던 컴포넌트 정보와 현재 render함수가 만든 컴포넌트 정보를 비교한다**.
      - **최소한의 연산으로 비교한 후, 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트한다. **
    - 최적의 자원을 사용하여 이를 수행한다.

- 리액트의 특징

  - DOM은? 

    - DOM은 Document Object Model의 약자이다. 
    - 객채로 문서 구조를 표현하는 방법으로 XML이나 HTML로 작성한다.
    - 웹 브라우저는 DOM을 활용하여 객체에 자바스크립트와 CSS를 적용한다. DOM은 트리 형태라서 특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입할 수 있다. 
    - DOM은 동적 UI가 최적화되어 있지 않다. HTML 자체로는 정적인데, 자바스크립트를 사용하여 이를 동적으로 만들 수 있다. 
    - DOM 자체는 빠르다, 그러나 웹 브라우저 단에서 DOM에 변화가 일어나면 웹 브라우저가 CSS를 다시 연산하고, 레이아웃을 구성하고, 페이지를 리페인트한다. 이 과정에서 시간이 허비되는 것이다. 
    - 업데이트가 너무 잦으면 성능이 저하되므로 DOM을 최소한으로 조작하여 작업을 처리해야한다. 
    - 그래서 react의 가상돔 방식을 사용해서 DOM 업데이트를 추상화함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행한다.

  - Virtual DOM

    - 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용한다. 마치 **실제 DOM 가벼운 사본과 비슷하다**.
    - 리액트에서 데이터 변화 후 웹 브라우저에 실제 DOM을 업데이트 하는 절차
      - 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링한다. 
      - 이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다.
      - 바뀐 부분만 실제 DOM에 적용한다. 
    - 무조건 가상돔을 사용한다고 해서 사용하지 않을 때와 비교하여 무조건 빠른 것이 아니다. 

    > 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축하기

    - **리액트를 사용하지 않고 코드 최적화를 열심히 하면 DOM 작업이 느려지는 문제를 개선할 수 있고, 또 작업이 매우 간단할 때는 오히려 리액트를 사용하지 않는 편이 더 나은 성능을 보이기도 한다.** 
    - 리액트와 가상돔이 언제나 제공할 수 있는 것은 바로 **업데이트 처리 간결성**이다. 쉽게 업데이트에 접근할 수 있다.

  - 기타 특징

    - 리액트는 프레임워크가 아닌 라이브러리이다. 
    - 다른 웹 프레임워크가 Ajax, 데이터 모델링, 라우팅 등과 같은 기능을 내장하고 있는 반면, 리액트는 정말 뷰만 신경 쓰는 라이브러리이므로 기타 기능은 직접 구현하여 사용해야 한다. 
    - 리액트는 다른 웹 프레임워크나 라이브러리와 혼용할 수 있다. 
    - 대신 여러 라이브러리를 접해야 한다는 단점도 있다. 

  - 작업 환경 설정

    - Node.js 웹 브라우저 환경이 아닌 곳에서도 자바스크립트를 사용하여 연산할 수 있다. 
    - 크롬 V8 자바스크립트 엔진으로 빌드한 자바스크립트 런타임
    - vs코드는 모든 운영체제를 지원한다. 

  - 리액트 프로젝트 생성하기 

    `yarn create react-app 프로젝트 이름`

    `cd 프로젝트 이름` - 프로젝트 디렉토리 이동

    `yarn start` - 개벌 전용 서버 구동





### JSX

- 코드 이해하기

  - 우리가 import를 할 수 있는건 node_modules 디렉터리에 react 모듈이 설치되어 있기 때문이다. 
  - 이렇게 **모듈을 불러와서 사용하는 것은 원래 브라우저에는 없던 기능**이다. Node.js에서 지원하는 기능
  - Node.js는 require라는 구문으로 패키지를 불러올 수 있다. 
  - 이러한 기능을 **브라우저에서 사용하기 위해 bundler를 사용**한다. 
  - 리액트에서 webpack을 사용하는 이유는 **편의성과 확장성** 때문이다.
  - 번들러 도구를 사용하면 **import로 모듈을 불러왔을 때 불러온 모듈을 모두 합쳐서 하나의 파일을 생성해 준다**. 

  ```react
  import logo from "./logo.svg";
  import "./App.css";
  ```

  - 웹팩을 사용하면 SVG, CSS 파일을 불러와서 사용할 수 있는데 이것은 웹팩의 loader라는 기능이 담당한다. 
    - css-loader, file-loader, babel-loader가 있다. 
  - 웹팩 로더는 직접 설치하고 설정해야 하지만 `create-react-app`이 번거로운 작업을 다 해주는 것이다. 

- JSX란?

  - JSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼다. 
  - 작성한 코드는 바벨을 사용하여 코드가 번들링되는 과정에서 일반 자바스크립트 형태의 코드로 변환된다. 

  - 예시(변환 전 코드- JSX)

  ```react
  function App() {
    return (
      <div>
        Hello <b>react</b>
      </div>
    )
  }
  ```

  - 예시(변환 후 코드 - JS)

  ```js
  function App() {
    return React.createElement("div", null, "Hello", React.createElement("b", null, "react"));
  }
  ```

  - 매번 React.createElement 함수를 사용한다면 불편하다. 그래서 JSX를 사용하면 html를 좀 더 쉽게 작성할 수 있고 편하게 UI를 렌더링할 수 있다. 
  - JSX는 리액트로 프로젝트를 개발할 때 사용되므로 공식적인 자바스크립트 문법이 아니다. 

- JSX의 장점?

  - 보기 쉽고 익숙하다
    - 가독성도 높고 작성하기도 쉽다. 
  - 더욱 높은 활용도
    - JSX는 우리가 알고 있는 HTML 태그를 사용할 수 있을 뿐만 아니라, 앞으로 만들 컴포넌트도 JSX 안에서 작성할 수 있다. 

- JSX 문법

  - 감싸인 요소 
    - 컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 한다. 
  - 예시(부모요소가 없어 잘못된 케이스)

  ```react
  function App() {
    return (
        <h1>리액트 안녕</h1>
        <h2>잘 작동하니?</h2>
    );
  }
  
  export default App;
  ```

  - 예시(옳은 케이스)

  ```react
  function App() {
    return (
      <div>
        <h1>리액트 안녕</h1>
        <h2>잘 작동하니?</h2>
      </div>
    );
  }
  
  export default App;
  ```

  - 이렇게 하는 이유는 **가상돔에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져 있어야 한다는 규칙이 존재**

  - div가 사용하기 싫으면 React v16 이상부터 도입된 Fragment라는 기능을 사용하면 된다.

  - 예시

  ```react
  function App() {
    return (
      <>
        <h1>리액트 안녕</h1>
        <h2>잘 작동하니?</h2>
      </>
    );
  }
  
  export default App;
  ```

- 자바스크립트 표현

  - JSX 안에서 자바스크립트 표현식 사용 가능하다.
  - 변수 선언은 return문 위에서 하고  
  - JSX 내부에서 코드를 `{}`감싸면 된다.
  - 예시

  ```react
  function App() {
    const name = "리액트";
    return (
      <>
        <h1>{name} 안녕</h1>
        <h2>잘 작동하니?</h2>
      </>
    );
  }
  
  export default App;
  ```

- if 문 대신 조건부 연산자

  - JSX 내부에서는 If문을 사용할 수 없다. JSX 밖에서 사용하거나 아니면 `{}`중괄를호 사용하여 조건부 연산자를 사용하고 `()`소괄호 안에 구문에 해당 할 때 보여주고 싶은 값을 넣으면 된다.  
  - 조건부 연산자의 또 다른 이름은 **삼항 연산자**이다. 

  - 예시

  ```react
  function App() {
    const name = "리액트";
    return (
      <>
        {name === "리액트" ? (
          <h1>리액트입니다.</h1>
        ) : (
          <h2>리액트가 아닙니다.</h2>
        )}
      </>
    );
  }
  
  export default App;
  ```

- AND 연산자(&&)를 사용한 조건부 렌더링

  - 특정 조건을 만족할 때 내용을 보여 주고, 만족하지 않을 때 아무것도 렌더링하지 않아야 하는 상황이 올 수 있다.

  ```react
  function App() {
    const name = "리액트";
    return (
      <>
        {name === "리액트" && <h1>리액트입니다.</h1>}
      </>
    );
  }
  
  export default App;
  ```

  - name이 react일 때만 문구가 보인다.
  - 한 가지 예외사항은 **falsy한 값인 0은 예외적으로 화면에 나타난다.**

  ```react
  function App() {
    const number = 0;
    return (
      <>
        {number && <h1>리액트입니다.</h1>}
      </>
    );
  }
  
  export default App;
  ```

  - jsx는 주로 여러 줄로 작성할 때 괄호로 감싸고, 한 줄로 표현할 수 있는 JSX는 감싸지 않는다. 필수 사항이 아니다. 

  

  

- undefined를 렌더링하지 않기

  - 리액트 컴포넌트에서는 함수에서 undefined만 반환하여 렌더링하는 상황을 만들면 안 된다. 

  - OR 연산자를 사용하거나 JSX 내부에 undefined를 렌더링하는 것은 괜찮다. 

  

- 인라인 스타일링

  - 리액트 DOM 요소에 스타일 적용할 때는 문자열 형태로 넣는 것이 아니라 객체 형태로 넣어 주어야 한다. 
  - 이름 - 문자를 없애고 camelCase으로 작성해야 한다. 

  ```react
  function App() {
    const name = "리액트";
    const style = {
      backgroundColor: "black",
      color: "aqua",
      fontSize: "48px",
      fontWeight: "bold",
      padding: 16
    }
  
    return <div style={style}>{name}</div>
  }
  
  export default App;
  ```

- class 대신 className

  - App.css에서 style 작성 후에 App.css에서 css 클래스를 불러와서 사용한다.

  ```css
  .react {
    background: aqua;
    color: black;
    font-size: "48px";
    font-weight: "bold";
    padding: 16px;
  }
  ```

  ```react
  import React from "react";
  import "./App.css"
  
  function App() {
    const name = "리액트";
    return <div className="react">{name}</div>
  }
  
  export default App;
  ```

  - class라고 쓰면 경고창 뜬다.  className 사용하자.

- 꼭 닫아야 하는 태그 

  - HTML에서는 input를 그냥 써도 되는데 JSX는 태그 작성할 때 반드시 닫는 태그가 있어야 한다. 
  - 예시1

  ```react
  import React from "react";
  import "./App.css"
  
  function App() {
    const name = "리액트";
    return (
      <>
       <div className="react">{name}</div>
       <input></input>
      </>
    )
  }
  
  export default App;
  ```

  - 예시2 

    - 태그 사이에 별도의 내용이 들어가지 않으면 self-closing 태그를 사용해서 선언 동시에 닫을 수 있다.

    ```react
    import React from "react";
    import "./App.css"
    
    function App() {
      const name = "리액트";
      return (
        <>
         <div className="react">{name}</div>
         <input />
        </>
      )
    }
    
    export default App;
    ```

- 주석

  - JSX 안에서 주석을 작성하는 방법은 일반 자바스크립트에서 작성할 때와 조금 다르다.
  - `{/* 주석 */}` 이렇게 작성하자

  ```react
  import React from "react";
  import "./App.css"
  
  function App() {
    const name = "리액트";
    return (
      <>
       {/* 주석은 이렇게 작성한다. */}
       <div className="react">{name}</div>
       <input></input>
      </>
    )
  }
  
  export default App;
  ```

  

- Prettier 설정

  - 프로젝트의 root directory(src, public)에서 `.prettierrc`라는 파일 생성 후에 커스터 마이징을 한다. 

  ```react
  {
    "singleQuote" : true,
    "semi" : true,
    "useTabs" : false,
    "tabWidth": 2
  }
  ```

  

### 컴포넌트

#### 클래스형 컴포넌트

- 클래스형 컴포넌트는 state 기능 및 라이프사이클 기능을 사용할 수 있다는 것과 임의 메서드를 정의할 수 있다. 
- 클래스형 컴포넌트에서는 **render 함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할 JSX를 반환해야 한다**. 

```react
import React, { Component } from "react";
import "./App.css"

class App extends Component {
  render() {
    const name = "react";
    return <div className="react">{name}</div>
  }
}

export default App;
```

#### 함수형 컴포넌트 vs 클래스형 컴포넌트

- 함수형 컴포넌트는 클래스형 컴포넌트보다 선언하기 훨씬 편하다.
- 메모리 자원도 클래스형 컴포넌트보다 덜 사용한다. 
- 프로젝트를 완성하여 빌드한 후 배포할 때도 함수형 컴포넌트를 사용하는 것이 결과물의 파일 크기가 더 작다. 
  - 근데 사실상 성능과 파일 크기 면에서 별 차이가 없다. 
- 함수형 컴포넌트 단점은 state와 라이프사이클 API의 사용이 불가능하다는 점인데 이 부분도 16 버전 이후 Hooks의 도입되면서 해결됐다.

#### 첫 컴포넌트 생성

- 함수형 컴포넌트
  - 코드 스니펫 단축키 `rsc`

```react
import React from 'react'

const MyComponent = () => {
  return <div>나의 새롭고 멋진 컴포넌트</div>
}

export default MyComponent;import React from 'react'
```

- 모듈 불러오기 

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent />
}

export default App;
```



#### props

- props는 properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는 요소이다. 
- props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트(현 상황에서는 App 컴포넌트가 부모 컴포넌트)에서 설정할 수 있다.
- JSX 내부에서 props 렌더링(자식 컴포넌트에서 받기)

```js
import React from 'react';

const MyComponent = (props) => {
  return (
    <div>
      안녕하세요, 제 이름은 {props.name}입니다.
    </div>
  );
};

export default MyComponent;
```

- 컴포넌트를 사용할 때 props 값 지정하기(부모 컴포넌트에서 전달)

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent name="React"/>
}

export default App;
```

- props 기본값 설정: defaultProps

```react
import React from 'react';

const MyComponent = props => {
  return <div> 안녕하세요, 제 이름은 {props.name}입니다.</div>
};

MyComponent.defaultProps = {
  name: "기본 이름"
}

export default MyComponent;
```

- 태그 사이의 내용을 보여 주는 children
  - MyComponent 태그 사이에 작성한 리액트라는 문자열을 MyComponent 내부에서 보여 주려면 props.children 값을 보여 주어야 한다. 

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent>리액트</MyComponent>
}

export default App;
```

```react
import React from 'react';

const MyComponent = props => {
  return (
    <div>
      안녕하세요, 제 이름은 {props.name}입니다. <br />
      children 값은 {props.children}
      입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}


export default MyComponent;
```

- 비구조화 할당 문법을 통해 props 내부 값 추출하기
  - 이렇게 코드를 작성하면 name, children을 더 짧게 사용 가능

```react
import React from 'react';

const MyComponent = props => {
  const { name, children } = props;
  return (
    <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}


export default MyComponent;
```

- 비구조화 할당 문법을 이용한 다른 방법
  - 이게 엄청 쉬운 방법 그니까 파라미터 부분에서 비구조화 할당 문법 사용하자

```react
import React from 'react';

const MyComponent = ({ name, children }) => {
  return (
    <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}


export default MyComponent;
```

- propTypes를 통한 props 검증
  - 컴포넌트의 필수 props를 지정하거나 props의 타입을 지정할 때는 propTypes를 사용한다.
  - 컴포넌트의 propTypes를 지정하는 방법은 defaultProp을 설정하는 것과 비슷하다. 
  - 타입 지정 후에 반드시 타입에 맞는 값을 props로 전달해야 한다. 

```react
import React from 'react';
import PropTypes from "prop-types";

const MyComponent = ({ name, children }) => {
  return (
    <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}

MyComponent.propTypes = {
  name: PropTypes.string
}

export default MyComponent;
```

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent name={"React"}>리액트</MyComponent>
}

export default App;
```

- isRequired를 사용하여 필수 propTypes 설정

```react
import React from 'react';
import PropTypes from "prop-types";

const MyComponent = ({ name, favoriteNumber, children }) => {
  return (
    <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
      <br />
      제가 좋아하는 숫자는 {favoriteNumber}입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}

MyComponent.propTypes = {
  name: PropTypes.string,
  // 숫자로 지정
  favoriteNumber: PropTypes.number.isRequired
}


export default MyComponent;
```

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent name={"React"} favoriteNumber={1}>리액트</MyComponent>
}

export default App;
```

- 클래스형 컴포넌트에서 props 사용하기

```react
import React, {Component} from 'react';
import PropTypes from "prop-types";

class MyComponent extends Component {
  render() {
    const { name, children, favoriteNumber } = this.props;
    return (
      <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
      <br />
      제가 좋아하는 숫자는 {favoriteNumber}입니다.
    </div>
    )
  }
};

MyComponent.defaultProps = {
  name : "기본 이름"
}

MyComponent.propTypes = {
  name: PropTypes.string,
  favoriteNumber: PropTypes.number.isRequired
}


export default MyComponent;
```

- defaultProps와 propTypes를 설정할 때 class 내부에서 지정하는 방법

```react
import React, {Component} from 'react';
import PropTypes from "prop-types";

class MyComponent extends Component {
  static defaultProps = {
    name : "기본 이름"
  };
  static propTypes = {
    name: PropTypes.string,
    favoriteNumber: PropTypes.number.isRequired
  }

  render() {
    const { name, children, favoriteNumber } = this.props;
    return (
      <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
      <br />
      제가 좋아하는 숫자는 {favoriteNumber}입니다.
    	</div>
    )
  }
};

export default MyComponent;
```

- defaultProps와 propTypes는 다른 개발자랑 협업하면 해당 컴포넌트에 어떤 props가필요한지 쉽게 알 수 있어 개발 능률이 좋아진다. 



#### state

- 리액트에서 state는  컴포넌트 내부에서 바뀔 수 있는 값을 의미한다. 
- props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props를 읽기 전용으로만 사용할 수 있다.
- 리액트에는 두 가지 종류의 state가 있다. 하나는 클래스형 컴포넌트가 지니고 있는 state이고, 다른 하나는 함수형 컴포넌트에서 useState라는 함수를 통해 사용하는 state이다.

- 클래스형 컴포넌트의 state

```react
import React, { Component } from 'react'

export default class Counter extends Component {
  constructor(props) {
    super(props);
    // state 정의
    this.state = {
      number: 0
    };
  }

  render() {
    // 구조분해할당으로 사용 가능
    const { number } = this.state;
    return (
      <div>
        <h1>{number}</h1>
        <button
          onClick={() => {
            // this.setState를 사용하여 state에 새로운 값을 넣을 수 있다.
            this.setState({ number: number + 1})
          }}
        >
         +1
        </button>
      </div>
    )
  }
}
```



- state를 constructor에서 꺼내기
  - 다른 방식으로 state 초깃값을 지정 가능
  - constructor 메서드 사용 안해도 됨. 

```react
import React, { Component } from 'react'

export default class Counter extends Component {
  state = {
    number: 0,
    fixedNumber: 0,
  }

  render() {
    // 구조분해할당으로 사용 가능
    const { number, fixedNumber } = this.state;
    return (
      <div>
        <h1>{number}</h1>
        <h2>바뀌지 않는 값: {fixedNumber}</h2>
        <button
          onClick={() => {
            // this.setState를 사용하여 state에 새로운 값을 넣을 수 있다.
            this.setState({ number: number + 1})
          }}
        >
         +1
        </button>
      </div>
    )
  }
}
```



- this.setState에 객체 대신 함수 인자 전달하기

  - 기본 구조

  ```react
  this.setState((prevState, props) => {
    return {
      //업데이트하고 싶은 내용
    }
  })
  ```

  - 숫자 2씩 증가하기

  ```react
  import React, { Component } from 'react'
  
  export default class Counter extends Component {
    state = {
      number: 0,
      fixedNumber: 0,
    }
  
    render() {
      // 구조분해할당으로 사용 가능
      const { number, fixedNumber } = this.state;
      return (
        <div>
          <h1>{number}</h1>
          <h2>바뀌지 않는 값: {fixedNumber}</h2>
          <button
            onClick={() => {
              this.setState(prevState => {
                return {
                  number: prevState.number + 1
                };
              });
              this.setState(prevState => ({
                number: prevState.number + 1
              }))
            }}
          >
           +1
          </button>
        </div>
      )
    }
  }
  
  ```

  

- this.setState가 끝난 후 특정 작업 실행하기

  - setState의 두 번째 파라미터로 콜백함수를 등록하여 작업을 처리할 수 있다.

  ```react
  export default class Counter extends Component {
    state = {
      number: 0,
      fixedNumber: 0,
    }
  
    render() {
      // 구조분해할당으로 사용 가능
      const { number, fixedNumber } = this.state;
      return (
        <div>
          <h1>{number}</h1>
          <h2>바뀌지 않는 값: {fixedNumber}</h2>
          <button
            onClick={() => {
              this.setState({
                number: number + 1
              },
              () => {
                console.log("방금 setState가 호출되었습니다.");
                console.log("this.state")
              }
              )
            }}
          >
           +1
          </button>
        </div>
      )
    }
  }
  ```



- 함수형 컴포넌트에서 useState 사용하기

  - useState 함수의 인자에는 상태의 초깃값을 넣어 준다.
  - useState에서는 반드시 객체가 아니어도 상관없다. 
  - 배열의 첫 번쨰 원소는 현재 상태이고, 두 번째 원소는 상태를 바꾸어 주는 함수이다. 
    - 이 함수 setter함수라고 부른다. 

  ```react
  import React, { useState } from 'react'
  
  export default function Say() {
    const [message,setMessage] = useState('');
    const onClickEnter = () => setMessage("안녕하세요!");
    const onClickLeave = () => setMessage("안녕히 가세요!");
  
    return (
      <div>
        <button onClick={onClickEnter}>입장</button>
        <button onClick={onClickLeave}>퇴장</button>
        <h1>{message}</h1>
      </div>
    )
  }
  ```

  

- 한 컴포넌트에서 useState 여러  번 사용하기

  - useState는 한 컴포넌트에서 여러 번 사용해도 상관없다. 

  ```react
  import React, { useState } from 'react'
  
  export default function Say() {
    const [message,setMessage] = useState('');
    const onClickEnter = () => setMessage("안녕하세요!");
    const onClickLeave = () => setMessage("안녕히 가세요!");
  
    const [color, setColor] = useState("black");
  
    return (
      <div>
        <button onClick={onClickEnter}>입장</button>
        <button onClick={onClickLeave}>퇴장</button>
        <h1 style={{color}}>{message}</h1>
        <button style={{ color : "red"}} onClick={() => setColor("red")}>
          빨간색
        </button>
        <button style={{ color : "green"}} onClick={() => setColor("green")}>
          초록색
        </button>
        <button style={{ color : "blue"}} onClick={() => setColor("blue")}>
          파란색
        </button>
      </div>
    )
  }
  ```

  

- state를 사용할 때 주의 사항

  - state값을 바꾸어야 할 때는 setState 혹은 useState를 통해 전달받은 세터 함수를 사용해야 한다.
  - 배열이나 객체를 업데이트 할 때는 반드시 사본을 만들고 값을 업데이트 한 후에 세터 함수를 통해 업데이트한다.
    - spread 연산자 활용

  ```react
  const object = { a: 1, b: 2, c: 3};
  // 사본을 만들어서 b 값만 덮어 쓰기
  const nextObject = { ...object, b: 2};
  ```

  - 배열 다루기

  ```react
  const array = [
    { id: 1, value: true},
    { id: 2, value: true},
    { id: 3, value: false}
  ];
  
  // 새 항목 추가
  let nextArray = array.concat({ id: 4})
  // id가 2인 항목 제거
  nextArray.filter(item => item.id !== 2);
  // id가 1인 항목의 value를 false로 설정
  nextArray.map(item => (item.id === 1 ? {...item, value: false} : item));
  ```

  

### 이벤트 핸들링

#### 클래스형 컴포넌트

- 사용자가 **웹 브라우저에서 DOM 요소들과 상호 작용하는 것을 이벤트**라고 한다. 

- 리액트의 이벤트 시스템 사용할 때 주의 사항

  - 이벤트 이름은 카멜 표기법으로 작성한다.
    - `onclick` => `onClick`
  - 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달한다.

- DOM 요소에만 이벤트를 설정할 수 있다.

  - 우리가 직접 만든 컴포넌트에는 이벤트를 자체적으로 설정할 수 없다.
  - 컴포넌트 내부의 DOM 이벤트로 설정할 수 있다. 

  - 예제로 이벤트 핸들링 익히기

    - onChange 이벤트 핸들링하기
    - onChange 이벤트 설정
      - e 객체는 합성이벤트로 웹 브라우저의 네이티브 이벤트를 감싸는 객체이다.
      - 합성 이벤트는 네이티브 이벤트와 달리 **이벤트가 끝나고 나면 이벤트가 초기화되므로 정보를 참조할 수 없다.**
      - 만약 비동기적으로 이벤트 객체를 참조할 일이 있다면 `e.persist() `함수를 호출해야 한다.  

    ```react
    import React, { Component } from 'react'
    
    export default class EventPractice extends Component {
      render() {
        return (
          <div>
            <h1>이벤트 연습</h1>
            <input
              type= "text"
              name= "message"
              placeholder="아무거나 입력해 보세요"
              onChange= {
                // e객체는 SyntheticEvent로 웹 브라우저의 네이티브 이벤트를 감싸는 객체다.
                (e) => {
                  console.log(e.target.value);
                }
              }
            />
          </div>
        )
      }
    }
    ```

    - 버튼을 누를 때 comment 값을 공백으로 설정

    ```react
    import React, { Component } from 'react'
    
    export default class EventPractice extends Component {
      state = {
        message: ""
      }
    
      render() {
        return (
          <div>
            <h1>이벤트 연습</h1>
            <input
              type= "text"
              name= "message"
              placeholder="아무거나 입력해 보세요"
              value={this.state.message}
              onChange= {
                // e객체는 SyntheticEvent로 웹 브라우저의 네이티브 이벤트를 감싸는 객체다.
                (e) => {
                  this.setState({
                    message: e.target.value
                  })
                }
              }
            />
            <button onClick={
              () => {
                alert(this.state.message);
                this.setState({
                  message: ""
                });
              }
            }>
              확인
            </button>
          </div>
        )
      }
    }
    ```

    - 임의 메서드 만들기

      - 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달한다. 

      - 기본 방식
        - 함수가 호출될 때 this는 호출부에 따라 결정되므로, 클래스의 임의 메서드가  특정 HTML 요소의 이벤트로 등록되는 과정에서 메서드 this의 관계가 끊어져 버린다. 
        - 그래서 this를 컴포넌트 자신으로 제대로 가리키기 위해서는 메서드를 this와 바인딩하는 작업이 필요하다. 그렇지 않으면 this가 undefined를 가리키게 된다. 

      ```react
      import React, { Component } from 'react'
      
      export default class EventPractice extends Component {
        state = {
          message: ""
        }
      
        constructor(props) {
          super(props);
          this.handleChange = this.handleChange.bind(this);
          this.handleClick = this.handleClick.bind(this);
        }
      
        handleChange(e) {
          this.setState({
            message: e.target.value
          });
        }
      
        handleClick() {
          alert(this.state.message);
          this.setState({
            message: ""
          })
        }
      
        render() {
          return (
            <div>
              <h1>이벤트 연습</h1>
              <input
                type= "text"
                name= "message"
                placeholder="아무거나 입력해 보세요"
                value={this.state.message}
                onChange= {this.handleChange}
              />
              <button onClick={this.handleClick}>
                확인
              </button>
            </div>
          )
        }
      }
      ```

      - 더 쉬운 방식(Property initailizer Syntax)를 사용한 메서드 작성

        - 새 메서드를 만들 때마다 constructor도 수정해야 하기 때문에 좀 더 쉽게 하는 방법이다.
          - Babel의 transform-class-properties 문법을 사용하여 화살표 함수 형태로 메서드를 정의한다.

        ```react
        import React, { Component } from 'react'
        
        export default class EventPractice extends Component {
          state = {
            message: ""
          }
        
          handleChange = (e) => {
            this.setState({
              message: e.target.value
            });
          }
        
          handleClick = (e) => {
            alert(this.state.message);
            this.setState({
              message: ""
            })
          }
        
          render() {
            return (
              <div>
                <h1>이벤트 연습</h1>
                <input
                  type= "text"
                  name= "message"
                  placeholder="아무거나 입력해 보세요"
                  value={this.state.message}
                  onChange= {this.handleChange}
                />
                <button onClick={this.handleClick}>
                  확인
                </button>
              </div>
            )
          }
        }
        ```

      - input 여러개 다루기

      ```react
      import React, { Component } from 'react'
      
      export default class EventPractice extends Component {
        state = {
          username: "",
          message: ""
        }
      
        constructor(props) {
          super(props);
          this.handleChange = this.handleChange.bind(this);
          this.handleClick = this.handleClick.bind(this);
        }
      
        handleChange(e) {
          this.setState({
            [e.target.name]: e.target.value
          });
        }
      
        handleClick() {
          alert(this.state.username + ': ' + this.state.message);
          this.setState({
            username: "",
            message: ""
          })
        }
      
        render() {
          return (
            <div>
              <h1>이벤트 연습</h1>
              <input
                type= "text"
                name= "username"
                placeholder="사용자명"
                value={this.state.username}
                onChange= {this.handleChange}
              />
              <input
                type= "text"
                name= "message"
                placeholder="아무거나 입력해 보세요"
                value={this.state.message}
                onChange= {this.handleChange}
              />
              <button onClick={this.handleClick}>
                확인
              </button>
            </div>
          )
        }
      }
      ```

      - 다음 코드가 핵심
        - 객체 안에서  key를 [ ]로 감싸면 그 안에 넣은 레퍼런스가 가리키는 실제 값이 key 값으로 사용된다. 

      ```react
      handleChange(e) {
        this.setState({
          [e.target.name]: e.target.value
        });
      }
      ```

      - 예를 들어 다음과 같은 객체를 만들면

      ```react
      const name = "variantKey";
      const object = {
        [name]: "value"
      }
      // 결과는 다음과 같다. 
      {
        "variantKey": "value"
      }
      ```

      - onKeyPress 이벤트 핸들링

      ```react
      import React, { Component } from 'react'
      
      export default class EventPractice extends Component {
        state = {
          username: "",
          message: ""
        }
      
        handleChange = (e) => {
          this.setState({
            // 해당 인풋의 Name을 가리키니 input 여러개 사용해도 문제 없음
            [e.target.name]: e.target.value
          });
        }
      
        handleClick = () => {
          alert(this.state.username + ': ' + this.state.message);
          this.setState({
            username: "",
            message: ""
          })
        }
      
        handleKeyPress = (e) => {
          if(e.key === "Enter") {
            this.handleClick();
          }
        }
      
        render() {
          return (
            <div>
              <h1>이벤트 연습</h1>
              <input
                type= "text"
                name= "username"
                placeholder="사용자명"
                value={this.state.username}
                onChange= {this.handleChange}
              />
              <input
                type= "text"
                name= "message"
                placeholder="아무거나 입력해 보세요"
                value={this.state.message}
                onChange= {this.handleChange}
                onKeyPress={this.handleKeyPress}
              />
              <button onClick={this.handleClick}>
                확인
              </button>
            </div>
          )
        }
      }
      ```

      ​				

#### 함수형 컴포넌트

- 이전코드 함수형 컴포넌트로 바꾸기

```react
import React, {useState} from 'react'

const EventPractice = () => {
  const [username, setUsername] = useState("");
  const [message, setMessage] = useState("");
  const onChangeUsername = e => setUsername(e.target.value);
  const onChangeMessage = e => setMessage(e.target.value);

  const onClick = () => {
    alert(username + ": " + message);
    setUsername("");
    setMessage("");
  }

  const onKeyPress = e => {
    if (e.key === "Enter") {
      onClick();
    }
  }

  return (
    <div>
      <h1>이벤트 연습</h1>
        <input
          type= "text"
          name= "username"
          placeholder="사용자명"
          value={username}
          onChange= {onChangeUsername}
        />
        <input
          type= "text"
          name= "message"
          placeholder="아무거나 입력해 보세요"
          value={message}
          onChange= {onChangeMessage}
          onKeyPress={onKeyPress}
        />
        <button onClick={onClick}>
          확인
        </button>
    </div>
  )
}

export default EventPractice
```

- 인풋의 개수가 많아진다면 e.target.name을 활용하자

```react
import React, {useState} from 'react'

const EventPractice = () => {
  const [form , setForm] = useState({
    username: "",
    message: ""
  })
  const { username, message } = form

  const onChange = e => {
    const nextForm = {
      // 기존의 form 내용을 이 자리에 복사한 뒤
      ...form,
      // 원하는 값을 덮어 씌우기
      [e.target.name]: e.target.value
    };
    setForm(nextForm);
  }


  const onClick = () => {
    alert(username + ": " + message);
    setForm({
      username: "",
      message: ""
    })
  }

  const onKeyPress = e => {
    if (e.key === "Enter") {
      onClick();
    }
  }

  return (
    <div>
      <h1>이벤트 연습</h1>
        <input
          type= "text"
          name= "username"
          placeholder="사용자명"
          value={username}
          onChange= {onChange}
        />
        <input
          type= "text"
          name= "message"
          placeholder="아무거나 입력해 보세요"
          value={message}
          onChange= {onChange}
          onKeyPress={onKeyPress}
        />
        <button onClick={onClick}>
          확인
        </button>
    </div>
  )
}

export default EventPractice
```







### ref: DOM에 이름 달기

#### ref는 어떤 상황에서 사용해야 할까?

- **정답은 DOM을 꼭 직접적으로 건드려야 할 때**이다.
- 예제 컴포넌트 생성

```react
import React, { Component } from 'react';
import "./ValidationSample.css";

export default class ValidationSample extends Component {
  state = {
    password: "",
    clicked: false,
    validated: false
  }

  handleChanged = (e) => {
    this.setState({
      password: e.target.value
    });
  }

  handleButtonClick = () => {
    this.setState({
      clicked: true,
      validated: this.state.password === "0000"
    })
  }

  render() {
    return (
      <div>
        <input
          type="password"
          value={this.state.password}
          onChange = {this.handleChanged}
          className = {this.state.clicked ? (this.state.validated ? "success" : "failure") : ""}
        />
        <button onClick={this.handleButtonClick}>검증하기</button>
      </div>
    )
  }
}

```

- DOM을 꼭 사용해야 하는 상황
  - 특정 input에 포커스 주기
  - 스크롤 박스 조작하기
  - Canvas 요소에 그림 그리기 



#### ref 사용

- 콜백 함수를 통한 ref 설정

  - ref를 달고자 하는 요소에 ref라는 콜백 함수를 props로 전달해 주면 된다. 
  - 콜백 함수는  ref 값을 파라미터로 전달받는다. 그리고 함수 내부에서 파라미터로 받은 ref를 컴포넌트의 멤버 변수로 설정해 준다.
  - 사용 예시

  ```react
  <input ref={(ref) => {this.input=ref}} />
  ```

- creatRef를 통한 ref 설정

  - 리액트에 내장되어 있는 createRef 라는 함수를 사용한다.

  - 예시 코드

  ```react
  import React, { Component } from 'react'
  
  export default class RefSample extends Component {
    input = React.createRef();
  
    handleFocus = () => {
      this.input.current.focus();
    }
  
    render() {
      return (
        <div>
          <input ref={this.input}/>
        </div>
      )
    }
  }
  ```

  

- onClick 이벤트 코드 수정

  - onClick 이벤트가 발생할 대 input에 포커스를 주도록 수정했다.

  ```react
  handleButtonClick = () => {
      this.setState({
        clicked: true,
        validated: this.state.password === "0000"
      })
      this.input.focus();
    }
  
    render() {
      return (
        <div>
          <input
            ref = {(ref) => this.input = ref}
            type="password"
            value={this.state.password}
            onChange = {this.handleChanged}
            className = {this.state.clicked ? (this.state.validated ? "success" : "failure") : ""}
          />
          <button onClick={this.handleButtonClick}>검증하기</button>
        </div>
      )
    }
  ```

  

####  컴포넌트에 ref 달기 

- 주로 이 방법은 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 사용한다. 
- 사용법

```react
<MyComponent 
	ref={(ref) => {this.myComponent=ref}}  
/>
```

- 스크롤 박스가 있는 컴포넌트를 하나 만들고, 스크롤바를 아래로 내리는 작업을 부모 컴포넌트에서 실행해보자.

- 컴포넌트 파일 생성

```react
import React, { Component } from 'react'

export default class ScrollBox extends Component {
  render() {
    const style = {
      border: "1px solid black",
      height: "300px",
      width: "300px",
      overflow: "auto",
      position: "relative"
    };

    const innerStyle = {
      width: "100%",
      height: "650px",
      background: "linear-gradient(white, black)"
    }

    return (
      <div
        style={style}
        ref={(ref) => {this.box=ref}}>
        <div style={innerStyle} />
      </div>
    )
  }
}
```

- 컴포넌트에 메서드 생성

  - 컴포넌트에 스크롤바를 맨 아래쪽으로 내리는 메서드를 만들겠다. 자바스크립트로 스크롤바를 내릴 때는  DOM 노드가 가진 다음 값들을 사용한다.

  - scrollTop: 세로 스크롤바 위치(0 ~350)
  - scrollHeight: 스크롤이 있는 박스 안의 div 높이(650)
  - clientHeight: 스크롤이 있는 박스의 높이(300)

```react
import React, { Component } from 'react'

export default class ScrollBox extends Component {
  scrollToBottom = () => {
    const { scrollHeight, clientHeight } = this.box;
    //스크롤바를 맨 아래쪽으로 내리려면 scrollHeight - clientHeight 빼면 된다.
    this.box.scrollTop = scrollHeight - clientHeight;
  }
  render() {
    const style = {
      border: "1px solid black",
      height: "300px",
      width: "300px",
      overflow: "auto",
      position: "relative"
    };

    const innerStyle = {
      width: "100%",
      height: "650px",
      background: "linear-gradient(white, black)"
    }


    return (
      <div
        style={style}
        ref={(ref) => {this.box=ref}}>
        <div style={innerStyle} />
      </div>
    )
  }
}
```

```react
import React, {Component} from "react";
import "./App.css"
import ScrollBox from "./ScrollBox";

class App extends Component {
  render() {
    return (
      <div>
        <ScrollBox ref={(ref) => this.scrollBox=ref}/>
        <button onClick={() => this.scrollBox.scrollToBottom()}>
          맨 밑으로
        </button>
      </div>
    )
  }


}
export default App;
```





### 컴포넌트 반복

#### 자바스크립트 배열의 map() 함수

- 문법

  `arr.map(callback, [thisArg])`

  - callback: 새로운 배열의 요소를 생성하는 함수로 파라미터는 다음 세 가지이다.
    - currentValue: 현재 처리하고 있는 요소
    - index: 현재 처리하고 있는 요소의 index 값
    - array: 현재 처리하고 있는 원본 배열
  - thisArg(선택 항목): callback 함수 내부에서 사용할 this 레퍼런스

- 예제

  ```js
  var numbers = [1, 2, 3, 4, 5];
  
  var processed = numbers.map(function(num) {
    return num * num;
  })
  // [ 1, 4, 9, 16, 25]
  console.log(processed);
  ```

- ES6으로 변환

  ```react
  const numbers = [1, 2, 3, 4, 5];
  const result = numbers.map((num) => num * num);
  console.log(result)
  ```



#### 데이터 배열을 컴포넌트 배열로 변환하기

- 컴포넌트 수정하기
  - 근데 아래 코드처럼만 작성하면 "key" prop이 없다는 경고 메시지를 표시한다.

```react
import React from 'react'

const IterationSample = () => {
  const names = ["눈사람", "얼음", "눈", "바람"];
  const nameList = names.map(name => <li>{name}</li>);
  return (
    <ul>
      {nameList}
    </ul>
  )
}

export default IterationSample
```

- Key

  - **리액트에서 key는 컴포넌트 배열을 렌더링했을 때 어떤 원소에 변동이 있었는지 알아내려고 사용한다.**
  - 유동적인 데이터를 다룰 때는 원소를 새로 생성, 제거, 수정할 수 있다. 
  - **key가 있으면 Virtual DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서 어떤 변화가 일어났는지 빠르게 알아낼 수 있다.** 
  - key값은 언제나 유일해야 한다. 데이터가 가진 고윳값을 key값으로 설정해야 한다. 

  ```react
  const articleList = articles.map(article => (
    <Article
      title = {article.title}
      writer = {article.writer}
      key = {article.id}
    />
  );
  ```

  - map에서는 보통 callback 함수의 index를 사용한다. 
    - 근데 고유한 값이 없을 때만 index를 key로 사용하자. index를 key로 사용하면 배열이 변경될 때 효율적으로 리렌더링하지 못한다. 
  - 예시

  ```react
  import React from 'react'
  
  const IterationSample = () => {
    const names = ["눈사람", "얼음", "눈", "바람"];
    const nameList = names.map((name, index) => <li key={index}>{name}</li>);
    return (
      <ul>
        {nameList}
      </ul>
    )
  }
  
  export default IterationSample
  ```

- 응용

  - 고윳값 만드는 예시 
  - 예시 코드

  ```react
  import React, { useState } from 'react'
  
  const IterationSample = () => {
    const [names, setNames] = useState([
      { id: 1, text: "눈사람"},
      { id: 2, text: "얼음"},
      { id: 3, text: "눈"},
      { id: 4, text: "바람"},
    ]);
    const [inputText, setInputText] = useState("");
    const [nextId, setNextId] = useState(5);
  
    const onChange = e => setInputText(e.target.value)
    const onClick = () => {
      const nextNames = names.concat({
        id: nextId,
        text: inputText
      });
      setNextId(nextId + 1);
      setNames(nextNames);
      setInputText("");
    }
  
  
    const nameList = names.map(name => <li key={name.id}>{name.text}</li>)
    return (
      <>
       <input value={inputText} onChange={onChange}/>
       <button onClick={onClick}>추가</button>
       <ul>{nameList}</ul>
      </>
    )
  }
  
  export default IterationSample
  ```

  - 위의 코드에서 우리는 input에 어떤 값을 넣으면 새로운 id와 text가 names 배열에 추가된다. 
  - 여기서 push메서드를 사용하지 않고 concat 메서드를 사용한 이유는 **push는 기존 배열 자체를 변경해 주는 반면, concat은 새로운 배열을 만들어 준다는 차이점이 있다.**
  - **리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서 새로운 값을 상태로 설정해야 한다. **이를 불변성 유지라고 하는데, **나중에 리액트 컴포넌트 성능을 최적화할 수 있다.**

  - 매우 중요:**데이터의 불변성을 유지하면서 배열의 특정항목을 지울때는 filter() 내장 함수를 사용해야 한다.** 
  - 데이터 제거 기능 구현
    - onDoubleClick 이벤트 활용

  ```react
  import React, { useState } from 'react'
  
  const IterationSample = () => {
    const [names, setNames] = useState([
      { id: 1, text: "눈사람"},
      { id: 2, text: "얼음"},
      { id: 3, text: "눈"},
      { id: 4, text: "바람"},
    ]);
    const [inputText, setInputText] = useState("");
    const [nextId, setNextId] = useState(5);
  
    const onChange = e => setInputText(e.target.value)
    const onClick = () => {
      const nextNames = names.concat({
        id: nextId,
        text: inputText
      });
      setNextId(nextId + 1);
      setNames(nextNames);
      setInputText("");
    }
  
    const onRemove = id => {
      const nextNames = names.filter(name => name.id !== id);
      setNames(nextNames);
    }
  
    const nameList = names.map(name => (
      <li key={name.id} onDoubleClick={() => onRemove(name.id)}>
        {name.text}
      </li>
    ))
  
    return (
      <>
       <input value={inputText} onChange={onChange}/>
       <button onClick={onClick}>추가</button>
       <ul>{nameList}</ul>
      </>
    )
  }
  
  export default IterationSample
  ```

  

### 컴포넌트의 라이프사이클 메서드

모든 리액트는 라이프사이클(수명 주기)이 존재한다. 

컴포넌트를 처음으로 렌더링할 때 어떤 작업을 처리해야 하거나 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 수도 있고, 불필요한 업데이트를 방지해야 할 수도 있다. 



#### 라이프사이클 메서드의 이해

- 라이프사이클 메서드의 종류는 총 9가지이다.

-  **WIll 접두사가 붙은 메서드는 어떤 작업을 작동하기 전에 실행되는 메서드**이고, **Did 접두사가 붙은 메서드는 어떤 작업을 작동한 후에 실행되는 메서드이다.**

- 라이플프사이클은 총 세 가지, 즉 **마운트, 업데이트, 언마운트** 카테고리로 나눈다.  

- 마운트

  - DOM이 생성되고 웹 브라우저상에 나타나는 것을 마운트라고 한다. 
  - 다음은 호출되는 메서드다
    - constructor 
      - 컴포넌트를 새로 만들때마다 호출되는 클래스 생성자 메서드
    - getDerivedStateFromProps
      - props에 있는 값을 state에 넣을때 사용하는 메서드
    - render
      - 우리가 준비한 UI를 렌더링하는 메서드이다.
    - componentDidMount 
      - 컴포넌트가 웹 브라우저상에 나타난 후 호출하는 메서드이다. 

- 업데이트

  - 총 네 가지의 경우 업테이트한다.

    - props가 바뀔 때
    - state가 바뀔 때
    - 부모 컴포넌트가 리렌더링될 때
    - this.forceUpdate로 강제로 렌더링을 트리거할 때 

  - 다음은 호출되는 메서드이다.

    - getDerivedStateFromProps
      - 마운트 과정에서도 호출되며, 업데이트가 시작하기도 전에 호출된다.
      - props의 변화에 따라 state 값에도 변화를 주고 싶을 때 사용한다. 
    - ShouldComponentUpdate
      - 컴포넌트가 리렌더링을 해야 할지 말아야 할지를 결정하는 메서드
      - true/false를 반환한다. 
      - true를 반환하면 다음 라이프사이클 메서드를 계속 실행하고, false 작업 중단(리렌더링 안 됨)
      - `this.forceUpdate`함수를 사용하면 이 과정 생략하고 바로 render 함수를 호출한다.  
    - render
      - 컴포넌트를 리렌더링한다.
    - getSnapShotBeforeUpdate
      - 컴포넌트 변화를 DOM에 반영하기 바로 직전에 호출하는 메서드이다. 
      - 최종본 인증샷 찍는거다. 

    - componentDidUpdate
      - 컴포넌트의 업데이트 작업이 끝난 후 호출하는 메서드이다.  

- 언마운트
  - 컴포넌트를 DOM에서 제거하는 것을 언마운트라고 한다
    - componentWilunmount
      - 컴포넌트가 웹 브라우저상에서 사라지기 전에 호출하는 메서드이다. 



#### 라이프사이클 메서드 살펴보기

- render() 함수

  `render() { ... }`

  - 컴포넌트 모양새를 정의한다. 그래서 매우 중요한 메서드이다. 
  - 라이프사이클 메서드 중 유일한 필수 메서드이기도 하다. 
  - 이 메서드 안에서 this.props와 this.state에 접근 가능, 리액트 요소를 반환
  - 요소는 div 같은 태그도 될 수 있고, 아무것도 보여주고 싶지 않다면 null 값이나 false값을 반환하도록 하세요
  - 다음 사항을 주의하세요
    - 메서드 안에서 이벤트 설정이 아닌 곳에서 setState을 사용하면 안 되고
    - 브라우저의 DOM에 접근해서도 안 된다.
    - DOM 정보를 가져오거나 state 변화를 줄 때는 componentDidMount에서 처리해야 한다.

- constructor 메서드

  `constructor(props) { ... }`

  - 이것은 컴포넌트 생성자 메서드로 컴포넌트를 만들 때 처음으로 실행된다. 이 메서드에서는 초기 state를 정할 수 있다.

  

- getDerivedStateFromProps 메서드

  - 리액트 v16 이후에 새로 만든 라이프사이클 메서드이다. 
  - **props로 받아온 값을 state에 동기화시키는 용도로 사용하며**, 컴포넌트가 마운트될 때와 업데이트될 때 호출된다.

  ```react
  static getDerivedStateFromProps(nextProps, prevState) {
    if(nextProps.value !== prevState.value) {
      return { value: nextProps.value };
    }
    // state를 변경할 필요가 없다면 null을 반환
    return null
  }
  ```

- componentDidMount 메서드

  `componentDidMount() { ... }`

  - 이것은 컴포넌트를 만들고, 첫 렌더링을 다 마친 후 실행한다. 
  - 이 안에서 다른 자바스크립트 라이브러리 또는 프레임워크의 함수를 호출하거나, setTimeout, setInterval, 네트워크 요청 같은 비동기 작업을 처리하면 된다. 

- shouldComponentUpdate 메서드

  `shouldComponentUpdate(nextProps, nextState) {...}`

  - 이것은 props 또는 state를 변경했을 때, 리렌더링을 시작할지 여부를 지정하는 메서드이다. 
  - 반드시 true / false를 반환해야 한다. 
  - 메서드 안에서 현재 props와 state은 this.props와 this.state로 접근하고, 새로 설정될 props 또는 state는 nextProps와 nextState로 접근할 수 있다. 
  - 프로젝트 성능을 최적화할 때, 상황에 맞는 알고리즘을 작성하여 리렌더링을 방지할 대는 false값을 반환하게 한다. 

- getSnapShotBeforeUpdate 메서드

  - 리액트 16버전 이후 만든 메서드
  - render에서 만들어진 결과물이 브라우저에 실제로 반영되기 직전에 호출된다. 
  - 이 메서드에서 반환하는 값은 componentDidUpdate에서 세 번째 파라미터인 snapshot 값으로 전달 받을 수 있다. 
  - **주로 업데이트하기 직전의 값을 참고할 일이 있을 때 활용(ex)스크롤바 위치 유지);**

  ```react
  getSnapshotBeforeUpdate(prevProps, prevState) {
    if(prveState.array !== this.state.array) {
      const { scrollTop, scrollHeight } = this.list
      return { scrollTop, scrollHeight};
    }
  }
  ```

- componentDidUpdate 메서드

  `componentDidUpdate(prevProps, prevState, snapshot) { ... }`

  - 리렌더링 완료후 실행한다. 업데이트가 끝난 직후이므로, DOM관련 처리를 해도 무방하다.
  - 여기서는 prevProps 또는 prevState를 사용하여 컴포넌트가 이전에 가졌던 데이터에 접근할  수 있다. 
  - getSnapshotBeforeUpdate에서 반환한 값이 있다면 여기서 snapshot 값을 전달받을 수 있다. 

- componentWillUnmount 메서드

  `componentWillUnmount() { ... }`

  - 이것은 컴포넌트를 DOM에서 제거할 때 실행한다. componentDidMount에서 등록한 이벤트, 타이머, 직접 생성한 DOM이 있다면 여기서 제거 작업을 해야 한다.

- componentDIdCatch 메서드

  - v16에 새롭게 도입되었고
  - **컴포넌트 렌더링 도중에 에러가 발생했을 때 애플리케이션이 먹통이 되지 않고 오류 UI를 보여 줄 수 있게 해준다. **

  ```react
  componentDidCatch(error, info) {
    this.setState({
      error: true
    });
    console.log({ error, info });
  }
  ```

  - error에서 어떤 에러가 발생했는지 알려 주며, info 파라미터는 어디에 있는 코드에서 오류가 발생했는지에 대한 정보를 준다. 
  - 이 메서드를 사용할 때는 컴포넌트 자신에게 발생하는 에러를 잡아낼 수 없고 자신의 this.props.children으로 전달되는 컴포넌트에서 발생하는 에러만 잡아낼 수 있다는 점을 알아두자. 



#### 라이프사이클 메서드 사용하기

- LifeCycleSample.js

```react
import React, { Component } from 'react'

export default class LifeCycleSample extends Component {
  state = {
    number: 0,
    color: null,
  }

  myRef = null;

  constructor(props) {
    super(props);
    console.log("constructor");
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    console.log("getDerivedStateFromProps")
    if(nextProps.color !== prevState.color) {
      return { color: nextProps.color };
    }

    return null
  }

  componentDidMount() {
    console.log("componentDidMount");
  }

  shouldComponentUpdate(nextProps, nextState) {
    // nextProps, nextState은 object형태로 들어온다. 
    console.log("shouldComponentUpdate", nextProps, nextState);
    // 숫자의 마지막 자리가 4면 리렌더링하지 않는다.
    return nextState.number % 10 !== 4;
  }

  componentWillUnmount() {
    console.log("componentWillUnmount")
  }

  handleClick = () => {
    this.setState({
      number: this.state.number + 1
    });
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    console.log("getSnapshotBeforeUpdate");
    if(prevProps.color !== this.props.color) {
      return this.myRef.style.color;
    }
    return null
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log("componentDidUpdate", prevProps, prevState);
    if(snapshot) {
      console.log("업데이트되기 직전 색상:", snapshot);
    }
  }

  render() {
    console.log("render");
    const style = {
      color: this.props.color
    }

  return (
    <div>
      {/* 여기 ref는 위에 this.myref.style.color을 통해 새로운 컬러를 입혀준다. */}
      <h1 style={style} ref={ref => this.myRef = ref}>
        {this.state.number}
      </h1>
      <p>color: {this.state.color}</p>
      <button onClick={this.handleClick}>
        더하기
      </button>
    </div>
   )
  }
}
```

- App.js

```react
import React, {Component} from "react";
import "./App.css"
import LifeCycleSample from "./LifeCycleSample";

function getRandomColor() {
  return "#" + Math.floor(Math.random() * 16777215).toString(16);
}

class App extends Component {
  state =  {
    color: "#000000"
  }

  handleClick = () => {
    this.setState({
      color: getRandomColor()
    });
  }

  render() {
    return (
      <div>
        <button onClick={this.handleClick}>랜덤 색상</button>
        <LifeCycleSample color={this.state.color}/>
      </div>
    )
  }


}
export default App;
```

- 에러 잡아내기 

```react
return (
    <div>
     {/*없는 값- 의도적 에러*/}
      {this.props.missing.value}
      <h1 style={style} ref={ref => this.myRef = ref}>
        {this.state.number}
      </h1>
      <p>color: {this.state.color}</p>
      <button onClick={this.handleClick}>
        더하기
      </button>
    </div>
   )
```

```react
import React, { Component } from 'react'

// ErrorBoundary.js
export default class ErrorBoundary extends Component {
  state = {
    error: false
  };

  componentDidCatch(error, info) {
    this.setState({
      error: true
    });
    console.log({ error, info })
  }

  render() {
      if (this.state.error) return <div>에러가 발생했다.</div>
      return this.props.children;
  }
}
```

```react
//App.js
render() {
  return (
    <div>
      <button onClick={this.handleClick}>랜덤 색상</button>
      <ErrorBoundary>
      	<LifeCycleSample color={this.state.color}/>
      </ErrorBoundary>
      </div>
 )
}
```





### Hooks

#### useState

```react
import React, { useState } from 'react'

export default function Counter() {
  const [value, setValue] = useState(0);

  return (
    <div>
      <p>
        현재 카운터 값은 <b>{value}</b>입니다.
      </p>
      <button onClick={() => setValue(value + 1)}>+1</button>
      <button onClick={() => setValue(value - 1)}>-1</button>
    </div>
  )
}
```

- useState는 코드 상단에서 import 구문을 통해 불러오고, 다음과 같이 사용한다.

`const [value, setValue] = useState(기본값)`

- useState 함수의 파라미터에는 상태의 기본값을 넣어 준다.
- 함수 호출하면 배열이 반환, 배열의 첫 번째 원소는 상태 값, 두 번째 원소는 상태를 설정하는 함수
- 함수에 파라미터를 넣어서 호출하면 전달받은 파라미터로 값이 바뀌고 컴포넌트가 정상적으로 리렌더링됩니다.

- useState를 여러 번 사용하기

  - 하나의 useState 함수는 하나의 상태 값만 관리할 수 있다.  컴포넌트에서 관리해야 할 상태가 여러 개라면 useState를 여러 번 사용하면 된다. 

  - 예시

```react
import React, { useState } from 'react'

export default function Info() {
  const [name, setName] = useState("");
  const [nickname, setNickname] = useState("");

  const onChangeName = e => {
    setName(e.target.value);
  };

  const onChangeNickname = e => {
    setNickname(e.target.value);
  }

  return (
    <div>
      <div>
        <input value={name} onChange={onChangeName}/>
        <input value={nickname}  onChange={onChangeNickname}/>
        <div>
          <b>이름:</b> {name}
        </div>
        <div>
          <b>닉네임:</b> {nickname}
        </div>
      </div>
    </div>
  )
}
```



#### useEffect

- useEffect는 리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook이다. 

- 클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를 합친 형태다.

- 마운트될 때만 실행하고 싶을 때

  - 함수의 두 번째 파라미터로 비어 있는 배열을 넣어 주면 된다.

  ```react
  useEffect(() => {
    console.log("렌더링 완료");
    console.log({
      name,
      nickname
    });
  }, []);
  ```

  

- 특정 값이 업데이트될 때만 실행하고 싶을 때

  - useEffect의 두 번째 파라미터로 전달되는 배열 안에 검사하고 싶은 값을 넣어 주면 된다. 
  - 배열 안에는 useState를 통해 관리하고 있는 상태를 넣어 주어도 되고, props로 전달받은 값을 넣어 줘도 된다. 
  - 전문용어로 dependency라고 한다.
  - 예시

  ```react
  useEffect(() => {
    console.log("렌더링 완료");
    console.log({
      name,
      nickname
    });
  }, [name]);
  ```

  

- 뒷정리하기

  - 컴포넌트가 unmount되기 전이나 업데이트되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect에서 cleanup 함수를 반환해 주어야 합니다. 
  - 예시 

  ```react
  // Info.js
  useEffect(() => {
    console.log("effect");
    console.log(name);
    return () => {
      console.log("cleanup");
      console.log(name);
    }
  // 이렇게 하면 unmount 될때만 cleanup함수 호출   
  }, []);
  
  // App.js
  import React, { useState } from "react";
  import "./App.css"
  import Info from "./Info";
  
  
  const App = () => {
    const [visible, setVisible] = useState(false);
  
    return (
      <div>
        <button
          onClick={() => {
            setVisible(!visible);
          }}
        >
          {visible ? "숨기기" : "보이기"}
        </button>
        <hr />
        {visible && <Info />}
      </div>
    )
  }
  export default App;
  ```

  

#### useReducer

- 리듀서는 현재 상태, 그리고 업데이트를 위해 필요한 정보를 담은 액션값을 전달받아 새로운 상태를 반환하는 함수이다. 

- **반드시 새로운 상태를 만들 때는 불변성을 지켜야 한다**

- useReducer를 사용하면 가장 큰 장점은 컴포넌트 업데이트 로직을 컴포넌트 바깥으로 빼낼 수 있다는 것이다. 

- 카운터 구현하기

  - 예시

  ```react
  import React, { useReducer } from 'react'
  
  function reducer(state, action) {
  
    switch (action.type) {
      case "Increment":
        return { value: state.value + 1};
      case "Decrement":
        return { value: state.value - 1};
      default:
        // 아무것도 해당되지 않을 때 기존 상태 반환
        return state;
    }
  }
  
  const Counter = () => {
    const [state, dispatch] = useReducer(reducer, {value : 0});
  
    return (
      <div>
        <p>
          현재 카운터 값은 <b>{state.value}</b>
        </p>
        <button onClick={() => dispatch({ type : "Increment"})}>+1</button>
        <button onClick={() => dispatch({ type : "Decrement"})}>-1</button>
      </div>
    )
  }
  
  export default Counter;
  ```

  - useRedcuer의 **첫 번째 파라미터에는 리듀서 함수를 넣고, 두 번째 파라미터에는 해당 리듀서의 기본값을 넣어준다.**
  - 이 Hook을 사용하면 state 값과 dispatch 함수를 받아 온다. 
  - 여기서 **state는 현재 가리키고 있는 상태고, dispatch는 액션을 발생시키는 함수다.**
    - dispatch(action)과 같은 형태로, 함수 안에 파라미터로 액션 값을 넣어 주면 리듀서 함수가 호출되는 구조

- 인풋 상태 관리하기

  - 예시

  ```react
  import React, { useReducer } from 'react'
  
  
  
  function reducer(state, action) {
    return {
      ...state,
      [action.name]: action.value
    }
  }
  
  const Info = () => {
    const [state, dispatch] = useReducer(reducer, {
      name: "",
      nickname: "",
    });
  
    const {name, nickname} = state;
  
    const onChange = e => {
      dispatch(e.target)
    };
  
    return (
      <div>
        <div>
          <input name = "name" value={name} onChange={onChange}/>
          <input name = "nickname" value={nickname}  onChange={onChange}/>
          <div>
            <b>이름:</b> {name}
          </div>
          <div>
            <b>닉네임:</b> {nickname}
          </div>
        </div>
      </div>
    )
  }
  
  export default Info;
  ```

  - e.target 값 자체를 액션 값으로 사용했다. 
  - 이렇게 하면 인풋을 관리하면 아무리 인풋 개수가 많아져도 코드를 짧고 깔끔하게 유지할 수 있다. 



- useMemo

  - useMemo를 사용하면 함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있다.

  - 문제 코드

  ```react
  import React, { useState } from 'react'
  
  const getAverage = numbers => {
    console.log("평균값 계산 중..");
    if (numbers.length === 0) return 0;
    const sum = numbers.reduce((a, b) => a + b);
    return sum / numbers.length;
  
  }
  
  
  const Average = () => {
    const [list, setList] = useState([]);
    const [number, setNumber] = useState("");
  
    const onChange = e => {
      setNumber(e.target.value);
    };
  
    const onInsert = e => {
      const nextList = list.concat(parseInt(number));
      setList(nextList);
      setNumber("");
    };
  
    return (
      <div>
        <input value={number} onChange={onChange}/>
        <button onClick={onInsert}>등록</button>
        <ul>
          {list.map((value, index) => (
            <li key={index}>{value}</li>
          ))}
        </ul>
        <div>
          <b>평균값:</b> {getAverage(list)}
        </div>
      </div>
    )
  }
  
  export default Average
  ```

  - 이렇게 하면 인풋 내용이 수정될 때 getAverage 함수가 호출된다. 너무 낭비
    - 상태가 변경되면서 리렌더링되고 함수가 재실행되는 거임
  - 그래서 useMemo를 사용하면 최적화 가능
  - 수정 코드

  ```react
  import React, { useState, useMemo } from 'react'
  
  const getAverage = numbers => {
    console.log("평균값 계산 중..");
    if (numbers.length === 0) return 0;
    const sum = numbers.reduce((a, b) => a + b);
    return sum / numbers.length;
  
  }
  
  const Average = () => {
    const [list, setList] = useState([]);
    const [number, setNumber] = useState("");
  
    const onChange = e => {
      setNumber(e.target.value);
    };
  
    const onInsert = e => {
      const nextList = list.concat(parseInt(number));
      setList(nextList);
      setNumber("");
    };
  
    const avg = useMemo(() => getAverage(list), [list])
  
    return (
      <div>
        <input value={number} onChange={onChange}/>
        <button onClick={onInsert}>등록</button>
        <ul>
          {list.map((value, index) => (
            <li key={index}>{value}</li>
          ))}
        </ul>
        <div>
          <b>평균값:</b> {avg}
        </div>
      </div>
    )
  }
  
  export default Average
  ```

  - 첫 번째 함수는 평균구하는 함수, 두 번째는 list의 값을 캐싱해서 렌더링 하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식





#### useCallback

- **값을 재사용 하는 것이면 useMemo, 함수를 재사용하려면 useCallback을 사용하자.**

- useMemo랑 마찬가지로 렌더링 성능을 최적화해야 하는 상황에서 사용한다. 
- 컴포넌트의 렌더링이 자주 발생하거나 렌더링해야 할 컴포넌트의 개수가 많아지면 이 부분을 최적화해 주는 것이 좋다. 

- 예시

  ```react
  import React, { useState, useMemo, useCallback } from 'react'
  
  const getAverage = numbers => {
    console.log("평균값 계산 중..");
    if (numbers.length === 0) return 0;
    const sum = numbers.reduce((a, b) => a + b);
    return sum / numbers.length;
  
  }
  
  
  const Average = () => {
    const [list, setList] = useState([]);
    const [number, setNumber] = useState("");
  
    const onChange = useCallback(e => {
      setNumber(e.target.value);
      // 컴포넌트가 처음 렌더링 될 때만
    }, []);
  
    const onInsert = useCallback(e => {
      const nextList = list.concat(parseInt(number));
      setList(nextList);
      setNumber("");
      // number, list가 바뀔때마다
    }, [number, list]);
  
    const avg = useMemo(() => getAverage(list), [list])
  
    return (
      <div>
        <input value={number} onChange={onChange}/>
        <button onClick={onInsert}>등록</button>
        <ul>
          {list.map((value, index) => (
            <li key={index}>{value}</li>
          ))}
        </ul>
        <div>
          <b>평균값:</b> {avg}
        </div>
      </div>
    )
  }
  
  export default Average
  ```

  - useCallback의 첫 번째 파라미터에는 생성하고 싶은 함수를 넣고, 두 번째 파라미터에는 배열을 넣으면 된다. 
  - 이 배열은 dependency이므로 어떤 값이 바뀌었을 때 함수를 새로 생성하는지 명시해야 한다.
  - 함수 내부에서 상태 값에 의존해야 할 때는 그 값을 반드시 두 번째 파라미터 안에 포함시켜 주어야 한다. 
    - 위의 onchange는 설정만 하기 때문에 배열에 비어도 되지만
    - onInsert는 기존의 number, list를 조회해서 nextList를 생성하기 때문에 반드시 배열 안에 number, list를 넣어줘야 한다. 



#### useRef

- 함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해 준다. 
- Average 컴포넌트에서 등록 버튼을 눌렀을 때 포커스가 인풋 쪽으로 넘어가도록 코드를 작성해보겠다
- 예시

```react
import React, { useState, useMemo, useCallback, useRef } from 'react'

const getAverage = numbers => {
  console.log("평균값 계산 중..");
  if (numbers.length === 0) return 0;
  const sum = numbers.reduce((a, b) => a + b);
  return sum / numbers.length;

}


const Average = () => {
  const [list, setList] = useState([]);
  const [number, setNumber] = useState("");
  const inputEl = useRef(null);

  const onChange = useCallback(e => {
    setNumber(e.target.value);
    // 컴포넌트가 처음 렌더링 될 때만
  }, []);

  const onInsert = useCallback(e => {
    const nextList = list.concat(parseInt(number));
    setList(nextList);
    setNumber("");
    // number, list가 바뀔때마다
    inputEl.current.focus();
  }, [number, list]);

  const avg = useMemo(() => getAverage(list), [list])

  return (
    <div>
      {/* input에 참조설정한다*/}
      <input value={number} onChange={onChange} ref={inputEl}/>
      <button onClick={onInsert}>등록</button>
      <ul>
        {list.map((value, index) => (
          <li key={index}>{value}</li>
        ))}
      </ul>
      <div>
        <b>평균값:</b> {avg}
      </div>
    </div>
  )
}

export default Average
```

- useRef를 사용하여 ref를 설정하면 useRef를 통해 만든 객체 안의 current 값이 실제 엘리먼트를 가리킨다. 

- 로컬 변수 사용하기

  - 로컬 변수란 렌더링과 상관없이 바뀔 수 있는 값을 의미
  - 함수형 컴포넌트 예시 

  ```react
  import React, { useRef } from "react";
  
  const RefSample = () => {
    const id = useRef(1);
    const setId = (n) => {
      id.current = n;
    }
    const parentId = () => {
      console.log(id.current);
    }
    return (
      <div>
        refsample
      </div>
    );
  };
  
  export default RefSample;
  ```

  - **이렇게 ref 안의 값이 바뀌어도 컴포넌트가 렌더링되지 않는다는 점에 주의하자.** 렌더링과 관련되지 않는 값을 관리할 때만 이러한 방식으로 코드를 작성하자.



#### 커스텀 Hooks 만들기

- 여러 컴포넌트에서 비슷한 기능을 공유할 경우, 이를 나만의 Hook으로 작성하여 로직을 재사용할 수 있다.

- 예시

```react
import { useReducer } from 'react'

function reducer(state, action) {
  return {
    ...state,
    [action.name] : action.value
  }
}

// 초깃값만 전달받는다. 
const useInputs = (initialForm) => {
  const [state, dispatch] = useReducer(reducer, initialForm);
  const onChange = e => {
    dispatch(e.target);
  };
  // state, onChange를 보내서 다른 곳에서 사용
  return [state, onChange];
}

export default useInputs
```



```react
import React from 'react'
import useInputs from "./useInputs";


const Info = () => {
  // useInputs.js에서 state, onChange함수를 import해서 사용
  const [state, onChange] = useInputs({
    name: "",
    nickname: "",
  });
  
  const {name, nickname} = state;

  return (
    <div>
      <div>
        <input name = "name" value={name} onChange={onChange}/>
        <input name = "nickname" value={nickname}  onChange={onChange}/>
        <div>
          <b>이름:</b> {name}
        </div>
        <div>
          <b>닉네임:</b> {nickname}
        </div>
      </div>
    </div>
  )
}

export default Info
```







### 컴포넌트 스타일링

#### 가장 흔한 방식, 일반 CSS

- CSS를 작성할 때 가장 중요한 점은 CSS 클래스 중복되지 않게 만드는 것이다.
- 여러 가지 방식이 존재하는데, 그중 하나는 이름을 지을 때 특별한 규칙을 사용하여 짓는 것이고, 또 다른 하나는 CSS Selector를 활용하는 것이다.
- 이름 짓는 규칙
  - 클래스 이름에 컴포넌트 이름을 포함시킴으로써 다른 컴포넌트에서 실수로 중복되는 클래스를 만들어 사용하는 것을 방지할 수 있다.
  - 비슷한 방식으로 BEM 네이밍은 CSS 방법론 중 하나로, 이름을 지을 때 일종의 규칙을 준수하여 어떤 용도로 사용되는지 명확하게 작성하는 방식이다.
    -  예시 `.card_title-primary`

- CSS Selector

  - CSS selector를 사용하면 CSS 클래스가 특정 클래스 내부에 있는 경우에만 스타일을 적용할 수 있다. 
  - 예를 들어 .App 안에 들어 있는 .logo에 스타일을 적용하고 싶다면 다음과 작성할 수 있다.

  ```react
  .App .logo {
    animation: App-logo-spin infinite 20s linear;
    height: 40vmin;
  }
  ```

  - 다른 예시

  ```react
  /* .App안에 들어 있는 header
     header 클래스가 아닌 header 태그 자체에
     스타일을 적용하기 때문에 .이 생략되었다.
  */
  .App header {
    background-color: #282c34;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: calc(10px + 2vmin);
    color: white;
  }
  ```

  

#### Sass 사용하기

- Sass(Syntatically Awesome Style Sheets) 문법적으로 매우 멋진 스타일시트다.

-  **CSS 전처리기로 복잡한 작업을 쉽게 할 수 있도록 해 주고, 스타일 코드의 재활용성을 높여 줄 뿐만 아니라 코드의 가독성을 높여서 유지 보수를 더욱 쉽게 해 준다.**

- Sass에서는 두 가지 확장자 .scss와 .sass를 지원한다. 

  - .sass 예시

  ```css
  $font-stack: Helvetica, sans-serif
  $primary-color: #333
  
  body
  	font: 100% $font-stack
    color: $primary-color
  ```

  - .scss

  ```css
  $font-stack: Helvetica, sans-serif
  $primary-color: #333
  
  body {
  	font: 100% $font-stack
    color: $primary-color
  }    
  ```

- .sass vs .scss

  - .sass 확장자는 중괄호와 세미콜론을 사용하지 않는다.
  - .scss 확장자는 기존 CSS를 작성하는 방식과 비교해서 문법이 크게 다르지 않다. 

- Sass 사용

  - `node-sass`라이브러리 설치 
  - 예시

  ```scss
  // scss 파일
  // utils를 import 해서 사용하기 
  @import "./styles/utils";
  
  .SassComponent {
    display: flex;
    .box {
      background: red;
      cursor: pointer;
      transition: all 0.3s ease-in;
      &.red {
        background: $red;
        @include square(1);
      }
      &.orange {
        background: $orange;
        @include square(2);
      }
      &.yellow {
        background: $yellow;
        @include square(3);
      }
      &.green {
        background: $green;
        @include square(4);
      }
      &.blue {
        background: $blue;
        @include square(5);
      }
      &.indigo {
        background: $indigo;
        @include square(6);
      }
      &.violet {
        background: $violet;
        @include square(7);
      }
      &.hover {
        background: black;
      }
    }
  }
  ```

  - utils 함수 분리하기 
    - 여러 파일에서 사용하기 위해 

  ```scss
  $red: #fa5252;
  $orange: #fd7e14;
  $yellow: #fcc419;
  $green: #40c057;
  $blue: #339af0;
  $indigo: #5c7cfa;
  $violet: #7950f2;
  
  @mixin square($size) {
    $calculated: 32px * $size;
    width: $calculated;
    height: $calculated;
  }
  ```

  

- Sass-loader 설정 커스터마이징하기

  - 만약 프로젝트에 디렉터리가 많이 만들어서 구조가 깊어졌다면 상위 폴더로 한참 거슬러 올라가야 한다.
  - 그래서 커스터 마이징 시도 `yarn eject` 명령어를 통해 세부 설정을 밖으로 꺼내주어야 한다. 

  ```react
  {
    test: sassRegex,
    exclude: sassModuleRegex,
    use: getStyleLoaders(
    	{
       importLoaders: 3,
       sourceMap: isEnvProduction
         ? shouldUseSourceMap
         : isEnvDevelopment,
       modules: {
         mode: 'icss',
         },
       }).concat({
          loader: require.resolve("sass-loader"),
          options: {
             sassOptions: {
               includePaths: [paths.appSrc + "/styles"]
             },
               sourceMap: isEnvDevelopment && shouldUseSourceMap,
            // 이거 설정하면 import 구문 없어도 자동으로 import한다. 
               prependData: `@import 'utils';`
             }
        }),
        // Don't consider CSS imports dead code even if the
        // containing package claims to have no side effects.
        // Remove this when webpack adds a warning or an error for this.
        // See https://github.com/webpack/webpack/issues/6571
        sideEffects: true,
  }
  ```
  
  

#### CSS Module

- CSS Module은 CSS를 불러와서 사용할 때 클래스 이름을 고유한 값, 즉 `[파일 이름]_[클래스 이름]_[해시값]`형태로 자동으로 만들어서 컴포넌트 스타일 클래스 이름이 중첩되는 현상을 방지해 주는 기술이다.
- `.module.css`확장자로 파일을 저장하기만 하면 CSS Module이 적용된다.
- CSS Module을 사용하면 클래스 이름을 지을 대 그 고유성에 대해 고민하지 않아도 된다. 
- 해당 컴포넌트 내부에서만 작동한다. 
- 전역적으로 사용되는 경우라면 `:global`을 앞에 입력하여 글로벌 CSS임을 명시해 줄 수 있다.
- CSS 작성 예시

```css
/* 자동으로 고유해질 것이므로 흔히 사용되는 단어를 클래스 이름으로 마음대로 사용 가능 */
.wrapper {
  background: black;
  padding: 1rem;
  color: white;
  font-size: 2rem;
}

/* 글로벌 CSS를 작성하고 싶다면 */
:global .something {
  font-weight: 800;
  color: aqua;
}
```



- JS 적용 예시

```js
import React from 'react'
import styles from "./CSSModule.module.css";

const CSSModule = () => {
  return (
    <div>
      <div className={styles.wrapper}>
        안녕하세요, 저는 <span className="something">CSS Module!</span>
      </div>
    </div>
  )
}

export default CSSModule
```

- CSS Module이 적용된 스타일 파일을 불러오면 객체를 하나 전달받게 되는데 CSS Module에서 사용한 클래스 이름과 해당 이름을 고유화한 값이 키-값 형태로 들어 있다. 
- 이 **고유한 클래스 이름을 사용하려면 클래스를 적용하고 싶은 JSX 엘리먼트에 className= {styles.[클래스 이름]} 형태로 전달해 주면 된다.** 
- **`:global`을 사용하여 전역적으로 선언한 클래스의 경우 해 왔던 것처럼 그냥 문자열로 넣어준다.**



- CSS Moudle을 사용한 클래스 이름을 두 개 이상 적용할 때 다음과 같이 코드를 작성하자.

```js
const CSSModule = () => {
  return (
    <div>
      <div className={`${styles.wrapper} ${styles.inverted}`}>
        안녕하세요, 저는 <span className="something">CSS Module!</span>
      </div>
    </div>
  )
}
```



- classnames

  - classnames는 **CSS 클래스를 조건부로 설정할 떄 매우 유용한 라이브러리이다.**

  - 일단 해당 라이브러리를 설치하자

    `yarn add classnames`

  - 예시 코드

  ```js
  const MyComponent = ({ highlighted, theme }) => (
  	<div className={classNames('MyComponent', { highlighted }, theme)}>Hello</div>
  );
  ```

  - 위에 같이 하면, 클래스에 highlighted 값이 true이면 highlighted 클래스가 적용되고, false이면 적용되지 않는다. 추가로 theme으로 전달받는 문자열은 내용 그대로 클래스에 적용된다. 
  - 덧붙여 CSS Module과 함께 사용되면 사용이 더 훨씬 쉬어진다. 
  - classnames에 내장되어 있는 bind 함수를 사용하면 클래스를 넣어 줄 떄마다 styles.[클래스 이름] 형태를 사용할 필요가 없다. 
  - 사전에 미리 styles에서 받아 온 후 사용하게끔 설정해 두고 cx('클래스 이름', '클래스 이름2') 형태로 사용할 수 있다.
  - 예시

  ```js
  import React from 'react'
  import classNames from "classnames/bind";
  import styles from "./CSSModule.module.css";
  
  // 미리 Style에서 클래스 받아오도록 서렂ㅇ
  const cx = classNames.bind(styles)
  
  const CSSModule = () => {
    return (
      <div>
        <div className={cx("wrapper", "inverted")}>
          안녕하세요, 저는 <span className="something">CSS Module!</span>
        </div>
      </div>
    )
  }
  
  export default CSSModule
  ```

  - Sass와 함게 사용하기 

    - Sass를 사용할 때도 파일 이름 뒤에 .module.scss 확장자를 사용해 주면 CSS Module로 사용할 수 있다. 
    - 예시

    ```scss
    /* 자동으로 고유해질 것이므로 흔히 사용되는 단어를 클래스 이름으로 마음대로 사용 가능 */
    .wrapper {
      background: black;
      padding: 1rem;
      color: white;
      font-size: 2rem;
      &.inverted {
        // inverted가 .wrapper와 함께 사용되었을 때만 적용
        color: black;
        background: white;
        border: 1px solid black;
      }
    }
    
    /* 글로벌 CSS를 작성하고 싶다면 */
    :global{
      // :global {}로 감싸기
      .something {
        font-weight: 800;
        color: aqua;
      }
    }
    ```

  - CSS Module이 아닌 파일에서 CSS Module 사용하기

    - 일반 `.css/.scss` 파일에서도 `:local` 을 사용하여 CSS Module을 사용할 수 있다.

    ```css
    :local .wrapper{
      /* 스타일 */
    }
    
    :local {
      .wrapper{
        /*스타일 */
      }
    }
    ```

    

#### styled-components

- 자바스크립트 파일 안에 스타일을 선언하는 방식이다.

- 이 방식을 **CSS-in-JS** 라고 부른다. 

- 설치

  `yarn add styled-components`

- styled-component를 사용하면 자바스크립트 파일 하나에 스타일까지 작성할 수 있기 때문에 `.css`또는 `.scss`확장자를 가진 스타일 파일을 따로 만들지 않아도 된다는 큰 이점이 있다.

```js
import React from 'react'
import styled, { css } from "styled-components"


const Box = styled.div`
  background: ${props => props.color || "blue"};
  padding: 1rem;
  display; flex;
`;

const Button = styled.button`
  background: white;
  color: black;
  border-radius: 4px;
  padding: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  font-size: 1rem;
  font-weight: 600;

  &:hover {
    background: rgba(255, 255, 255, 0.9);
  }
  ${props =>
    props.inverted &&
    css `
      background: none;
      border: 2px solid white;
      color: white;
      &:hover {
        background: white;
        color: black
      }
    `};

  & + button {
    margin-left: 1rem;
  }

`

const StyledComponent = () => {
  return (
    <Box color="black">
      <Button>안녕하세요</Button>
      <Button inverted={true}>테두리만</Button>
    </Box>
  )
}

export default StyledComponent
```

- Tagged 템플릿 리터럴

  - 스타일을 작성할 때 `을 사용하여 만든 문자열에 스타일 정보를 넣는데 이것을 Tagged 템플릿 리터럴이라고 부른다.
  - CSS Module을 배울 때 나온 일반 템플릿 리터럴과 다른 점은 템플릿 안에 자바스크립트 객체나 함수를 전달할 때 온전히 추출할 수 있다는 것이다.

  ```js
  `hello ${{foo: "bar"]} ${() => "world"}}!`
  
  // 결과: "hello [object object] () => 'world'!"
  ```

  - 템플릿에 객체를 넣거나 함수를 넣으면 형태를 잃어 버리게 된다.

  ```js
  function tagged(...args) {
    console.log(args);
  }
  
  tagged`hello ${{foo: "bar"}} ${() => "world"}`
  // 출력 결과 
  ["hello", " ", "!", raw: Array(3)]
  {foo: "bar"}
  ```

  - 이렇게 하면 템플릿 안에 넣은 값을 온전히 추출할 수 있다. 

- 스타일링된 엘리먼트 만들기

  - styled-components를 사용하여 스타일링된 엘리먼트를 만들 때는 컴포넌트 파일의 상단에서 styled를 불러오고, `styled.태그명`을 사용하여 구현한다.

  ```react
  import styled from "styled-components"
  
  const MyComponent = styled.div`
    font-size: 2rem;
  `
  ```

  - Tagged 템플릿 리터럴 문법을 통해 스타일을 넣어 주면, 해당 스타일이 적용된 div로 이루어진 리액트 컴포넌트가 생성된다.  나중에 `<MyComponent>Hello<MyComponent>`와 같은 형태로 사용할 수 있다.
  - div가 아닌 button이나 input에 스타일링 하고 싶다면 styled.button 혹은 styled.input 같은 형태로 뒤에 태그명을 넣어주면 된다.

  ```js
  const MyInput = styled('input')`
  	background: gray;
  `
  
  const StyledLink = styled(Link)`
  	color: blue;
  `
  ```

- 스타일에서 props 조회하기

  - 아래처럼 작성하면 props를 조회해서 props.color를 사용한다. color값이 주어지지 않았을 때는 blue를 기본 색상으로 설정했다. 

  ```react
  const Box = styled.div`
    background: ${props => props.color || "blue"};
    padding: 1rem;
    display; flex;
  `;
  ```

  

- props에 따른 조건부 스타일링

  - 스타일 코드 여러 줄을 props에 다라 넣어 주어야 할 때 CSS를 styled-components에서 불러와야 한다. 
  - CSS를 사용하지 않고 바로 문자열을 넣어도 동작하긴 하지만 문자열로 취급되기 때문에 Vs Code 확장 프로그램에세ㅓ 신택스 하이라이팅이 제대로 이루어지지 않는다는 단점이 따른다. 
  - 그리고 더욱 치명적인 단점은 Tagged 템플릿 리터럴이 아니기 때문에 함수를 받아 사용하지 못해 해당 부분에서는 props값을 사용하지 못한다. 

  ```js
  ${props =>
    props.inverted &&
    css `
      background: none;
      border: 2px solid white;
      color: white;
      &:hover {
        background: white;
        color: black
      }
    `};
  ```

  



- 반응형 디자인

  - media 쿼리를 사용해서 가능하다. 

  ```js
  const Box = styled.div`
    background: ${props => props.color || "blue"};
    padding: 1rem;
    display; flex;
    width: 1024px;
    margin: 0 auto;
    @media (max-width: 1024px) {
      width: 768px;
    }
    @media (max-width: 768px) {
      width: 100%
    }
  `;
  ```

  - 더 쉽게 utils 함수를 따라 사용해보자. 
    - [참고](https://www.styled-components.com/docs/advanced#media-templates)

  ```js
  const sizes = {
    desktop: 1024,
    tablet: 768
  };
  
  //위의 사이즈에 따라 자동으로 media 쿼리를 만들어보자
  const media = Object.keys(sizes).reduce((acc, label) => {
    acc[label] = (...args) => css`
     @media (max-width: ${sizes[label] / 16}em) {
        ${css(...args)};
     }
     `
  })
  
  
  
  const Box = styled.div`
    background: ${props => props.color || "blue"};
    padding: 1rem;
    display; flex;
    width: 1024px;
    margin: 0 auto;
    ${media.desktop`width: 768px;`}
    ${media.tablet`width: 100%;`}
  `;
  ```

  

### 일정 관리 웹 애플리케이션 만들기

#### 프로젝트 준비하기

- 프로젝트 생성 및 필요한 라이브러리 설치

`yarn create react-app todo-app`

- 필요한 라이브러리 설치
  - Sass
  - classnames 조건부 스타일링
  - 예쁜 아이콘

​	`yarn add node-sass classnames react-icons`

- [아이콘 사이트](https://react-icons.netlify.com/#/icons/md)

- Prettier 설정

  ```js
  {
    "singleQuote": true,
    "semi": true,
    "useTabs": false,
    "tabWidth": 2,
    "trailingComma": "all",
    "printWidth": 80
  }
  ```

- index.css 수정

  ```css
  body {
    margin: 0;
    padding: 0;
    /* 회색 배경*/
    background: #e9ecef;
  }
  ```

- App 컴포넌트 초기화

  ```js
  import './App.css';
  
  function App() {
    return (
      <div>Todo App을 만들자</div>
    );
  }
  
  export default App;
  ```

- 닫혀 있는 파일에도 자동 완성이 제대로 작동하려면

  ```js
  {
    "compilerOptions": {
      "target": "es6"
    }
  }
  ```

  

#### UI 구성하기

- TodoTemplate
  - 화면을 가운데로 정렬시켜 주며, 앱 타이틀(일정 관리)을 보여 준다.
  - children으로 내부 JSX를 props로 받아와서 렌더링한다.
- TodoInsert
  - 새로운 항목을 입력하고 추가할 수 있는 컴포넌트다. state를 통해 인풋의 상태를 관리한다.
- TodoListItem
  - 각 할 일 항목에 대한 정보를 보여 주는 컴포넌트이다. todo객체를 props로 받아 와서 상태에 따라 다른 스타일의 UI를 보여준다.
- TodoList
  - Todo 배열을 props로 받아 온 후 , 이를 배열 내장 함수 map을 사용해서 여러 개의 TodoListItem 컴포넌트로 변환하여 보여준다.

- TodoTemplate 만들기

  - TodoTemplate.js

  ```js
  import React from 'react'
  import "./TodoTemplate.scss";
  
  
  const TodoTemplate = ({ children }) => {
    return (
      <div>
        <div className="TodoTemplate">
          <div className="app-title">일정 관리</div>
          <div className="content">{children}</div>
        </div>
      </div>
    )
  }
  
  export default TodoTemplate
  ```

  - TodoTemplate.scss

  ```scss
  .TodoTemplate {
    width: 512px;
    margin-left: auto;
    margin-right: auto;
    margin-top: 6rem;
    border-radius: 4px;
    overflow: hidden;
  
    .app-title {
      background: #22b8cf;
      color: white;
      height: 4rem;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  
    .content {
      background: white;
    }
  }
  ```

  

- TodoInsert 만들기

  - TodoInsert.js

  ```js
  import React from 'react'
  // add icon 사용
  import { MdAdd } from "react-icons/md"
  import "./TodoTemplate.scss"
  
  
  const TodoInsert = () => {
    return (
      <form className="TodoInsert">
        <input placeholder="할 일을 입력하세요" />
        <button type="submit">
          <MdAdd />
        </button>
      </form>
    )
  }
  
  export default TodoInsert
  ```

  - App.js

  ```js
  import './App.css';
  import TodoTemplate from "./components/TodoTemplate";
  import TodoInsert from "./components/TodoInsert";
  
  function App() {
    return (
      <TodoTemplate>
        <TodoInsert />
      </TodoTemplate>
    );
  }
  
  export default App;
  ```

  - TodoInsert.scss

  ```scss
  .TodoInsert {
    display: flex;
    background: #495057;
  
    input {
      background: none;
      outline: none;
      border: none;
      padding: 0.5rem;
      font-size: 1.125rem;
      line-height: 1.5;
      color: white;
  
      &::placeholder {
        color: #dee2e6
      }
      /* 버튼을 제외한 영역을 모두 차지하기*/
      flex: 1
    }
  
    button {
      background: none;
      outline: none;
      border: none;
      background: #868e96;
      color: white;
      padding-left: 1rem;
      padding-right: 1rem;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      cursor: pointer;
      transition: 0.1s background ease-in;
      // button(상위 선택자 참조)
      &:hover {
        background: #adb5bd;
      }
    }
  }
  ```

- TodoListItem 과 TodoList 만들기

  - TodoListItem.js

  ```js
  import React from 'react'
  import {
    MdCheckBoxOutlineBlank,
    MdRemoveCircleOutline,
  } from "react-icons/md";
  import "./TodoListItem.scss"
  
  
  const TodoListItem = () => {
    return (
  
      <div className="TodoListItem">
        <div className="checkbox">
          <MdCheckBoxOutlineBlank />
          <div className="text">할 일</div>
        </div>
        <div className="remove">
          <MdRemoveCircleOutline />
        </div>
      </div>
    )
  }
  export default TodoListItem
  ```

  - TodoList.js

  ```js
  import React from 'react';
  import TodoListItem from "./TodoListItem";
  import "./TodoList.scss";
  
  const TodoList = () => {
    return (
      <div className="TodoList">
        <TodoListItem />
        <TodoListItem />
        <TodoListItem />
      </div>
    )
  }
  
  export default TodoList
  ```

  - App.js

  ```js
  import './App.css';
  import TodoTemplate from "./components/TodoTemplate";
  import TodoInsert from "./components/TodoInsert";
  import TodoList from "./components/TodoList";
  
  function App() {
    return (
      <TodoTemplate>
        <TodoInsert />
        <TodoList />
      </TodoTemplate>
    );
  }
  
  export default App;
  ```

  - TodoList.scss

  ```scss
  .TodoList {
    min-height: 320px;
    max-height: 513px;
    overflow-y: auto;
  }
  ```

  - TodoListItem.scss

  ```scss
  .TodoListItem {
    padding: 1rem;
    display: flex;
    align-items: center;
    &:nth-child(even) {
      background: #f8f9fa;
    }
    .checkbox {
      cursor: pointer;
      flex: 1;
      display: flex;
      align-items: center;
      svg {
        // icon
        font-size: 1.5rem;
      }
      .text {
        margin-left: 0.5rem;
        flex: 1;
      }
      // 체크되었을 떄
      &.checked {
        svg {
          color: #22b8cf;
        }
        .text {
          color: #adb5bd;
          // 밑줄 2개
          text-decoration: line-through;
        }
      }
    }
    .remove {
      display: flex;
      align-items: center;
      font-size: 1.5rem;
      color: #ff6b6b;
      cursor: pointer;
      &:hover {
        color: #ff8787;
      }
    }
  
    // 엘리먼트 사이사이에 테두리 넣어준다.
    & + & {
      border-top: 1px solid #dee2e6;
    }
  }
  ```

  

#### 기능 구현하기 

- App에서 todos 상태 사용하기

  - App.js

  ```js
  import React, { useState } from "react";
  import './App.css';
  import TodoTemplate from "./components/TodoTemplate";
  import TodoInsert from "./components/TodoInsert";
  import TodoList from "./components/TodoList";
  
  function App() {
    const [todos, setTodos] = useState([
      {
        id: 1,
        text: "리액트의 기초 알아보기",
        checked: true,
      },
      {
        id: 2,
        text: "컴포넌트 스타일링해 보기",
        checked: true,
      },
      {
        id: 3,
        text: "일정 관리 앱 만들어 보기",
        checked: false,
      },
    ])
  
    return (
      <TodoTemplate>
        <TodoInsert />
        <TodoList todos={todos} />
      </TodoTemplate>
    );
  }
  
  export default App;
  ```

  - TodoList.js

  ```js
  import React from 'react';
  import TodoListItem from "./TodoListItem";
  import "./TodoList.scss";
  
  const TodoList = ({todos}) => {
    return (
      <div className="TodoList">
        {todos.map((todo) => (
          <TodoListItem todo={todo} key={todo.id}/>
        ))}
      </div>
    )
  }
  
  export default TodoList
  ```

  - TodoListItem.js

  ```js
  import React from 'react'
  import {
    MdCheckBoxOutlineBlank,
    MdRemoveCircleOutline,
  } from "react-icons/md";
  import "./TodoListItem.scss"
  import cn from "classnames";
  
  const TodoListItem = ({ todo }) => {
    const { text, checked } = todo;
  
    return (
      <div className="TodoListItem">
      // checked이면 scss에서 설정해 놓은 &.checked가 실행된다.
        <div className={cn("checkbox", { checked })}>
          <MdCheckBoxOutlineBlank />
          <div className="text">{text}</div>
        </div>
        <div className="remove">
          <MdRemoveCircleOutline />
        </div>
      </div>
    )
  
  }
  
  export default TodoListItem
  ```
  
  
  
- 항목 추가 기능 구현하기

  - TodoInsert value 상태 관리하기

  ```react
  import React, { useState, useCallback } from 'react'
  import { MdAdd } from "react-icons/md"
  import "./TodoInsert.scss"
  
  
  const TodoInsert = () => {
    const [value, setValue] = useState("");
  
    // 리렌더링 될때마다 함수 새로 만드는 것보다 재사용할 수 있게
    const onChange = useCallback(e => {
      setValue(e.target.value)
    })
  
    return (
      <form className="TodoInsert">
        <input placeholder="할 일을 입력하세요" value={value} onChange={onChange}/>
        <button type="submit">
          <MdAdd />
        </button>
      </form>
    )
  }
  
  export default TodoInsert
  ```

  

- todos 배열에 새 객체 추가하기

```react
import React, { useCallback, useState, useRef } from "react";
import './App.css';
import TodoTemplate from "./components/TodoTemplate";
import TodoInsert from "./components/TodoInsert";
import TodoList from "./components/TodoList";

function App() {
  const [todos, setTodos] = useState([
    {
      id: 1,
      text: "리액트의 기초 알아보기",
      checked: true,
    },
    {
      id: 2,
      text: "컴포넌트 스타일링해 보기",
      checked: true,
    },
    {
      id: 3,
      text: "일정 관리 앱 만들어 보기",
      checked: false,
    },
  ])

  // 고윳값으로 사용될 id
  // ref를 사용하여 변수 담기
  const nextId = useRef(4);


  const onInsert = useCallback(
    text => {
      const todo = {
        id: nextId.current,
        text,
        checked: false,
      };
      setTodos(todos.concat(todo))
      // nextId 1씩 더하기
      nextId.current += 1;
    },
    [todos],
  );

  return (
    <TodoTemplate>
      <TodoInsert onInsert={onInsert}/>
      <TodoList todos={todos} />
    </TodoTemplate>
  );
}

export default App;
```



- TodoInsert에서 onSubmit 이벤트 설정하기

  - onInsert 함수에 현재 재  useState를 통해 관리하고 있는 value 값을 파라미터로 넣어서 호출한다.
  - App.js

  ```js
  import React, { useCallback, useState, useRef } from "react";
  import './App.css';
  import TodoTemplate from "./components/TodoTemplate";
  import TodoInsert from "./components/TodoInsert";
  import TodoList from "./components/TodoList";
  
  function App() {
    const [todos, setTodos] = useState([
      {
        id: 1,
        text: "리액트의 기초 알아보기",
        checked: true,
      },
      {
        id: 2,
        text: "컴포넌트 스타일링해 보기",
        checked: true,
      },
      {
        id: 3,
        text: "일정 관리 앱 만들어 보기",
        checked: false,
      },
    ])
  
    // 고윳값으로 사용될 id
    // ref를 사용하여 변수 담기
    const nextId = useRef(4);
  
  
    const onInsert = useCallback(
      text => {
        const todo = {
          id: nextId.current,
          text,
          checked: false,
        };
        setTodos(todos.concat(todo))
        // nextId 1씩 더하기
        nextId.current += 1;
      },
      [todos],
    );
  
    return (
      <TodoTemplate>
        <TodoInsert onInsert={onInsert}/>
        <TodoList todos={todos} />
      </TodoTemplate>
    );
  }
  
  export default App;
  ```

  - TodoInsert.js

  ```js
  import React, { useState, useCallback } from 'react'
  import { MdAdd } from "react-icons/md"
  import "./TodoInsert.scss"
  
  
  const TodoInsert = ({ onInsert }) => {
    const [value, setValue] = useState("");
  
    // 리렌더링 될때마다 함수 새로 만드는 것보다 재사용할 수 있게
    const onChange = useCallback(e => {
      setValue(e.target.value)
    }, []);
  
    const onSubmit = useCallback(
      e => {
        onInsert(value);
        setValue("");
        // 새로고침 방지
        e.preventDefault();
      },
      [onInsert, value],
    )
  
  
  
    return (
      <form className="TodoInsert" onSubmit={onSubmit}>
        <input placeholder="할 일을 입력하세요" value={value} onChange={onChange}/>
        <button type="submit">
          <MdAdd />
        </button>
      </form>
    )
  }
  
  export default TodoInsert
  ```

  - onSubmit은 엔터를 쳐도 새 항목이 추가된다. 

- 지우기 기능 구현하기

  - Todos 배열에서 id로 항목 지우기
  - App.js

  ```js
  import React, { useCallback, useState, useRef } from "react";
  import './App.css';
  import TodoTemplate from "./components/TodoTemplate";
  import TodoInsert from "./components/TodoInsert";
  import TodoList from "./components/TodoList";
  
  function App() {
    const [todos, setTodos] = useState([
      {
        id: 1,
        text: "리액트의 기초 알아보기",
        checked: true,
      },
      {
        id: 2,
        text: "컴포넌트 스타일링해 보기",
        checked: true,
      },
      {
        id: 3,
        text: "일정 관리 앱 만들어 보기",
        checked: false,
      },
    ])
  
    // 고윳값으로 사용될 id
    // ref를 사용하여 변수 담기
    const nextId = useRef(4);
    
    const onRemove = useCallback(
      id => {
        setTodos(todos.filter(todo => todo.id !== id))
      },
      [todos],
    )
  
    return (
      <TodoTemplate>
        <TodoInsert onInsert={onInsert}/>
        <TodoList todos={todos} onRemove={onRemove}/>
      </TodoTemplate>
    );
  }
  
  export default App;
  ```

  - TodoListItem에서 삭제 함수 호출하기
  - TodoList.js

  ```react
  import React from 'react';
  import TodoListItem from "./TodoListItem";
  import "./TodoList.scss";
  
  const TodoList = ({todos, onRemove }) => {
    return (
      <div className="TodoList">
        {todos.map(todo => (
          <TodoListItem todo={todo} key={todo.id} onRemove={onRemove}/>
        ))}
      </div>
    )
  }
  
  export default TodoList
  ```

  - TodoListItem

  ```react
  import React from 'react'
  import {
    MdCheckBoxOutlineBlank,
    MdRemoveCircleOutline,
  } from "react-icons/md";
  import "./TodoListItem.scss"
  import cn from "classnames";
  
  const TodoListItem = ({ todo }) => {
    const { text, checked } = todo;
  
    return (
      <div className="TodoListItem">
        <div className={cn("checkbox", { checked })}>
          <MdCheckBoxOutlineBlank />
          <div className="text">{text}</div>
        </div>
        <div className="remove">
          <MdRemoveCircleOutline />
        </div>
      </div>
    )
  }
  
  export default TodoListItem
  ```

- 수정 기능

  - App.js

  ```js
  import React, { useCallback, useState, useRef } from "react";
  import './App.css';
  import TodoTemplate from "./components/TodoTemplate";
  import TodoInsert from "./components/TodoInsert";
  import TodoList from "./components/TodoList";
  
  function App() {
    const [todos, setTodos] = useState([
      {
        id: 1,
        text: "리액트의 기초 알아보기",
        checked: true,
      },
      {
        id: 2,
        text: "컴포넌트 스타일링해 보기",
        checked: true,
      },
      {
        id: 3,
        text: "일정 관리 앱 만들어 보기",
        checked: false,
      },
    ])
  
    // 고윳값으로 사용될 id
    // ref를 사용하여 변수 담기
    const nextId = useRef(4);
  
    const onToggle = useCallback(
      id => {
        setTodos(
          todos.map(todo =>
            todo.id === id? {
               ...todo, checked: !todo.checked} : todo,
          ),
        );
      },
      [todos],
    )
  
    return (
      <TodoTemplate>
        <TodoInsert onInsert={onInsert}/>
        <TodoList todos={todos} onRemove={onRemove} onToggle={onToggle}/>
      </TodoTemplate>
    );
  }
  
  export default App;
  
  ```

  - id값이 다를 때는 변화를 주지 않고 처음 받아 왔던 상태 그대로 반환한다. 그렇기 때문에 map을 사용하여 만든 배열에서 변화가 필요한 원소만 업데이트되고 나머지는 그대로 남아 있게 되는 것이다. 
  - TodoListItem에서 토글 함수 호출하기
  - TodoList.js

  ```js
  import React from 'react';
  import TodoListItem from "./TodoListItem";
  import "./TodoList.scss";
  
  const TodoList = ({todos, onRemove, onToggle }) => {
    return (
      <div className="TodoList">
        {todos.map(todo => (
          <TodoListItem todo={todo} key={todo.id} onRemove={onRemove} onToggle={onToggle}/>
        ))}
      </div>
    )
  }
  
  export default TodoList
  ```

  - TodoListItem.js

  ```js
  import React from 'react'
  import {
    MdCheckBoxOutlineBlank,
    MdRemoveCircleOutline,
    MdCheckBox,
  } from "react-icons/md";
  import "./TodoListItem.scss"
  import cn from "classnames";
  
  const TodoListItem = ({ todo, onRemove, onToggle }) => {
    const { id, text, checked } = todo;
  
    return (
      <div className="TodoListItem">
        <div className={cn("checkbox", { checked })} onClick={() => onToggle(id)}>
          { checked ? <MdCheckBox /> : <MdCheckBoxOutlineBlank />}
          <div className="text">{text}</div>
        </div>
        <div className="remove" onClick={() => onRemove(id)}>
          <MdRemoveCircleOutline />
        </div>
      </div>
    )
  
  }
  export default TodoListItem
  ```

  



### 컴포넌트 성능 최적화

#### 많은 데이터 렌더링하기

- 컴포넌트 수정

  - App.js

  ```js
  function createBulkTodos() {
    const array = [];
    for (let i = 1; i <= 2500; i++) {
      array.push({
        id: i,
        text: `할 일 ${i}`,
        checked: false,
      });
    }
    return array;
  }
  
  
  function App() {
    const [todos, setTodos] = useState(createBulkTodos);
    const nextId = useRef(2501);
    
    (...)
  }      
  ```

  - 위의 코드에서 createBulkTodos()를 하지 않고 createBulkTodos를 함수를 호출하면 컴포넌트가 처음 렌더링될 때만 createBulkTodos 함수가 실행된다. 
  - 이렇게 하면 겁나 느려짐. 

  

#### 느려지는 원인 분석

- 컴포넌트는 다음과 같은 상황에서 리렌더링이 발생한다. 
  - 1.자신이 전달받은 props가 변경될 때
  - 2.자신의 state가 바뀔 때
  - 3.부모 컴포넌트가 리렌더링될 때
  - 4.forceUpdate 함수가 실행될 때
- 따라서 위에 컴포넌트는 App의 컴포넌트의 state가 변경되면서  App 컴포넌트가 리렌더링된다. 
- 부모 컴포넌트가 리렌더링되었으니 TodoList 컴포넌트가 리렌더링되고 그 안의 무수한 컴포넌트들도 리렌더링된다.



#### React.memo를 사용하여 컴포넌트 성능 최적화

- 컴포넌트의 props가 바뀌지 않았다면 리렌더링하지 않도록 설정하여 함수형 컴포넌트의 리렌더링 성능을 최적화해 줄 수 있다. 

- 사용 예시

  ```js
  import React from 'react'
  import {
    MdCheckBoxOutlineBlank,
    MdRemoveCircleOutline,
    MdCheckBox,
  } from "react-icons/md";
  import "./TodoListItem.scss"
  import cn from "classnames";
  
  const TodoListItem = ({ todo, onRemove, onToggle }) => {
    const { id, text, checked } = todo;
  
    return (
      <div className="TodoListItem">
        <div className={cn("checkbox", { checked })} onClick={() => onToggle(id)}>
          { checked ? <MdCheckBox /> : <MdCheckBoxOutlineBlank />}
          <div className="text">{text}</div>
        </div>
        <div className="remove" onClick={() => onRemove(id)}>
          <MdRemoveCircleOutline />
        </div>
      </div>
    )
  
  }
  
  
  export default React.memo(TodoListItem)
  ```

- useState의 함수형 업데이트

  ```js
  const [number, setNumber] = useState(0);
  
  const onIncrease = useCallback(
  	() => setNumber(prevNumber => prevNumber + 1),
    [],
  );
  ```

  - 위 코드처럼 어떻게 업데이트할지 정의해 주는 업데이트 함수를 넣어 준다.
  - 그러면 useCallback을 사용할 떄 두 번째 파라미터로 넣는 배열에 number를 넣지 않아도 된다.
  - App.js

  ```js
  const onInsert = useCallback(
    text => {
      const todo = {
        id: nextId.current,
        text,
        checked: false,
      };
      setTodos(todos => todos.concat(todo))
      // nextId 1씩 더하기
      nextId.current += 1;
    },
    [],
  );
  
  
  const onToggle = useCallback(
    id => {
      setTodos(todos =>
        todos.map(todo =>
          todo.id === id? { ...todo, checked: !todo.checked} : todo,
        ),
      );
    },
    [],
  )
  
  
  const onRemove = useCallback(
    id => {
      setTodos(todos => todos.filter(todo => todo.id !== id))
    },
    [],
  )
  ```

  

#### useReducer 사용하기

- App.js

```js
import React, { useCallback, useState, useRef, useReducer } from "react";
import './App.css';
import TodoTemplate from "./components/TodoTemplate";
import TodoInsert from "./components/TodoInsert";
import TodoList from "./components/TodoList";

function todoReducer(todos, action) {
  switch (action.type) {
    case "INSERT":
      return todos.concat(action.todo);
    case "REMOVE":
      return todos.filter(todos => todos.id !== action.id);
    case "TOGGLE":
      return todos.map(todo =>
          todo.id === action.id ? { ...todo, checked: !todo.checked } : todo,
        );
     default:
      return todos;
  }
}


function App() {
  const [todos, dispatch] = useReducer(todoReducer, undefined, createBulkTodos);

  // 고윳값으로 사용될 id
  // ref를 사용하여 변수 담기
  const nextId = useRef(2501);


  const onInsert = useCallback(
    text => {
      const todo = {
        id: nextId.current,
        text,
        checked: false,
      };
      dispatch({ type: "Insert", todo });
      // nextId 1씩 더하기
      nextId.current += 1;
    },
    [],
  );


  const onToggle = useCallback(
    id => {
      dispatch({ type: "TOGGLE", id});
    },
    [],
  )


  const onRemove = useCallback(
    id => {
      dispatch({ type: "REMOVE", id })
    },
    [],
  )

  return (
    <TodoTemplate>
      <TodoInsert onInsert={onInsert}/>
      <TodoList todos={todos} onRemove={onRemove} onToggle={onToggle}/>
    </TodoTemplate>
  );
}

export default App;
```



