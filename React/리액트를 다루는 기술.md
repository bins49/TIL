### 리액트 시작

- 리액트 이해

  - 리액트는 자바스크립트 라이브러리로 사용자 인터페이스를 만드는 데 사용한다.

  - 구조가 MVC, MVW 등인 프레임워크와 달리, 오직 **V(view)만 신경 쓰는 라이브러리**이다.

  - 컴포넌트는 **특정 부분이 어떻게 생길지 정하는 선언체**, 재사용이 가능한 API로 수많은 기능들을 내장하고 있다. 

  - 사용자 화면에 뷰를 보여 주는 것을 렌더링이라고 한다. 

- 초기 렌더링

  - 맨 처음에 어떻게 보일지를 정하는 초기 렌더링이 필요하다. 리액트에서는 이를 다루는 render 함수가 있다. 
  - render()는 **뷰가 어떻게 생겼는지 어떻게 작동하는지 객체를 반환한다.** 
    - 뷰가 어떻게 생겼고 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환한다. 
  - 최상위 컴포넌트의 렌더링 작업 => HTML 마크업을 만들고 => 실제 페이지의 DOM 요소 안에 주입한다. 
  - 컴포넌트를 실제 페이지에 렌더링할 때는 분리된 두 가지 절차를 따르는데, 문자열 형태의 HTML 코드 생성 후 특정 DOM에 해당 내용을 주입하면 이벤트가 적용된다. 

  #### 조화 과정

  - 리액트에서 뷰를 업데이트할 때는 업데이트라는 단어보다는 조화 과정을 거친다라고 하는 것이 더 정확한 표현이다. 
    - 변화에 따라 뷰가 변형되는 것처럼 보이지만, 사실은 새로운 요소로 갈아 끼우기 떄문이다. 
    - **컴포넌트는 데이터를 업데이트 했을 때 단순히 업데이트한 값을 수정하는 것이 아니라, 새로운 데이터를 가지고 render 함수를 또 다시 호출한다** 
    - render 함수가 곧바로 DOM에 반영하지 않고, 이전에 **render 함수가 만들었던 컴포넌트 정보와 현재 render함수가 만든 컴포넌트 정보를 비교한다**.
      - **최소한의 연산으로 비교한 후, 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트한다. **
    - 최적의 자원을 사용하여 이를 수행한다.

- 리액트의 특징

  - DOM은? 

    - DOM은 Document Object Model의 약자이다. 
    - 객채로 문서 구조를 표현하는 방법으로 XML이나 HTML로 작성한다.
    - 웹 브라우저는 DOM을 활용하여 객체에 자바스크립트와 CSS를 적용한다. DOM은 트리 형태라서 특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입할 수 있다. 
    - DOM은 동적 UI가 최적화되어 있지 않다. HTML 자체로는 정적인데, 자바스크립트를 사용하여 이를 동적으로 만들 수 있다. 
    - DOM 자체는 빠르다, 그러나 웹 브라우저 단에서 DOM에 변화가 일어나면 웹 브라우저가 CSS를 다시 연산하고, 레이아웃을 구성하고, 페이지를 리페인트한다. 이 과정에서 시간이 허비되는 것이다. 
    - 업데이트가 너무 잦으면 성능이 저하되므로 DOM을 최소한으로 조작하여 작업을 처리해야한다. 
    - 그래서 react의 가상돔 방식을 사용해서 DOM 업데이트를 추상화함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행한다.

  - Virtual DOM

    - 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용한다. 마치 **실제 DOM 가벼운 사본과 비슷하다**.
    - 리액트에서 데이터 변화 후 웹 브라우저에 실제 DOM을 업데이트 하는 절차
      - 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링한다. 
      - 이전 Virtual DOM에 있던 내용과 현재 내용을 비교한다.
      - 바뀐 부분만 실제 DOM에 적용한다. 
    - 무조건 가상돔을 사용한다고 해서 사용하지 않을 때와 비교하여 무조건 빠른 것이 아니다. 

    > 지속적으로 데이터가 변화하는 대규모 애플리케이션 구축하기

    - **리액트를 사용하지 않고 코드 최적화를 열심히 하면 DOM 작업이 느려지는 문제를 개선할 수 있고, 또 작업이 매우 간단할 때는 오히려 리액트를 사용하지 않는 편이 더 나은 성능을 보이기도 한다.** 
    - 리액트와 가상돔이 언제나 제공할 수 있는 것은 바로 **업데이트 처리 간결성**이다. 쉽게 업데이트에 접근할 수 있다.

  - 기타 특징

    - 리액트는 프레임워크가 아닌 라이브러리이다. 
    - 다른 웹 프레임워크가 Ajax, 데이터 모델링, 라우팅 등과 같은 기능을 내장하고 있는 반면, 리액트는 정말 뷰만 신경 쓰는 라이브러리이므로 기타 기능은 직접 구현하여 사용해야 한다. 
    - 리액트는 다른 웹 프레임워크나 라이브러리와 혼용할 수 있다. 
    - 대신 여러 라이브러리를 접해야 한다는 단점도 있다. 

  - 작업 환경 설정

    - Node.js 웹 브라우저 환경이 아닌 곳에서도 자바스크립트를 사용하여 연산할 수 있다. 
    - 크롬 V8 자바스크립트 엔진으로 빌드한 자바스크립트 런타임
    - vs코드는 모든 운영체제를 지원한다. 

  - 리액트 프로젝트 생성하기 

    `yarn create react-app 프로젝트 이름`

    `cd 프로젝트 이름` - 프로젝트 디렉토리 이동

    `yarn start` - 개벌 전용 서버 구동





### JSX

- 코드 이해하기

  - 우리가 import를 할 수 있는건 node_modules 디렉터리에 react 모듈이 설치되어 있기 때문이다. 
  - 이렇게 **모듈을 불러와서 사용하는 것은 원래 브라우저에는 없던 기능**이다. Node.js에서 지원하는 기능
  - Node.js는 require라는 구문으로 패키지를 불러올 수 있다. 
  - 이러한 기능을 **브라우저에서 사용하기 위해 bundler를 사용**한다. 
  - 리액트에서 webpack을 사용하는 이유는 **편의성과 확장성** 때문이다.
  - 번들러 도구를 사용하면 **import로 모듈을 불러왔을 때 불러온 모듈을 모두 합쳐서 하나의 파일을 생성해 준다**. 

  ```react
  import logo from "./logo.svg";
  import "./App.css";
  ```

  - 웹팩을 사용하면 SVG, CSS 파일을 불러와서 사용할 수 있는데 이것은 웹팩의 loader라는 기능이 담당한다. 
    - css-loader, file-loader, babel-loader가 있다. 
  - 웹팩 로더는 직접 설치하고 설정해야 하지만 `create-react-app`이 번거로운 작업을 다 해주는 것이다. 

- JSX란?

  - JSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼다. 
  - 작성한 코드는 바벨을 사용하여 코드가 번들링되는 과정에서 일반 자바스크립트 형태의 코드로 변환된다. 

  - 예시(변환 전 코드- JSX)

  ```react
  function App() {
    return (
      <div>
        Hello <b>react</b>
      </div>
    )
  }
  ```

  - 예시(변환 후 코드 - JS)

  ```js
  function App() {
    return React.createElement("div", null, "Hello", React.createElement("b", null, "react"));
  }
  ```

  - 매번 React.createElement 함수를 사용한다면 불편하다. 그래서 JSX를 사용하면 html를 좀 더 쉽게 작성할 수 있고 편하게 UI를 렌더링할 수 있다. 
  - JSX는 리액트로 프로젝트를 개발할 때 사용되므로 공식적인 자바스크립트 문법이 아니다. 

- JSX의 장점?

  - 보기 쉽고 익숙하다
    - 가독성도 높고 작성하기도 쉽다. 
  - 더욱 높은 활용도
    - JSX는 우리가 알고 있는 HTML 태그를 사용할 수 있을 뿐만 아니라, 앞으로 만들 컴포넌트도 JSX 안에서 작성할 수 있다. 

- JSX 문법

  - 감싸인 요소 
    - 컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 한다. 
  - 예시(부모요소가 없어 잘못된 케이스)

  ```react
  function App() {
    return (
        <h1>리액트 안녕</h1>
        <h2>잘 작동하니?</h2>
    );
  }
  
  export default App;
  ```

  - 예시(옳은 케이스)

  ```react
  function App() {
    return (
      <div>
        <h1>리액트 안녕</h1>
        <h2>잘 작동하니?</h2>
      </div>
    );
  }
  
  export default App;
  ```

  - 이렇게 하는 이유는 **가상돔에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져 있어야 한다는 규칙이 존재**

  - div가 사용하기 싫으면 React v16 이상부터 도입된 Fragment라는 기능을 사용하면 된다.

  - 예시

  ```react
  function App() {
    return (
      <>
        <h1>리액트 안녕</h1>
        <h2>잘 작동하니?</h2>
      </>
    );
  }
  
  export default App;
  ```

- 자바스크립트 표현

  - JSX 안에서 자바스크립트 표현식 사용 가능하다.
  - 변수 선언은 return문 위에서 하고  
  - JSX 내부에서 코드를 `{}`감싸면 된다.
  - 예시

  ```react
  function App() {
    const name = "리액트";
    return (
      <>
        <h1>{name} 안녕</h1>
        <h2>잘 작동하니?</h2>
      </>
    );
  }
  
  export default App;
  ```

- if 문 대신 조건부 연산자

  - JSX 내부에서는 If문을 사용할 수 없다. JSX 밖에서 사용하거나 아니면 `{}`중괄를호 사용하여 조건부 연산자를 사용하고 `()`소괄호 안에 구문에 해당 할 때 보여주고 싶은 값을 넣으면 된다.  
  - 조건부 연산자의 또 다른 이름은 **삼항 연산자**이다. 

  - 예시

  ```react
  function App() {
    const name = "리액트";
    return (
      <>
        {name === "리액트" ? (
          <h1>리액트입니다.</h1>
        ) : (
          <h2>리액트가 아닙니다.</h2>
        )}
      </>
    );
  }
  
  export default App;
  ```

- AND 연산자(&&)를 사용한 조건부 렌더링

  - 특정 조건을 만족할 때 내용을 보여 주고, 만족하지 않을 때 아무것도 렌더링하지 않아야 하는 상황이 올 수 있다.

  ```react
  function App() {
    const name = "리액트";
    return (
      <>
        {name === "리액트" && <h1>리액트입니다.</h1>}
      </>
    );
  }
  
  export default App;
  ```

  - name이 react일 때만 문구가 보인다.
  - 한 가지 예외사항은 **falsy한 값인 0은 예외적으로 화면에 나타난다.**

  ```react
  function App() {
    const number = 0;
    return (
      <>
        {number && <h1>리액트입니다.</h1>}
      </>
    );
  }
  
  export default App;
  ```

  - jsx는 주로 여러 줄로 작성할 때 괄호로 감싸고, 한 줄로 표현할 수 있는 JSX는 감싸지 않는다. 필수 사항이 아니다. 

  

  

- undefined를 렌더링하지 않기

  - 리액트 컴포넌트에서는 함수에서 undefined만 반환하여 렌더링하는 상황을 만들면 안 된다. 

  - OR 연산자를 사용하거나 JSX 내부에 undefined를 렌더링하는 것은 괜찮다. 

  

- 인라인 스타일링

  - 리액트 DOM 요소에 스타일 적용할 때는 문자열 형태로 넣는 것이 아니라 객체 형태로 넣어 주어야 한다. 
  - 이름 - 문자를 없애고 camelCase으로 작성해야 한다. 

  ```react
  function App() {
    const name = "리액트";
    const style = {
      backgroundColor: "black",
      color: "aqua",
      fontSize: "48px",
      fontWeight: "bold",
      padding: 16
    }
  
    return <div style={style}>{name}</div>
  }
  
  export default App;
  ```

- class 대신 className

  - App.css에서 style 작성 후에 App.css에서 css 클래스를 불러와서 사용한다.

  ```css
  .react {
    background: aqua;
    color: black;
    font-size: "48px";
    font-weight: "bold";
    padding: 16px;
  }
  ```

  ```react
  import React from "react";
  import "./App.css"
  
  function App() {
    const name = "리액트";
    return <div className="react">{name}</div>
  }
  
  export default App;
  ```

  - class라고 쓰면 경고창 뜬다.  className 사용하자.

- 꼭 닫아야 하는 태그 

  - HTML에서는 input를 그냥 써도 되는데 JSX는 태그 작성할 때 반드시 닫는 태그가 있어야 한다. 
  - 예시1

  ```react
  import React from "react";
  import "./App.css"
  
  function App() {
    const name = "리액트";
    return (
      <>
       <div className="react">{name}</div>
       <input></input>
      </>
    )
  }
  
  export default App;
  ```

  - 예시2 

    - 태그 사이에 별도의 내용이 들어가지 않으면 self-closing 태그를 사용해서 선언 동시에 닫을 수 있다.

    ```react
    import React from "react";
    import "./App.css"
    
    function App() {
      const name = "리액트";
      return (
        <>
         <div className="react">{name}</div>
         <input />
        </>
      )
    }
    
    export default App;
    ```

- 주석

  - JSX 안에서 주석을 작성하는 방법은 일반 자바스크립트에서 작성할 때와 조금 다르다.
  - `{/* 주석 */}` 이렇게 작성하자

  ```react
  import React from "react";
  import "./App.css"
  
  function App() {
    const name = "리액트";
    return (
      <>
       {/* 주석은 이렇게 작성한다. */}
       <div className="react">{name}</div>
       <input></input>
      </>
    )
  }
  
  export default App;
  ```

  

- Prettier 설정

  - 프로젝트의 root directory(src, public)에서 `.prettierrc`라는 파일 생성 후에 커스터 마이징을 한다. 

  ```react
  {
    "singleQuote" : true,
    "semi" : true,
    "useTabs" : false,
    "tabWidth": 2
  }
  ```

  

### 컴포넌트

#### 클래스형 컴포넌트

- 클래스형 컴포넌트는 state 기능 및 라이프사이클 기능을 사용할 수 있다는 것과 임의 메서드를 정의할 수 있다. 
- 클래스형 컴포넌트에서는 **render 함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할 JSX를 반환해야 한다**. 

```react
import React, { Component } from "react";
import "./App.css"

class App extends Component {
  render() {
    const name = "react";
    return <div className="react">{name}</div>
  }
}

export default App;
```

#### 함수형 컴포넌트 vs 클래스형 컴포넌트

- 함수형 컴포넌트는 클래스형 컴포넌트보다 선언하기 훨씬 편하다.
- 메모리 자원도 클래스형 컴포넌트보다 덜 사용한다. 
- 프로젝트를 완성하여 빌드한 후 배포할 대도 함수형 컴포넌트를 사용하는 것이 결과물의 파일 크기가 더 작다. 
  - 근데 사실상 성능과 파일 크기 면에서 별 차이가 없다. 
- 함수형 컴포넌트 단점은 state와 라이프사이클 API의 사용이 불가능하다는 점인데 이 부분도 16 버전 이후 Hooks의 도입되면서 해결됐다.

#### 첫 컴포넌트 생성

- 함수형 컴포넌트
  - 코드 스니펫 단축키 `rsc`

```react
import React from 'react'

const MyComponent = () => {
  return <div>나의 새롭고 멋진 컴포넌트</div>
}

export default MyComponent;import React from 'react'
```

- 모듈 불러오기 

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent />
}

export default App;
```



#### props

- props는 properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는 요소이다. 
- props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트(현 상황에서는 App 컴포넌트가 부모 컴포넌트)에서 설정할 수 있다.
- JSX 내부에서 props 렌더링(자식 컴포넌트에서 받기)

```js
import React from 'react';

const MyComponent = (props) => {
  return (
    <div>
      안녕하세요, 제 이름은 {props.name}입니다.
    </div>
  );
};

export default MyComponent;
```

- 컴포넌트를 사용할 때 props 값 지정하기(부모 컴포넌트에서 전달)

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent name="React"/>
}

export default App;
```

- props 기본값 설정: defaultProps

```react
import React from 'react';

const MyComponent = props => {
  return <div> 안녕하세요, 제 이름은 {props.name}입니다.</div>
};

MyComponent.defaultProps = {
  name: "기본 이름"
}

export default MyComponent;
```

- 태그 사이의 내용을 보여 주는 children
  - MyComponent 태그 사이에 작성한 리액트라는 문자열을 MyComponent 내부에서 보여 주려면 props.children 값을 보여 주어야 한다. 

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent>리액트</MyComponent>
}

export default App;
```

```react
import React from 'react';

const MyComponent = props => {
  return (
    <div>
      안녕하세요, 제 이름은 {props.name}입니다. <br />
      children 값은 {props.children}
      입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}


export default MyComponent;
```

- 비구조화 할당 문법을 통해 props 내부 값 추출하기
  - 이렇게 코드를 작성하면 name, children을 더 짧게 사용 가능

```react
import React from 'react';

const MyComponent = props => {
  const { name, children } = props;
  return (
    <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}


export default MyComponent;
```

- 비구조화 할당 문법을 이용한 다른 방법
  - 이게 엄청 쉬운 방법 그니까 파라미터 부분에서 비구조화 할당 문법 사용하자

```react
import React from 'react';

const MyComponent = ({ name, children }) => {
  return (
    <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}


export default MyComponent;
```

- propTypes를 통한 props 검증
  - 컴포넌트의 필수 props를 지정하거나 props의 타입을 지정할 때는 propTypes를 사용한다.
  - 컴포넌트의 propTypes를 지정하는 방법은 defaultProp을 설정하는 것과 비슷하다. 
  - 타입 지정 후에 반드시 타입에 맞는 값을 props로 전달해야 한다. 

```react
import React from 'react';
import PropTypes from "prop-types";

const MyComponent = ({ name, children }) => {
  return (
    <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}

MyComponent.propTypes = {
  name: PropTypes.string
}

export default MyComponent;
```

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent name={"React"}>리액트</MyComponent>
}

export default App;
```

- isRequired를 사용하여 필수 propTypes 설정

```react
import React from 'react';
import PropTypes from "prop-types";

const MyComponent = ({ name, favoriteNumber, children }) => {
  return (
    <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
      <br />
      제가 좋아하는 숫자는 {favoriteNumber}입니다.
    </div>
  )
};

MyComponent.defaultProps = {
  name : "기본 이름"
}

MyComponent.propTypes = {
  name: PropTypes.string,
  // 숫자로 지정
  favoriteNumber: PropTypes.number.isRequired
}


export default MyComponent;
```

```react
import React from "react";
import "./App.css"
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent name={"React"} favoriteNumber={1}>리액트</MyComponent>
}

export default App;
```

- 클래스형 컴포넌트에서 props 사용하기

```react
import React, {Component} from 'react';
import PropTypes from "prop-types";

class MyComponent extends Component {
  render() {
    const { name, children, favoriteNumber } = this.props;
    return (
      <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
      <br />
      제가 좋아하는 숫자는 {favoriteNumber}입니다.
    </div>
    )
  }
};

MyComponent.defaultProps = {
  name : "기본 이름"
}

MyComponent.propTypes = {
  name: PropTypes.string,
  favoriteNumber: PropTypes.number.isRequired
}


export default MyComponent;
```

- defaultProps와 propTypes를 설정할 때 class 내부에서 지정하는 방법

```react
import React, {Component} from 'react';
import PropTypes from "prop-types";

class MyComponent extends Component {
  static defaultProps = {
    name : "기본 이름"
  };
  static propTypes = {
    name: PropTypes.string,
    favoriteNumber: PropTypes.number.isRequired
  }

  render() {
    const { name, children, favoriteNumber } = this.props;
    return (
      <div>
      안녕하세요, 제 이름은 {name}입니다. <br />
      children 값은 {children}
      입니다.
      <br />
      제가 좋아하는 숫자는 {favoriteNumber}입니다.
    	</div>
    )
  }
};

export default MyComponent;
```

- defaultProps와 propTypes는 다른 개발자랑 협업하면 해당 컴포넌트에 어떤 props가필요한지 쉽게 알 수 있어 개발 능률이 좋아진다. 



#### state

- 리액트에서 state는  컴포넌트 내부에서 바뀔 수 있는 값을 의미한다. 
- props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props를 읽기 전용으로만 사용할 수 있다.
- 리액트에는 두 가지 종류의 state가 있다. 하나는 클래스형 컴포넌트가 지니고 있는 state이고, 다른 하나는 함수형 컴포넌트에서 useState라는 함수를 통해 사용하는 state이다.

- 클래스형 컴포넌트의 state

```react
import React, { Component } from 'react'

export default class Counter extends Component {
  constructor(props) {
    super(props);
    // state 정의
    this.state = {
      number: 0
    };
  }

  render() {
    // 구조분해할당으로 사용 가능
    const { number } = this.state;
    return (
      <div>
        <h1>{number}</h1>
        <button
          onClick={() => {
            // this.setState를 사용하여 state에 새로운 값을 넣을 수 있다.
            this.setState({ number: number + 1})
          }}
        >
         +1
        </button>
      </div>
    )
  }
}
```



- state를 constructor에서 꺼내기
  - 다른 방식으로 state 초깃값을 지정 가능
  - constructor 메서드 사용 안해도 됨. 

```react
import React, { Component } from 'react'

export default class Counter extends Component {
  state = {
    number: 0,
    fixedNumber: 0,
  }

  render() {
    // 구조분해할당으로 사용 가능
    const { number, fixedNumber } = this.state;
    return (
      <div>
        <h1>{number}</h1>
        <h2>바뀌지 않는 값: {fixedNumber}</h2>
        <button
          onClick={() => {
            // this.setState를 사용하여 state에 새로운 값을 넣을 수 있다.
            this.setState({ number: number + 1})
          }}
        >
         +1
        </button>
      </div>
    )
  }
}
```



- this.setState에 객체 대신 함수 인자 전달하기

  - 기본 구조

  ```react
  this.setState((prevState, props) => {
    return {
      //업데이트하고 싶은 내용
    }
  })
  ```

  - 숫자 2씩 증가하기

  ```react
  import React, { Component } from 'react'
  
  export default class Counter extends Component {
    state = {
      number: 0,
      fixedNumber: 0,
    }
  
    render() {
      // 구조분해할당으로 사용 가능
      const { number, fixedNumber } = this.state;
      return (
        <div>
          <h1>{number}</h1>
          <h2>바뀌지 않는 값: {fixedNumber}</h2>
          <button
            onClick={() => {
              this.setState(prevState => {
                return {
                  number: prevState.number + 1
                };
              });
              this.setState(prevState => ({
                number: prevState.number + 1
              }))
            }}
          >
           +1
          </button>
        </div>
      )
    }
  }
  
  ```

  

- this.setState가 끝난 후 특정 작업 실행하기

  - setState의 두 번째 파라미터로 콜백함수를 등록하여 작업을 처리할 수 있다.

  ```react
  export default class Counter extends Component {
    state = {
      number: 0,
      fixedNumber: 0,
    }
  
    render() {
      // 구조분해할당으로 사용 가능
      const { number, fixedNumber } = this.state;
      return (
        <div>
          <h1>{number}</h1>
          <h2>바뀌지 않는 값: {fixedNumber}</h2>
          <button
            onClick={() => {
              this.setState({
                number: number + 1
              },
              () => {
                console.log("방금 setState가 호출되었습니다.");
                console.log("this.state")
              }
              )
            }}
          >
           +1
          </button>
        </div>
      )
    }
  }
  ```



- 함수형 컴포넌트에서 useState 사용하기

  - useState 함수의 인자에는 상태의 초깃값을 넣어 준다.
  - useState에서는 반드시 객체가 아니어도 상관없다. 
  - 배열의 첫 번쨰 원소는 현재 상태이고, 두 번째 원소는 상태를 바꾸어 주는 함수이다. 
    - 이 함수 setter함수라고 부른다. 

  ```react
  import React, { useState } from 'react'
  
  export default function Say() {
    const [message,setMessage] = useState('');
    const onClickEnter = () => setMessage("안녕하세요!");
    const onClickLeave = () => setMessage("안녕히 가세요!");
  
    return (
      <div>
        <button onClick={onClickEnter}>입장</button>
        <button onClick={onClickLeave}>퇴장</button>
        <h1>{message}</h1>
      </div>
    )
  }
  ```

  

- 한 컴포넌트에서 useState 여러  번 사용하기

  - useState는 한 컴포넌트에서 여러 번 사용해도 상관없다. 

  ```react
  import React, { useState } from 'react'
  
  export default function Say() {
    const [message,setMessage] = useState('');
    const onClickEnter = () => setMessage("안녕하세요!");
    const onClickLeave = () => setMessage("안녕히 가세요!");
  
    const [color, setColor] = useState("black");
  
    return (
      <div>
        <button onClick={onClickEnter}>입장</button>
        <button onClick={onClickLeave}>퇴장</button>
        <h1 style={{color}}>{message}</h1>
        <button style={{ color : "red"}} onClick={() => setColor("red")}>
          빨간색
        </button>
        <button style={{ color : "green"}} onClick={() => setColor("green")}>
          초록색
        </button>
        <button style={{ color : "blue"}} onClick={() => setColor("blue")}>
          파란색
        </button>
      </div>
    )
  }
  ```

  

- state를 사용할 때 주의 사항

  - state값을 바꾸어야 할 때는 setState 혹은 useState를 통해 전달받은 세터 함수를 사용해야 한다.
  - 배열이나 객체를 업데이트 할 때는 반드시 사본을 만들고 값을 업데이트 한 후에 세터 함수를 통해 업데이트한다.
    - spread 연산자 활용

  ```react
  const object = { a: 1, b: 2, c: 3};
  // 사본을 만들어서 b 값만 덮어 쓰기
  const nextObject = { ...object, b: 2};
  ```

  - 배열 다루기

  ```react
  const array = [
    { id: 1, value: true},
    { id: 2, value: true},
    { id: 3, value: false}
  ];
  
  // 새 항목 추가
  let nextArray = array.concat({ id: 4})
  // id가 2인 항목 제거
  nextArray.filter(item => item.id !== 2);
  // id가 1인 항목의 value를 false로 설정
  nextArray.map(item => (item.id === 1 ? {...item, value: false} : item));
  ```

  

### 이벤트 핸들링

#### 클래스형 컴포넌트

- 사용자가 **웹 브라우저에서 DOM 요소들과 상호 작용하는 것을 이벤트**라고 한다. 

- 리액트의 이벤트 시스템 사용할 때 주의 사항

  - 이벤트 이름은 카멜 표기법으로 작성한다.
    - `onclick` => `onClick`
  - 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달한다.

- DOM 요소에만 이벤트를 설정할 수 있다.

  - 우리가 직접 만든 컴포넌트에는 이벤트를 자체적으로 설정할 수 없다.
  - 컴포넌트 내부의 DOM 이벤트로 설정할 수 있다. 

  - 예제로 이벤트 핸들링 익히기

    - onChange 이벤트 핸들링하기
    - onChange 이벤트 설정
      - e 객체는 합성이벤트로 웹 브라우저의 네이티브 이벤트를 감싸는 객체이다.
      - 합성 이벤트는 네이티브 이벤트와 달리 **이벤트가 끝나고 나면 이벤트가 초기화되므로 정보를 참조할 수 없다.**
      - 만약 비동기적으로 이벤트 객체를 참조할 일이 있다면 `e.persist() `함수를 호출해야 한다.  

    ```react
    import React, { Component } from 'react'
    
    export default class EventPractice extends Component {
      render() {
        return (
          <div>
            <h1>이벤트 연습</h1>
            <input
              type= "text"
              name= "message"
              placeholder="아무거나 입력해 보세요"
              onChange= {
                // e객체는 SyntheticEvent로 웹 브라우저의 네이티브 이벤트를 감싸는 객체다.
                (e) => {
                  console.log(e.target.value);
                }
              }
            />
          </div>
        )
      }
    }
    ```

    - 버튼을 누를 때 comment 값을 공백으로 설정

    ```react
    import React, { Component } from 'react'
    
    export default class EventPractice extends Component {
      state = {
        message: ""
      }
    
      render() {
        return (
          <div>
            <h1>이벤트 연습</h1>
            <input
              type= "text"
              name= "message"
              placeholder="아무거나 입력해 보세요"
              value={this.state.message}
              onChange= {
                // e객체는 SyntheticEvent로 웹 브라우저의 네이티브 이벤트를 감싸는 객체다.
                (e) => {
                  this.setState({
                    message: e.target.value
                  })
                }
              }
            />
            <button onClick={
              () => {
                alert(this.state.message);
                this.setState({
                  message: ""
                });
              }
            }>
              확인
            </button>
          </div>
        )
      }
    }
    ```

    - 임의 메서드 만들기

      - 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달한다. 

      - 기본 방식
        - 함수가 호출될 때 this는 호출부에 따라 결정되므로, 클래스의 임의 메서드가  특정 HTML 요소의 이벤트로 등록되는 과정에서 메서드 this의 관계가 끊어져 버린다. 
        - 그래서 this를 컴포넌트 자신으로 제대로 가리키기 위해서는 메서드를 this와 바인딩하는 작업이 필요하다. 그렇지 않으면 this가 undefined를 가리키게 된다. 

      ```react
      import React, { Component } from 'react'
      
      export default class EventPractice extends Component {
        state = {
          message: ""
        }
      
        constructor(props) {
          super(props);
          this.handleChange = this.handleChange.bind(this);
          this.handleClick = this.handleClick.bind(this);
        }
      
        handleChange(e) {
          this.setState({
            message: e.target.value
          });
        }
      
        handleClick() {
          alert(this.state.message);
          this.setState({
            message: ""
          })
        }
      
        render() {
          return (
            <div>
              <h1>이벤트 연습</h1>
              <input
                type= "text"
                name= "message"
                placeholder="아무거나 입력해 보세요"
                value={this.state.message}
                onChange= {this.handleChange}
              />
              <button onClick={this.handleClick}>
                확인
              </button>
            </div>
          )
        }
      }
      ```

      - 더 쉬운 방식(Property initailizer Syntax)를 사용한 메서드 작성

        - 새 메서드를 만들 때마다 constructor도 수정해야 하기 때문에 좀 더 쉽게 하는 방법이다.
          - Babel의 transform-class-properties 문법을 사용하여 화살표 함수 형태로 메서드를 정의한다.

        ```react
        import React, { Component } from 'react'
        
        export default class EventPractice extends Component {
          state = {
            message: ""
          }
        
          handleChange = (e) => {
            this.setState({
              message: e.target.value
            });
          }
        
          handleClick = (e) => {
            alert(this.state.message);
            this.setState({
              message: ""
            })
          }
        
          render() {
            return (
              <div>
                <h1>이벤트 연습</h1>
                <input
                  type= "text"
                  name= "message"
                  placeholder="아무거나 입력해 보세요"
                  value={this.state.message}
                  onChange= {this.handleChange}
                />
                <button onClick={this.handleClick}>
                  확인
                </button>
              </div>
            )
          }
        }
        ```

      - input 여러개 다루기

      ```react
      import React, { Component } from 'react'
      
      export default class EventPractice extends Component {
        state = {
          username: "",
          message: ""
        }
      
        constructor(props) {
          super(props);
          this.handleChange = this.handleChange.bind(this);
          this.handleClick = this.handleClick.bind(this);
        }
      
        handleChange(e) {
          this.setState({
            [e.target.name]: e.target.value
          });
        }
      
        handleClick() {
          alert(this.state.username + ': ' + this.state.message);
          this.setState({
            username: "",
            message: ""
          })
        }
      
        render() {
          return (
            <div>
              <h1>이벤트 연습</h1>
              <input
                type= "text"
                name= "username"
                placeholder="사용자명"
                value={this.state.username}
                onChange= {this.handleChange}
              />
              <input
                type= "text"
                name= "message"
                placeholder="아무거나 입력해 보세요"
                value={this.state.message}
                onChange= {this.handleChange}
              />
              <button onClick={this.handleClick}>
                확인
              </button>
            </div>
          )
        }
      }
      ```

      - 다음 코드가 핵심
        - 객체 안에서  key를 [ ]로 감싸면 그 안에 넣은 레퍼런스가 가리키는 실제 값이 key 값으로 사용된다. 

      ```react
      handleChange(e) {
        this.setState({
          [e.target.name]: e.target.value
        });
      }
      ```

      - 예를 들어 다음과 같은 객체를 만들면

      ```react
      const name = "variantKey";
      const object = {
        [name]: "value"
      }
      // 결과는 다음과 같다. 
      {
        "variantKey": "value"
      }
      ```

      - onKeyPress 이벤트 핸들링

      ```react
      import React, { Component } from 'react'
      
      export default class EventPractice extends Component {
        state = {
          username: "",
          message: ""
        }
      
        handleChange = (e) => {
          this.setState({
            // 해당 인풋의 Name을 가리키니 input 여러개 사용해도 문제 없음
            [e.target.name]: e.target.value
          });
        }
      
        handleClick = () => {
          alert(this.state.username + ': ' + this.state.message);
          this.setState({
            username: "",
            message: ""
          })
        }
      
        handleKeyPress = (e) => {
          if(e.key === "Enter") {
            this.handleClick();
          }
        }
      
        render() {
          return (
            <div>
              <h1>이벤트 연습</h1>
              <input
                type= "text"
                name= "username"
                placeholder="사용자명"
                value={this.state.username}
                onChange= {this.handleChange}
              />
              <input
                type= "text"
                name= "message"
                placeholder="아무거나 입력해 보세요"
                value={this.state.message}
                onChange= {this.handleChange}
                onKeyPress={this.handleKeyPress}
              />
              <button onClick={this.handleClick}>
                확인
              </button>
            </div>
          )
        }
      }
      ```

      ​				

#### 함수형 컴포넌트

- 이전코드 함수형 컴포넌트로 바꾸기

```react
import React, {useState} from 'react'

const EventPractice = () => {
  const [username, setUsername] = useState("");
  const [message, setMessage] = useState("");
  const onChangeUsername = e => setUsername(e.target.value);
  const onChangeMessage = e => setMessage(e.target.value);

  const onClick = () => {
    alert(username + ": " + message);
    setUsername("");
    setMessage("");
  }

  const onKeyPress = e => {
    if (e.key === "Enter") {
      onClick();
    }
  }

  return (
    <div>
      <h1>이벤트 연습</h1>
        <input
          type= "text"
          name= "username"
          placeholder="사용자명"
          value={username}
          onChange= {onChangeUsername}
        />
        <input
          type= "text"
          name= "message"
          placeholder="아무거나 입력해 보세요"
          value={message}
          onChange= {onChangeMessage}
          onKeyPress={onKeyPress}
        />
        <button onClick={onClick}>
          확인
        </button>
    </div>
  )
}

export default EventPractice
```

- 인풋의 개수가 많아진다면 e.target.name을 활용하자

```react
import React, {useState} from 'react'

const EventPractice = () => {
  const [form , setForm] = useState({
    username: "",
    message: ""
  })
  const { username, message } = form

  const onChange = e => {
    const nextForm = {
      // 기존의 form 내용을 이 자리에 복사한 뒤
      ...form,
      // 원하는 값을 덮어 씌우기
      [e.target.name]: e.target.value
    };
    setForm(nextForm);
  }


  const onClick = () => {
    alert(username + ": " + message);
    setForm({
      username: "",
      message: ""
    })
  }

  const onKeyPress = e => {
    if (e.key === "Enter") {
      onClick();
    }
  }

  return (
    <div>
      <h1>이벤트 연습</h1>
        <input
          type= "text"
          name= "username"
          placeholder="사용자명"
          value={username}
          onChange= {onChange}
        />
        <input
          type= "text"
          name= "message"
          placeholder="아무거나 입력해 보세요"
          value={message}
          onChange= {onChange}
          onKeyPress={onKeyPress}
        />
        <button onClick={onClick}>
          확인
        </button>
    </div>
  )
}

export default EventPractice
```







### ref: DOM에 이름 달기

#### ref는 어떤 상황에서 사용해야 할까?

- **정답은 DOM을 꼭 직접적으로 건드려야 할 때**이다.
- 예제 컴포넌트 생성

```react
import React, { Component } from 'react';
import "./ValidationSample.css";

export default class ValidationSample extends Component {
  state = {
    password: "",
    clicked: false,
    validated: false
  }

  handleChanged = (e) => {
    this.setState({
      password: e.target.value
    });
  }

  handleButtonClick = () => {
    this.setState({
      clicked: true,
      validated: this.state.password === "0000"
    })
  }

  render() {
    return (
      <div>
        <input
          type="password"
          value={this.state.password}
          onChange = {this.handleChanged}
          className = {this.state.clicked ? (this.state.validated ? "success" : "failure") : ""}
        />
        <button onClick={this.handleButtonClick}>검증하기</button>
      </div>
    )
  }
}

```

- DOM을 꼭 사용해야 하는 상황
  - 특정 input에 포커스 주기
  - 스크롤 박스 조작하기
  - Canvas 요소에 그림 그리기 



#### ref 사용

- 콜백 함수를 통한 ref 설정

  - ref를 달고자 하는 요소에 ref라는 콜백 함수를 props로 전달해 주면 된다. 
  - 콜백 함수는  ref 값을 파라미터로 전달받는다. 그리고 함수 내부에서 파라미터로 받은 ref를 컴포넌트의 멤버 변수로 설정해 준다.
  - 사용 예시

  ```react
  <input ref={(ref) => {this.input=ref}} />
  ```

- creatRef를 통한 ref 설정

  - 리액트에 내장되어 있는 createRef 라는 함수를 사용한다.

  - 예시 코드

  ```react
  import React, { Component } from 'react'
  
  export default class RefSample extends Component {
    input = React.createRef();
  
    handleFocus = () => {
      this.input.current.focus();
    }
  
    render() {
      return (
        <div>
          <input ref={this.input}/>
        </div>
      )
    }
  }
  ```

  

- onClick 이벤트 코드 수정

  - onClick 이벤트가 발생할 대 input에 포커스를 주도록 수정했다.

  ```react
  handleButtonClick = () => {
      this.setState({
        clicked: true,
        validated: this.state.password === "0000"
      })
      this.input.focus();
    }
  
    render() {
      return (
        <div>
          <input
            ref = {(ref) => this.input = ref}
            type="password"
            value={this.state.password}
            onChange = {this.handleChanged}
            className = {this.state.clicked ? (this.state.validated ? "success" : "failure") : ""}
          />
          <button onClick={this.handleButtonClick}>검증하기</button>
        </div>
      )
    }
  ```

  

####  컴포넌트에 ref 달기 

- 주로 이 방법은 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 사용한다. 
- 사용법

```react
<MyComponent 
	ref={(ref) => {this.myComponent=ref}}  
/>
```

- 스크롤 박스가 있는 컴포넌트를 하나 만들고, 스크롤바를 아래로 내리는 작업을 부모 컴포넌트에서 실행해보자.

- 컴포넌트 파일 생성

```react
import React, { Component } from 'react'

export default class ScrollBox extends Component {
  render() {
    const style = {
      border: "1px solid black",
      height: "300px",
      width: "300px",
      overflow: "auto",
      position: "relative"
    };

    const innerStyle = {
      width: "100%",
      height: "650px",
      background: "linear-gradient(white, black)"
    }

    return (
      <div
        style={style}
        ref={(ref) => {this.box=ref}}>
        <div style={innerStyle} />
      </div>
    )
  }
}
```

- 컴포넌트에 메서드 생성

  - 컴포넌트에 스크롤바를 맨 아래쪽으로 내리는 메서드를 만들겠다. 자바스크립트로 스크롤바를 내릴 때는  DOM 노드가 가진 다음 값들을 사용한다.

  - scrollTop: 세로 스크롤바 위치(0 ~350)
  - scrollHeight: 스크롤이 있는 박스 안의 div 높이(650)
  - clientHeight: 스크롤이 있는 박스의 높이(300)

```react
import React, { Component } from 'react'

export default class ScrollBox extends Component {
  scrollToBottom = () => {
    const { scrollHeight, clientHeight } = this.box;
    //스크롤바를 맨 아래쪽으로 내리려면 scrollHeight - clientHeight 빼면 된다.
    this.box.scrollTop = scrollHeight - clientHeight;
  }
  render() {
    const style = {
      border: "1px solid black",
      height: "300px",
      width: "300px",
      overflow: "auto",
      position: "relative"
    };

    const innerStyle = {
      width: "100%",
      height: "650px",
      background: "linear-gradient(white, black)"
    }


    return (
      <div
        style={style}
        ref={(ref) => {this.box=ref}}>
        <div style={innerStyle} />
      </div>
    )
  }
}
```

```react
import React, {Component} from "react";
import "./App.css"
import ScrollBox from "./ScrollBox";

class App extends Component {
  render() {
    return (
      <div>
        <ScrollBox ref={(ref) => this.scrollBox=ref}/>
        <button onClick={() => this.scrollBox.scrollToBottom()}>
          맨 밑으로
        </button>
      </div>
    )
  }


}
export default App;
```





### 컴포넌트 반복

#### 자바스크립트 배열의 map() 함수

- 문법

  `arr.map(callback, [thisArg])`

  - callback: 새로운 배열의 요소를 생성하는 함수로 파라미터는 다음 세 가지이다.
    - currentValue: 현재 처리하고 있는 요소
    - index: 현재 처리하고 있는 요소의 index 값
    - array: 현재 처리하고 있는 원본 배열
  - thisArg(선택 항목): callback 함수 내부에서 사용할 this 레퍼런스

- 예제

  ```js
  var numbers = [1, 2, 3, 4, 5];
  
  var processed = numbers.map(function(num) {
    return num * num;
  })
  // [ 1, 4, 9, 16, 25]
  console.log(processed);
  ```

- ES6으로 변환

  ```react
  const numbers = [1, 2, 3, 4, 5];
  const result = numbers.map((num) => num * num);
  console.log(result)
  ```



#### 데이터 배열을 컴포넌트 배열로 변환하기

- 컴포넌트 수정하기
  - 근데 아래 코드처럼만 작성하면 "key" prop이 없다는 경고 메시지를 표시한다.

```react
import React from 'react'

const IterationSample = () => {
  const names = ["눈사람", "얼음", "눈", "바람"];
  const nameList = names.map(name => <li>{name}</li>);
  return (
    <ul>
      {nameList}
    </ul>
  )
}

export default IterationSample
```

- Key

  - **리액트에서 key는 컴포넌트 배열을 렌더링했을 때 어떤 원소에 변동이 있었는지 알아내려고 사용한다.**
  - 유동적인 데이터를 다룰 때는 원소를 새로 생성, 제거, 수정할 수 있다. 
  - **key가 있으면 Virtual DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서 어떤 변화가 일어났는지 빠르게 알아낼 수 있다.** 
  - key값은 언제나 유일해야 한다. 데이터가 가진 고윳값을 key값으로 설정해야 한다. 

  ```react
  const articleList = articles.map(article => (
    <Article
      title = {article.title}
      writer = {article.writer}
      key = {article.id}
    />
  );
  ```

  - map에서는 보통 callback 함수의 index를 사용한다. 
    - 근데 고유한 값이 없을 때만 index를 key로 사용하자. index를 key로 사용하면 배열이 변경될 때 효율적으로 리렌더링하지 못한다. 
  - 예시

  ```react
  import React from 'react'
  
  const IterationSample = () => {
    const names = ["눈사람", "얼음", "눈", "바람"];
    const nameList = names.map((name, index) => <li key={index}>{name}</li>);
    return (
      <ul>
        {nameList}
      </ul>
    )
  }
  
  export default IterationSample
  ```

- 응용

  - 고윳값 만드는 예시 
  - 예시 코드

  ```react
  import React, { useState } from 'react'
  
  const IterationSample = () => {
    const [names, setNames] = useState([
      { id: 1, text: "눈사람"},
      { id: 2, text: "얼음"},
      { id: 3, text: "눈"},
      { id: 4, text: "바람"},
    ]);
    const [inputText, setInputText] = useState("");
    const [nextId, setNextId] = useState(5);
  
    const onChange = e => setInputText(e.target.value)
    const onClick = () => {
      const nextNames = names.concat({
        id: nextId,
        text: inputText
      });
      setNextId(nextId + 1);
      setNames(nextNames);
      setInputText("");
    }
  
  
    const nameList = names.map(name => <li key={name.id}>{name.text}</li>)
    return (
      <>
       <input value={inputText} onChange={onChange}/>
       <button onClick={onClick}>추가</button>
       <ul>{nameList}</ul>
      </>
    )
  }
  
  export default IterationSample
  ```

  - 위의 코드에서 우리는 input에 어떤 값을 넣으면 새로운 id와 text가 names 배열에 추가된다. 
  - 여기서 push메서드를 사용하지 않고 concat 메서드를 사용한 이유는 **push는 기존 배열 자체를 변경해 주는 반면, concat은 새로운 배열을 만들어 준다는 차이점이 있다.**
  - **리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서 새로운 값을 상태로 설정해야 한다. **이를 불변성 유지라고 하는데, **나중에 리액트 컴포넌트 성능을 최적화할 수 있다.**

  - 매우 중요:**데이터의 불변성을 유지하면서 배열의 특정항목을 지울때는 filter() 내장 함수를 사용해야 한다.** 
  - 데이터 제거 기능 구현
    - onDoubleClick 이벤트 활용

  ```react
  import React, { useState } from 'react'
  
  const IterationSample = () => {
    const [names, setNames] = useState([
      { id: 1, text: "눈사람"},
      { id: 2, text: "얼음"},
      { id: 3, text: "눈"},
      { id: 4, text: "바람"},
    ]);
    const [inputText, setInputText] = useState("");
    const [nextId, setNextId] = useState(5);
  
    const onChange = e => setInputText(e.target.value)
    const onClick = () => {
      const nextNames = names.concat({
        id: nextId,
        text: inputText
      });
      setNextId(nextId + 1);
      setNames(nextNames);
      setInputText("");
    }
  
    const onRemove = id => {
      const nextNames = names.filter(name => name.id !== id);
      setNames(nextNames);
    }
  
    const nameList = names.map(name => (
      <li key={name.id} onDoubleClick={() => onRemove(name.id)}>
        {name.text}
      </li>
    ))
  
    return (
      <>
       <input value={inputText} onChange={onChange}/>
       <button onClick={onClick}>추가</button>
       <ul>{nameList}</ul>
      </>
    )
  }
  
  export default IterationSample
  ```

  

### 컴포넌트의 라이프사이클 메서드

모든 리액트는 라이프사이클(수명 주기)이 존재한다. 

컴포넌트를 처음으로 렌더링할 때 어떤 작업을 처리해야 하거나 컴포넌트를 업데이트하기 전후로 어떤 작업을 처리해야 할 수도 있고, 불필요한 업데이트를 방지해야 할 수도 있다. 



#### 라이프사이클 메서드의 이해

- 라이프사이클 메서드의 종류는 총 9가지이다.

-  **WIll 접두사가 붙은 메서드는 어떤 작업을 작동하기 전에 실행되는 메서드**이고, **Did 접두사가 붙은 메서드는 어떤 작업을 작동한 후에 실행되는 메서드이다.**

- 라이플프사이클은 총 세 가지, 즉 **마운트, 업데이트, 언마운트** 카테고리로 나눈다.  

- 마운트

  - DOM이 생성되고 웹 브라우저상에 나타나는 것을 마운트라고 한다. 
  - 다음은 호출되는 메서드다
    - constructor 
      - 컴포넌트를 새로 만들때마다 호출되는 클래스 생성자 메서드
    - getDerivedStateFromProps
      - props에 있는 값을 state에 넣을때 사용하는 메서드
    - render
      - 우리가 준비한 UI를 렌더링하는 메서드이다.
    - componentDidMount 
      - 컴포넌트가 웹 브라우저상에 나타난 후 호출하는 메서드이다. 

- 업데이트

  - 총 네 가지의 경우 업테이트한다.

    - props가 바뀔 때
    - state가 바뀔 때
    - 부모 컴포넌트가 리렌더링될 때
    - this.forceUpdate로 강제로 렌더링을 트리거할 때 

  - 다음은 호출되는 메서드이다.

    - getDerivedStateFromProps
      - 마운트 과정에서도 호출되며, 업데이트가 시작하기도 전에 호출된다.
      - props의 변화에 따라 state 값에도 변화를 주고 싶을 때 사용한다. 
    - ShouldComponentUpdate
      - 컴포넌트가 리렌더링을 해야 할지 말아야 할지를 결정하는 메서드
      - true/false를 반환한다. 
      - true를 반환하면 다음 라이프사이클 메서드를 계속 실행하고, false 작업 중단(리렌더링 안 됨)
      - `this.forceUpdate`함수를 사용하면 이 과정 생략하고 바로 render 함수를 호출한다.  
    - render
      - 컴포넌트를 리렌더링한다.
    - getSnapShotBeforeUpdate
      - 컴포넌트 변화를 DOM에 반영하기 바로 직전에 호출하는 메서드이다. 
      - 최종본 인증샷 찍는거다. 

    - componentDidUpdate
      - 컴포넌트의 업데이트 작업이 끝난 후 호출하는 메서드이다.  

- 언마운트
  - 컴포넌트를 DOM에서 제거하는 것을 언마운트라고 한다
    - componentWilunmount
      - 컴포넌트가 웹 브라우저상에서 사라지기 전에 호출하는 메서드이다. 



#### 라이프사이클 메서드 살펴보기

- render() 함수

  `render() { ... }`

  - 컴포넌트 모양새를 정의한다. 그래서 매우 중요한 메서드이다. 
  - 라이프사이클 메서드 중 유일한 필수 메서드이기도 하다. 
  - 이 메서드 안에서 this.props와 this.state에 접근 가능, 리액트 요소를 반환
  - 요소는 div 같은 태그도 될 수 있고, 아무것도 보여주고 싶지 않다면 null 값이나 false값을 반환하도록 하세요
  - 다음 사항을 주의하세요
    - 메서드 안에서 이벤트 설정이 아닌 곳에서 setState을 사용하면 안 되고
    - 브라우저의 DOM에 접근해서도 안 된다.
    - DOM 정보를 가져오거나 state 변화를 줄 때는 componentDidMount에서 처리해야 한다.

- constructor 메서드

  `constructor(props) { ... }`

  - 이것은 컴포넌트 생성자 메서드로 컴포넌트를 만들 때 처음으로 실행된다. 이 메서드에서는 초기 state를 정할 수 있다.

  

- getDerivedStateFromProps 메서드

  - 리액트 v16 이후에 새로 만든 라이프사이클 메서드이다. 
  - **props로 받아온 값을 state에 동기화시키는 용도로 사용하며**, 컴포넌트가 마운트될 때와 업데이트될 때 호출된다.

  ```react
  static getDerivedStateFromProps(nextProps, prevState) {
    if(nextProps.value !== prevState.value) {
      return { value: nextProps.value };
    }
    // state를 변경할 필요가 없다면 null을 반환
    return null
  }
  ```

- componentDidMount 메서드

  `componentDidMount() { ... }`

  - 이것은 컴포넌트를 만들고, 첫 렌더링을 다 마친 후 실행한다. 
  - 이 안에서 다른 자바스크립트 라이브러리 또는 프레임워크의 함수를 호출하거나, setTimeout, setInterval, 네트워크 요청 같은 비동기 작업을 처리하면 된다. 

- shouldComponentUpdate 메서드

  `shouldComponentUpdate(nextProps, nextState) {...}`

  - 이것은 props 또는 state를 변경했을 때, 리렌더링을 시작할지 여부를 지정하는 메서드이다. 
  - 반드시 true / false를 반환해야 한다. 
  - 메서드 안에서 현재 props와 state은 this.props와 this.state로 접근하고, 새로 설정될 props 또는 state는 nextProps와 nextState로 접근할 수 있다. 
  - 프로젝트 성능을 최적화할 때, 상황에 맞는 알고리즘을 작성하여 리렌더링을 방지할 대는 false값을 반환하게 한다. 

- getSnapShotBeforeUpdate 메서드

  - 리액트 16버전 이후 만든 메서드
  - render에서 만들어진 결과물이 브라우저에 실제로 반영되기 직전에 호출된다. 
  - 이 메서드에서 반환하는 값은 componentDidUpdate에서 세 번째 파라미터인 snapshot 값으로 전달 받을 수 있다. 
  - **주로 업데이트하기 직전의 값을 참고할 일이 있을 때 활용(ex)스크롤바 위치 유지);**

  ```react
  getSnapshotBeforeUpdate(prevProps, prevState) {
    if(prveState.array !== this.state.array) {
      const { scrollTop, scrollHeight } = this.list
      return { scrollTop, scrollHeight};
    }
  }
  ```

- componentDidUpdate 메서드

  `componentDidUpdate(prevProps, prevState, snapshot) { ... }`

  - 리렌더링 완료후 실행한다. 업데이트가 끝난 직후이므로, DOM관련 처리를 해도 무방하다.
  - 여기서는 prevProps 또는 prevState를 사용하여 컴포넌트가 이전에 가졌던 데이터에 접근할  수 있다. 
  - getSnapshotBeforeUpdate에서 반환한 값이 있다면 여기서 snapshot 값을 전달받을 수 있다. 

- componentWillUnmount 메서드

  `componentWillUnmount() { ... }`

  - 이것은 컴포넌트를 DOM에서 제거할 때 실행한다. componentDidMount에서 등록한 이벤트, 타이머, 직접 생성한 DOM이 있다면 여기서 제거 작업을 해야 한다.

- componentDIdCatch 메서드

  - v16에 새롭게 도입되었고
  - **컴포넌트 렌더링 도중에 에러가 발생했을 때 애플리케이션이 먹통이 되지 않고 오류 UI를 보여 줄 수 있게 해준다. **

  ```react
  componentDidCatch(error, info) {
    this.setState({
      error: true
    });
    console.log({ error, info });
  }
  ```

  - error에서 어떤 에러가 발생했는지 알려 주며, info 파라미터는 어디에 있는 코드에서 오류가 발생했는지에 대한 정보를 준다. 
  - 이 메서드를 사용할 때는 컴포넌트 자신에게 발생하는 에러를 잡아낼 수 없고 자신의 this.props.children으로 전달되는 컴포넌트에서 발생하는 에러만 잡아낼 수 있다는 점을 알아두자. 



#### 라이프사이클 메서드 사용하기

