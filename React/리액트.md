### 리액트는 왜 쓰니?

- Single Page Application

  - 우리가 인터넷을 사용할 때 여러 웹사이트를 방문한다. 일반적으로 웹사이트는 여러 페이지로 구성되어 있다. 예를 들어, 쇼핑몰 사이트에는 홈페이지, 상품 목록 페이지, 장바구니 페이지 등이 있다.

  - 보통, 이렇게 다른 페이지로 이동할 때마다 새로운 화면이 로딩되고, 기존에 본 화면은 사라진다. 이런 경우, 우리는 화면 전환을 기다려야 하고, 때때로 느린 로딩 때문에 불편을 느낄 수 있다.
  - 그래서 만들어진게 SPA이다. 하나의 페이지로 구성된 웹사이트이다. 이렇게 하면, 페이지 이동 없이 필요한 정보만 빠르게 가져와서 화면에 보여준다. 그래서 화면 전환을 기다릴 필요가 없고, 사용자 경험이 좋아진다.
  - 예를 들어, 쇼핑몰 사이트에서 상품 목록에서 장바구니로 이동할 때, 전체 페이지를 로딩하는 대신에 필요한 부분만 빠르게 바뀐다. 
  - 결론적으로 SPA는 하나의 웹 페이지로 구성되어, 페이지 이동 없이 필요한 정보만 빠르게 가져와서 화면에 보여주는 웹사이트를 말한다. 이로 인해 사용자는 더 빠르고 편리한 경험을 누릴 수 있다. 
- html 재사용 편리
- 앱개발 기능
- react 프로젝트 생성: `npx create-react-app 프로젝트 이름` or `yarn create react-app 프로젝트 이름`





### JSX 문법 3개

- JSX란 

  - 자바스크립트 안에서 html을 좀 쉽게 작성할 수 있게 처리(.js 파일에서 쓰는 html 대용품)

    - 원래 JSX 없이 리액트에서 div를 만드려면

      `React.createElement("div", null, "Hello World")`를 사용해야하는데 그러지 않아도 된다.

  - 문법 1. class 넣을 땐 className

    ```react
    import './App.css';
    
    function App() {
      return (
        <div className="App">
          <div className="black-nav">
            <h3>hello</h3>
          </div>
        </div>
      );
    }
    
    export default App;
    ```

    - 우리가 작성하는 코드는 자바스크립트 파일 안에서 작성되는 것이다. 따라서 class라고 하면 class를 선언해달라는 문법이기 때문에 겹치지 않기 위해서 className이라고 작성한다.

      

  - 문법2. 중괄호{} 문법

    - 원래 자바스크립트에서 변수에 담긴 어떤 값을 html에 넣고 싶으면 `document.querySelector("h4").innerHTML = place;` 이런 식으로 사용해서 넣어야 했는데 JSX의 중괄호 문법을 사용하면 편하게 변수를 쓸 수 있다.

      ```react
      import './App.css';
      
      function App() {
      
        let place = "경기도";
        
        
        return (
          <div className="App">
            <div className="black-nav">
              <h4>장소</h4>
            </div>
            <h4>{ place }</h4>
          </div>
        );
      }
      
      export default App;
      ```

    - 중괄호는 `className = {place}` 안에도 사용할 수 있고 태그 안에도 `id={place}` 이런 식으로 사용 가능하다. 상상하는 모든 곳에 사용가능하다. 전문 용어로 **데이터 바인딩**이라고 한다.

  - 문법3. style={}

    - html에 style을 넣고 싶으면 className을 사용해도 좋지만 `style={ { color : "red" , "fontSize" : "10px" }}`해도 된다.
    - 여기서 주의사항 우리가 기존 css에서는 글씨 크기를 지정할때 `font-size` 를 보통 사용하는데 JSX에서 그렇게 쓰면 "font에서 size를 빼주세요"라는 뜻이 되니깐 `fontSize`이런 식으로 camelCase 방식으로 작성해야 한다.

  - Box-sizing: border-box

    - 기본적으로 박스 모델은 콘텐츠, 패딩, 테두리, 마진으로 나뉘어졌는데 width, height 사용할 때 기본적으로 콘텐츠 영역의 크기만 고려하게 되고, 즉 패팅, 테두리, 마진 영역은 width, height에 추가되는 값으로 계산

    - 즉 box-sizing: border-box는 박스의 크기 계산 방식을 변경해서, 박스 모델에서 콘텐츠 영역, 패딩 영역, 테두리 영역, 마진 영역을 모두 포함한 크기를 정확하게 지정할 수 있도록 도와주는 속성

### state

- 주의 사항 return() 안에는 병렬로 태그 2개 이상 쓰면 안 돼!! 아래 예시

```react
import './App.css';

function App() {

  let post = "강남 우동 맛집";

  return (
    <div className="App">
    </div>
    <div>
    </div>
  );
}

export default App;
```

- state은 왜 필요해?
  - 어떤 자료를 잠깐 저장하고 싶을 때 사용
  - 사용 방법
    - useState를 import 한다.
    - 그리고 내가 잠시 맡길 자료를 useState() 안에 작성한다.
    - 그리고 `let[상태, 상태 변경 도우미(함수)]` 이러한 형식을 따르면 자료를 사용할 수 있다.
  - 그럼 일반 변수  vs state?
    - 일반 변수는 갑자기 값이 변경되면 html에 자동으로 반영되지 않는다.
    - 반면에 state는 갑자기 값이 변경되면 html에 자동으로 반영(재렌더링)이 된다.
    - 자주 변경될 거 같은 부분만 state를 쓰자.
  
- warning message 없애기
  
  - `/* eslint-disable */` 을 사용
  
- `onClick ={ 함수 }` || onClick ={ function(){ console.log(1) } } ||  onClick ={ () => { console.log(1) } } 넣어주면 돼

- 함수는 긴 코드를 한 단어로 묶어주는 문법

- State 변경하는 법

  - 등호로 변경금지 `따봉 = 따봉 + 1 ` 
  - state변경함수(새로운 state)
    - 따봉변경(따봉+1)

  ```react
  /* eslint-disable */
  
  import { useState } from "react";
  import './App.css';
  
  function App() {
  
    let post = "강남 우동 맛집";
    let [a, b] = useState(["남자 코트 추천", "강남 우동맛집", "파이썬 독학"]);
  
    let [따봉, 따봉변경] = useState(0);
  
  
    return (
      <div className="App">
        <div className="black-nav">
          <h4>블로그임</h4>
        </div>
        <div className="list">
          <h4> {a[0]} <span onClick={ () => { 따봉변경(따봉+1) } }>👍</span> { 따봉 } </h4>
          <p>2월 17일 발행</p>
        </div>
        <div className="list">
          <h4> {a[1]} </h4>
          <p>2월 17일 발행</p>
        </div>
        <div className="list">
          <h4> {a[2]} </h4>
          <p>2월 17일 발행</p>
        </div>
      </div>
    );
  }
  
  export default App;
  
  ```

- State변경함수 특징
  - 기존 state === 신규 state의 경우 변경 안해줍니다.
- [array/object 특징]
  - array/object 담은 변수엔 값이 어딨는지 알려주는 화살표만 저장됨
  - 미지의 공간 Ram에 저장된다.
  - 만약 `글제목[0] = "여자코트 추천"` 이렇게 하면 array를 수정했지 변수에 있던 값이 어딨는지 알려주던 화살표는 수정안됨. 그래서 신규 state랑 기존 state랑 똑같다고 생각함.
  - 그래서 기존에 있던 array 데이터를 복사하면 기존 state랑 신규 state랑 달라지게되지만  위의 방식처럼해도 바뀌지 않는다. 왜냐면 변수에 저장된 것은 값이 어딨는지 알려주는 화살표만 저장된다. 
  - 변수 1 & 변수 2 화살표가 같으면 변수 1 == 변수2 비교해도 true가 나옴 그래서 바뀌지 않는다.
  - `let copy = [...글제목]` 이 방식은 괄호 벗겨준 다음에 다시 씌어준다. 완전히 독립적인 array가 탄생하고 화살표도 달라지게 된다.
  - 결론 state가 array/object면 독립적 카피본을 만들어서 수정해야 한다.(shallow copy)

```react
/* eslint-disable */

import { useState } from "react";
import './App.css';

function App() {

  let post = "강남 우동 맛집";
  let [글제목, 글제목변경] = useState(["남자 코트 추천", "강남 우동맛집", "파이썬 독학"]);


  let [따봉, 따봉변경] = useState(0);


  return (
    <div className="App">
      <div className="black-nav">
        <h4>블로그임</h4>
      </div>

      <button onClick={ () => {
        let copy = [...글제목];
        copy[0] = "여자코트 추천";
        console.log(copy == 글제목)
        글제목변경(copy)} }>
          글수정
      </button>

      <div className="list">
        <h4> {글제목[0]} <span onClick={ () => { 따봉변경(따봉+1) } }>👍</span> { 따봉 } </h4>
        <p>2월 17일 발행</p>
      </div>
      <div className="list">
        <h4> {글제목[1]} </h4>
        <p>2월 17일 발행</p>
      </div>
      <div className="list">
        <h4> {글제목[2]} </h4>
        <p>2월 17일 발행</p>
      </div>
    </div>
  );
}

export default App
```

```react
/* eslint-disable */

import { useState } from "react";
import './App.css';

function App() {

  let post = "강남 우동 맛집";
  let [글제목, 글제목변경] = useState(["남자코트추천", "강남우동맛집", "파이썬 독학"]);


  let [따봉, 따봉변경] = useState(0);


  return (
    <div className="App">
      <div className="black-nav">
        <h4>블로그임</h4>
      </div>

      <button onClick = { () => {
        let 정렬 = [...글제목].sort();
        글제목변경(정렬);
        }}>가나다순 정렬
      </button>

      <button onClick={ () => {
        let copy = [...글제목];
        copy[0] = "여자코트 추천";
        글제목변경(copy)} }>
          글수정
      </button>



      <div className="list">
        <h4> {글제목} <span onClick={ () => { 따봉변경(따봉+1) } }>👍</span> { 따봉 } </h4>
        <p>2월 17일 발행</p>
      </div>
      <div className="list">
        <h4> {글제목[1]} </h4>
        <p>2월 17일 발행</p>
      </div>
      <div className="list">
        <h4> {글제목[2]} </h4>
        <p>2월 17일 발행</p>
      </div>
    </div>
  );
}

export default App;
```





#### Component

- 더러운 html을 깔끔하게 한 단어로 축약하고 싶을때 componenet를 사용

- 첨보는 사람들도 이해할 수 있다

- 컴포넌트 만드는 법

  - function 만들고
    - 다른 function 바깥에 만들자
    - 영어대문자
  - return()안에 html 담기
    - 하나의 태그로 시작해서 하나의 태그로 끝나야한다.
    - 병렬로 집어넣는게 안 돼 
      - 만약에 병렬기입하려면 div 두 개로 묶은 부분을 하나 더 크게 div로 묶는다.
      - 의미없는 `<div>`대신 `<></>` 사용가능 전문용어로 fragment라고 한다.
  - <함수명></함수명> 쓰기 
    - `<함수명/> `이렇게도 사용 가능하다.

- 컴포넌트 언제 쓰면 좋은가?

  - 반복적인 html 축약할 때 
  - 큰 페이지들
    - 페이지 전환시
  - 자주변경되는 UI && html 들 

- 컴포넌트의 단점

  - State 가져다쓸 때 문제 생긴다. 다른 함수에 있을때는 그 함수에 있던 변수는 맘대로 가져다 쓸 수 없다.
  - 변수의 범위가 함수라서 그렇다. 

- 참고

  - 컴포넌트 만드는 다른 문법

    ```react
    // 값 변경시 에러메시지 출력
    const Modal = () => {
      return ()
    }
    ```

- 동적인 UI 만드는 step

  - html css로 미리 디자인 완성
  - UI의 현재 상태를 state로 저장
    - state를 저장할 때 오른쪽에 변경 함수는 보통 set~~ 이런식이 관습이다. 
    - useState() 안에 형식은 자유다. 모달창상태 표현만 가능하면 된다. 
  - state에 따라 UI가 어떻게 보일지 작성
    - html에 중간에 조건문을 쓰려면 중괄호 안에 if문을 사용할 수 없으니 대용품이 있다. 삼항연산자
    - 조건식? 참일때 실행할 코드 : 거짓일 때 실행할 코드
    - 아닐 경우 빈 문자열을 출력하거나 null(텅빈 값)
    - 쉽게 말해 스위치와 기계를 만드는거다.

  ```react
  /* eslint-disable */
  
  import { useState } from "react";
  import './App.css';
  
  function App() {
  
    let post = "강남 우동 맛집";
    let [글제목, 글제목변경] = useState(["남자코트추천", "강남우동맛집", "파이썬 독학"]);
  
    let [modal, setModal] = useState(false);
  
    let [따봉, 따봉변경] = useState(0);
  
  
    return (
      <div className="App">
        <div className="black-nav">
          <h4>blog</h4>
        </div>
  
        <button onClick = { () => {
          let 정렬 = [...글제목].sort();
          글제목변경(정렬);
          }}>가나다순 정렬
        </button>
  
        <button onClick={ () => {
          let copy = [...글제목];
          copy[0] = "여자코트 추천";
          글제목변경(copy)} }>
            글수정
        </button>
  
  
  
        <div className="list">
          <h4> {글제목} <span onClick={ () => { 따봉변경(따봉+1) } }>👍</span> { 따봉 } </h4>
          <p>2월 17일 발행</p>
        </div>
        <div className="list">
          <h4> {글제목[1]} </h4>
          <p>2월 17일 발행</p>
        </div>
        <div className="list">
          <div>
            <h4> {글제목[2]} </h4>
            <p>2월 17일 발행</p>
            <button onClick={ ()=>{ setModal(!modal) } }> {글제목[2]} </button>
            {
              modal == true ? <Modal></Modal> : null
            }
          </div>
        </div>
      </div>
    );
  }
  
  function Modal() {
    return (
      <div className="modal">
        <h4>제목</h4>
        <p>날짜</p>
        <p>상세내용</p>
      </div>
    )
  };
  
  export default App;
  ```

  ### map

  - 왼쪽 배열 자료만큼 내부코드 실행해준다.

  - 함수의 파라미터는 array 안에 있던 자료다. 

  - return에 뭐 적으면 array로 담아준다. 

  - 소괄호 안에 들어가는거 다 콜백함수 

    ```react
    [1, 2, 3].map(function(a) {
      return "1233211"
    })
    ```

  - 같은 html 반복생성하는 법 

  - 실제 블로그 글갯수만큼 html 생성해주세요.

  ```react
   	{
     // a는 배열에 안에 데이터이므로 파라미터 안에 아무거나 넣고 중괄호 안에 넣어주면 차례대로 배열에 있던 데이터가 출력된다. 
     // i는 반복문을 돌 때마다 1씩 증가하는 정수 
     글제목.map(function(a, i) {
      	return (
           <div className="list">
             <h4> { 글제목[i] } <span onClick={ () => { 따봉변경(따봉+1) } }>👍</span> { 따봉 }					</h4>
             <p>2월 17일 발행</p>
           </div>
         )
       })
    }
  ```

  - 참고

    - 반복문으로 html 생성하면 key={ html마다 다른숫자 } 추가해야한다.

  - 해당 글제목을 눌렀시에 따봉 +1을 하는법
    - state을 글제목 개수만큼 넣어주고 
    - 그리고 배열은 항상항상 꼭 배열을 복사 해줘야해 
    - 그리고 해당 글제목을 +1을 인덱스를 활용해서 해주고
    - 그것을 다시 함수 안에 넣어서 상태를 변경시키고
    - 그리고 배열에서 해당 글의 인덱스를 뽑아주면 된다. 

  ```react
  /* eslint-disable */
  
  import { useState } from "react";
  import './App.css';
  
  function App() {
  
    let post = "강남 우동 맛집";
    let [글제목, 글제목변경] = useState(["남자코트추천", "강남우동맛집", "파이썬 독학"]);
  
    let [modal, setModal] = useState(false);
  
    let [따봉, 따봉변경] = useState([0, 0, 0]);
  
  
    return (
      <div className="App">
        <div className="black-nav">
          <h4>blog</h4>
        </div>
  
       {
        글제목.map(function(a, i) {
          return (
            <div className="list" key={i}>
              <h4> { 글제목[i] } <span onClick={ () => {    
                let copy = [...따봉];
                copy[i] = copy[i] + 1;
                따봉변경(copy);
               } }>👍</span> { 따봉[i] } </h4>
              <p>2월 17일 발행</p>
            </div>
          )
        })
       }
      </div>
    );
  }
  
  export default App;
  
  ```

  

  ### Props

  - modal 안에 다른 함수에 작성했던 state를 쓰고 싶은데? 모든 변수는 함수탈출 불가다.
  - App 함수는 부모 Modal은 자식
  - 이러면 자식이 부모가 가지고 있던 state 사용 가능하다.
  - 부모 -> 자식 state 전송하는 법
    - <자식컴포넌트 작명={state이름}>
      - 작명이 귀찮으면 똑같은 이름을 쓰거라
    - props 파라미터를 자식 함수에 등록 후 props.작명 사용

  - props 전송은 오로지 부모 -> 자식만 가능(패륜, 불륜(같은 자식끼리) 전송 안 됨)
  - 파라미터 문법은 다양한 기능을 하는 함수를 만들 때 사용

  ```react
  let [메뉴, 메뉴변경] = useState(["김밥", "라면", "떡볶이"]);
  // 배경색 바꾸고 싶을때  
  {
       modal == true ? <Modal color={"yellow"} 메뉴={메뉴}/> : null
  }
  
  function Modal(props) {
    return (
      <div className="modal" style={{background: props.color}}>
        <h4>{props.메뉴[0]}</h4>
        <p>날짜</p>
        <p>상세내용</p>
      </div>
    )
  };
  ```

  - props로 일반 문자 전송 가능하다. 

  ```react
  {
        modal == true ? <Modal color="yellow" 메뉴={메뉴}/> : null
  }
  
  ```

  - 부모 state의 상태변경함수를 사용하는 법

  ```react
      {
        modal == true ? <Modal 메뉴={메뉴} 메뉴변경={메뉴변경}/> : null
      }
  
      </div>
    );
  }
  
  function Modal(props) {
    return (
      <div className="modal">
        <h4>{props.메뉴[0]}</h4>
        <p>날짜</p>
        <p>상세내용</p>
        <button onClick={ () => {
          let copy = [...props.메뉴];
          copy[0] = "빵";
          props.메뉴변경(copy) 
          }} >
          글수정</button>
      </div>
    )
  }
  ```

- 지금 누른 글 제목이 모달창 안에 뜨게 하려면?

  -  글제목 인덱스에 대한 상태를 추가하고
  - 글제목이 클릭될 때, 선택된 글제목 인덱스를 변경하는 함수를 호출하고 함수는 인자로 글제목의 인덱스를 받아 상태를 변경한다
  - 선택된 글제목 인덱스를 Modal 컴포넌트에 prop으로 전달하세요
  - Modal 컴포넌트에서 전달받은 prop을 사용하여 선택된 글제목 인덱스에 해당하는 글제목만 렌더링하세요.

  - 하나의 state가 두 개의 컴포넌트 둘 다 사용된다면 그 중에서 부모 컴포넌트에 만들자.
    - 왜 오직 부모 => 자식 컴포넌트에만  props를 전달할 수 있습니다. 

```react
/* eslint-disable */

import { useState } from "react";
import './App.css';

function App() {

  let [메뉴, 메뉴변경] = useState(["김밥", "라면", "떡볶이"]);

  let [modal, setModal] = useState(false);

  let [따봉, 따봉변경] = useState([0, 0, 0]);


  let [title, setIndex] = useState(0);

  return (
    <div className="App">
      <div className="black-nav">
        <h4>blog</h4>
      </div>

      <button onClick={ () => {
        let copy = [...메뉴];
        copy[0] = "삥";
        메뉴변경(copy)} }>
          메뉴수정
      </button>



     {
      메뉴.map(function(a, i) {
        return (
          <div className="list" key={i}>
            <h4 onClick={() => {setModal(!modal); setIndex(i)}}> { 메뉴[i] } <span onClick={ () => {
              let copy = [...따봉];
              copy[i] = copy[i] + 1;
              따봉변경(copy);
             } }>👍</span> { 따봉[i] } </h4>
            <p>2월 17일 발행</p>
          </div>
        )
      })
     }

    {
      modal == true ? <Modal
      메뉴={메뉴} 메뉴변경={메뉴변경} title={title}/> : null
    }

    </div>
  );
}

function Modal(props) {
  return (
      <div className = "modal">
        <h4>
          { props.메뉴[props.title] }
        </h4>
        <p>날짜</p>
        <p>상세내용</p>
        <button>글수정</button>
      </div>
  )
};

export default App;
```



### input

- input를 쓸 땐 반드시 끝내던지 `<input></input>` 아니면 `<input/>`  이렇게 해야한다. 
- `<input type="종류">`- text, range, checkbox, date 등등
- select는 옵션 선택
- textarea는 작성할 수 있는 크기가 더 커짐
- 만약에 뭔가 입력시 코드 실행하고 싶으면 아래 두 개 작성
  - `<input onChange={() => {}}>`
  - `<input onInput={() => {}}>`
- `<input onMouseOver={() => {}}>` 하면 마우스를 올려 놨을때 코드가 작동한다. 
- 이벤트핸들러 매우 많다.
- input에 입력한 값 가져오는 법
  - e = 이벤트 객체(지금 발생하는 이벤트에 관련한 여러 기능이 담겨 있다.)
  - ``<input onChange={(e) => {console.log(e.target.value)}}>``
  - target은 이벤트 발생한 html 태그
  - value는 이벤트 발생한 html태그에 입력한 값
- 현재 span 태그를 눌러도 모달창이 나오는것은 그것을 감싸고 있는 h4 그리고 div까지 총 3번 누르게 된다. 
- 클릭이벤트는 상위html로 퍼짐(이벤트 버블링)
- 상위html로 퍼지는 이벤트버블링을 막고 싶으면 `e.stopPropagation()`을 사용.

```react
/* eslint-disable */

import { useState } from "react";
import './App.css';

function App() {

  let post = "강남 우동 맛집";
  let [글제목, 글제목변경] = useState(["남자코트추천", "강남우동맛집", "파이썬 독학"]);

  let [modal, setModal] = useState(false);

  let [따봉, 따봉변경] = useState([0, 0, 0]);


  let [title, setIndex] = useState(0);

  return (
    <div className="App">
      <div className="black-nav">
        <h4>blog</h4>
      </div>

     {
      글제목.map(function(a, i) {
        return (
          <div className="list" key={i}>
            <h4 onClick={() => {setModal(!modal); setIndex(i)}}> { 글제목[i] } <span onClick={ (e) => { e.stopPropagation();
              let copy = [...따봉];
              copy[i] = copy[i] + 1;
              따봉변경(copy);
             } }>👍</span> { 따봉[i] } </h4>
            <p>2월 17일 발행</p>
          </div>
        )
      })
     }

    {
      modal == true ? <Modal
      글제목={글제목} 글제목변경={글제목변경} title={title}/> : null
    }

    </div>

  );
}


function Modal(props) {
  return (
      <div className = "modal">
        <h4>
          { props.글제목[props.title] }
        </h4>
        <p>날짜</p>
        <p>상세내용</p>
        <button>글수정</button>
      </div>
  )
};

export default App;
```

- input에 입력한 값 저장하려면 보통 변수 / state에 저장해둔다.
- state변경함수는 늦게 처리된다.(전문용어로 비동기처리)

```react
  <input onChange={(e) => {
    // 이거 완료되기 전에
    입력값변경(e.target.value);
    // 다음줄 실행해준다.
    console.log(입력값) }} />
```

- class를 이용한 옛날 React 문법

  - 기존 state에 변경사항만 즉, 차이점만 분석해서 차이점만 바꿔준다. 기존 state를 갈아치우는 게 아니라

  ```react
  import React from 'react';
  // 클래스 is 변수, 함수 보관함통
  class Modal2 extends React.Component {
    // props 받는 법
    constructor(props) {
      super(props);
      this.state = {
        name : "kim",
        age : 20
      }
    }
    render(){
      return (
        <div>안녕 {this.state.name}
          <button onClick={() => {
            // state 변경
            // 기존 state에 변경사항만 즉, 차이점만 분석해서 차이점만 바꿔준다. 기존 state를 갈아치우는 것이 아님  
            this.setState({age : 21});
          }}>버튼</button>
        </div>
      )
    }
  }
  ```

  



### bootstrap

- 레이아웃을 복사붙여넣기식으로 편하게 개발가능한 Bootstrap 라이브러리
- `npm install react-bootstrap bootstrap` -부트스트랩 설치
- css로 커스터마이징 가능

```react
import 'bootstrap/dist/css/bootstrap.min.css';
//여기서 import해야 버튼 사용 가능하다.
import { Button, Navbar, Container, Nav } from 'react-bootstrap';
import './App.css';

function App() {
  return (
    <div className="App">
      <Navbar bg="dark" variant="dark">
        <Container>
          <Navbar.Brand href="#home">Navbar</Navbar.Brand>
          <Nav className="me-auto">
            <Nav.Link href="#home">Home</Nav.Link>
            <Nav.Link href="#features">Features</Nav.Link>
            <Nav.Link href="#pricing">Pricing</Nav.Link>
          </Nav>
        </Container>
      </Navbar>
      <Button variant="primary">Primary</Button>
    </div>
  );
}

export default App;
```

- 이미지 넣는법

  - cs파일에선 그냥 ./이미지경로
  - JSX상에 이미지 넣으려면 
    - import 작명 from "이미지경로"
    - style ={{ backgroundImage: "url ("+ 작명 +")"}}
  - Bootstrap 이용해서 레이아웃 짜기(원조 bootstrap-조금 더 용량절약가능 )

  ```react
  <div className="container">
     <div className="row">
        <div className="col-md-4">안녕</div>
        <div className="col-md-4">안녕</div>
        <div className="col-md-4">안녕</div>
     </div>
  </div>
  ```

  - 외부 호스팅해둔 이미지라면 이미지 절대주소만 넣으면 된다.

  - Public 폴더 이용

    - 리액트는 사이트발행 전에 html, js, css 파일을 압축한다 (building)
    - 이미지 사용할 땐 /이미지경로
    - 주의점 
      - codingapple.com/어쩌구/에 발행시 문제
      - 그래서 경로도 /어쩌구/이미지경로로 해야한다.(근데 이게 까다로우니까)
        - `{process.env.PUBLIC_URL + '/이미지경로.png'}`

    ```react
    import 'bootstrap/dist/css/bootstrap.min.css';
    //여기서 import해야 버튼 사용 가능하다.
    import { Navbar, Container, Nav } from 'react-bootstrap';
    import './App.css';
    import bg from "./img/bg.png";
    
    function App() {
      return (
        <div className="App">
          <Navbar bg="light" variant="light">
            <Container>
              <Navbar.Brand href="#home">흔한 패션</Navbar.Brand>
              <Nav className="me-auto">
                <Nav.Link href="#features">카테고리</Nav.Link>
                <Nav.Link href="#pricing">장바구니</Nav.Link>
              </Nav>
            </Container>
          </Navbar>
    
          <div className="main-bg" style={{ backgroundImage: "url("+ bg +")"}}></div>
    
          <div className="container">
            <div className="row">
              <div className="col-md-4">
                <img src="{process.env.PUBLIC_URL + '/shoes1.jpg'}" width="80%" />
                <h4>상품명</h4>
                <p>상품정보</p>
              </div>
              <div className="col-md-4">
                <img src="/shoes2.jpg" width="80%" />
                <h4>상품명</h4>
                <p>상품정보</p>
              </div>
              <div className="col-md-4">
                <img src="/shoes3.jpg" width="80%" />
                <h4>상품명</h4>
                <p>상품정보</p>
              </div>
            </div>
          </div>
        </div>
      );
    }
    
    export default App;
    ```

    

  ### import/export 

  - 코드가 너무 길어서 src에 js파일을 만들고 나서 그 데이터를 export하는법
    - 한 개 있으면
      - export default 변수명
    - 여러개 하려면
      - export { 변수1, 변수 2}
  - import 하는법
    - 한 개 가져오려면
      - import 변수명 from 파일 위치
    - 여러개 가져오려면 
      - import { 변수1, 변수 2} from 파일 위치
      - 주의할 점 변수 1개를 import하면 작명 ok, 그러나 2개 이상 즉, 중괄호를 이용해서 가져오는 경우는 작명 불가

```react
import 'bootstrap/dist/css/bootstrap.min.css';
//여기서 import해야 버튼 사용 가능하다.
import { Navbar, Container, Nav } from 'react-bootstrap';
import './App.css';
import bg from "./img/bg.png";
import data from './data.js';
import { useState } from "react";




function App() {

  let [shoes] = useState(data)

  return (
    <div className="App">
      <Navbar bg="light" variant="light">
        <Container>
          <Navbar.Brand href="#home">흔한 패션</Navbar.Brand>
          <Nav className="me-auto">
            <Nav.Link href="#features">카테고리</Nav.Link>
            <Nav.Link href="#pricing">장바구니</Nav.Link>
          </Nav>
        </Container>
      </Navbar>

      <div className="main-bg" style={{ backgroundImage: "url("+ bg +")"}}></div>

      <div className="container">
        <div className="row">
          {
            shoes.map(function(a, i) {
              return (
                <Product shoes={shoes[i]} key={i} />
                )
              })
          }
        </div>
      </div>
    </div>
  );
}


function Product(props) {
    return(
      <div className="col-md-4">
        <img src={props.shoes.img} width="80%" alt="shoes"/>
          <h4>{props.shoes.title}</h4>
          <p>{props.shoes.price}</p>
      </div>
    )
}

export default App;
```

- 문자 중간에 변수 넣고 싶으면 "문자" + 변수 + ""문자" 





### 리액트 라우터: 셋팅과 기본 라우팅

- 페이지 나누는 법 (리액트 미사용)

  - html 파일 만들어서 상세페이지 내용 채운다. 
  - 누가 /detail로 접속하면 html 파일 보내줌

- 페이지 나누는 법 (리액트 사용)

  - 컴포넌트 만들어서 상세페이지내용 채움
  - 누가 /detail 접속하면 그 컴포넌트 보여줌
  - React-router-dom 라이브러리 쓰면 그런거 쉽게 만들 수 있다.
  - `npm install react-router-dom@6`

  ```js
  //경로 앞에 ./가 안 붙으면 대부분 설치한 라이브러리
  import { BroswserRouter } from "react-router-dom"
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(
    <React.StrictMode>
      <BrowserRouter>
      <App />
      </BrowserRouter>
    </React.StrictMode>
  );
  ```

  - 외부라이브러리는 필요할 때 검색해서 쓰는 것이다. 

  ```js
  // App.js
  import { Routes, Route, Link } from "react-router-dom";
  
  function App() {
    <Routes>
      <Route />
    </Routes>
    
  }
  ```

  - 라우팅: 웹 애플리케이션에서 사용자가 다른 페이지나 섹션을 이동할 때 페이지 전환을 처리하는 방법
  - Routes: Routes 컴포넌트는 라우팅을 정의하고 관리하는 데 사용된다. Route 컴포넌트 내에 여러 개의 Route 컴포넌트를 포함할 수 있으며 애플리케이션의 주요 라우팅 로직을 정의하는곳
  - Route: 개별적인 라우트를 정의하는데 사용된다. Route컴포넌트는 특정 URL패턴과 연결되어 있는 컴포넌트를 지정한다.

  - Link : 페이지 이동버튼



### Navigate, nested routes, outlet

- 리액트 폴더구조?

  - 비슷한 파일끼리 폴더로 묶는게 끝

- useNavigate() -훅(use로 시작하는 것들, 유용한 것들이 들어있는 함수)

  - 페이지 이동 도와준다.

  ```react
  import { Routes, Route, Link, useNavigate} from "react-router-dom";
  
  <Nav.Link onClick={() => { navigate(-1) }}>Home</Nav.Link>
  <Nav.Link onClick={() => { navigate("/detail") }}>Detail</Nav.Link>
  ```

- 404페이지 생성

  ```react
  <Route path="/detail" element={<Detail />}/>
  // *을 쓰면 위에 만든 라우터를 제외한 모든것
  <Route path="*" element={<>없는페이지요</>}/>
  ```

- Nested Routes

  ```react
  //(about/member), (/about/location)
  <Route path="/about" element={<About/>}>
     <Route path="member" element={<About/>}/>
     <Route path="location" element={<About/>}/>
  </Route>
  ```

  - 장점

    - route 작성이 약간 간단해질 수도 
    - Nested route 접속시엔 element 2개나 보임
      - 어디보여줄지 작성해야한다.(outlet 사용)
      - Nested routes의 element 보여주는 곳은 outlet

    ```react
    import { Routes, Route, Link, useNavigate, outlet} from "react-router-dom";
    
    
    <Route path="/about" element={<About/>}>
       <Route path="member" element={<div>멤버임</div>}/>
       <Route path="location" element={<About/>}/>
    </Route>
    function About() {
      return (
        <div>
          <h4>회사정보임</h4>
          <Outlet></Outlet>
        </div>
      )
    }
    ```
    
    - 언제 쓰면 좋나?
      - 여러 유사한 페이지 필요할 때 
        - 글자나 박스 같은 조금한 것들이 바뀌어야한다면 사용
        - 모달창 기능이나 탭 기능
    - 라우터의 장점
      - 이런 식으로 UI 만들면 뒤로가기 버튼 이용 가능
      - 페이지 이동이 쉬움(UI 스위치 조작 쉬움)



### URL 파라미터로 상세페이지 100개 만들기

- Function APP에서 detail 컴포넌트로 전송하려면 

  ```react
  <Route path="/detail" element={<Detail shoes={shoes}/>}/>
  ```

  - detail 컴포넌트 안에 shoes라는 state 더 만들면 편할까?

    -  그러면 문제가 발생... 나중에 수정사항이 생길 때 두 곳을 수정해야하니 불편... 

    - 그리고 detail에 상품이 여러개라면 상세페이지 100개가 필요하면?

    - 페이지 여러개 만들고 싶으면

      - : URL파라미터 써도 된다.

        - `<Route path="/detail/:id" element={<Detail shoes={shoes}/>}/>`

      - 이런식으로 상세페이지를 수백만개 만들 수 있음

        

    - 페이지는 여러개인데 보이는 내용은 똑같으면?

      - props를 활용하면 컴포넌트 1개로 각각 다른내용가능

      `<h4 className="pt-5">{props.shoes[현재url에 입력한 숫자].title}</h4>`

      - 유저가 URL파라미터에 입력한 거 가져오려면(`useparams()`)

      - URL 파라미터에 이상한거 입력하면?

        - id라는 변수가 이상하면 상품없다는 UI 보여주세요.

      - URL 파라미터 만들 때 여러개 가능

      - 오늘의 응용

      - /detail/0 접속시 0번째 상품말고 상품 id가 0인걸 보여주면 좋을듯

      - **상품의 영구번호가 0인 상품의 제목을 여기 보여주세요~** 

        ```react
        import { useParams } from "react-router-dom";
        
        function Detail(props) {
        
          let {id} = useParams();
        
          let product = props.shoes.find(item => item.id === parseInt(id));
        
        
          return (
            <div className="container">
            <div className="row">
              <div className="col-md-6">
                <img src="https://codingapple1.github.io/shop/shoes1.jpg" width="100%" />
              </div>
              <div className="col-md-6">
                <h4 className="pt-5">{product.title}</h4>
                <p>{product.content}</p>
                <p>{product.price}</p>
                <button className="btn btn-danger">주문하기</button>
              </div>
            </div>
          </div>
          )
        }
        
        ```

        

  - Style-components

    `npm install styled-components`이 안 돼서 `npm install -g yarn`을 설치해서 yarn 패키지 매니저 사용 후에 `yarn add styled-components` 로 설치

    - 이쁜 버튼 만들고 싶으면?

      - className 넣고 css 파일 가야함 

      - 귀찮으니 style-components를 사용함

        ```react
        // 이런식으로 styled.만들고 싶은거 + ``백틱 기호 안에 꾸미고 싶은거 꾸미고 변수로 정의하고
        let YellowBtn = styled.button`
          background : yellow;
          color : black;
          padding : 10px;
        `
        
        <yellowBtn>버튼</yellowBtn>
        ```

    - Style-components의 장점

      - 1. css 파일 안 열림
      - 2. 스타일이 다른 js파일로 오염되지 않는다. (vue.js의 scoped와 같다.)
           1. 기존 css파일의 스타일은 다른 js의 파일에 적용이 되기도 한다. 중복 
           2. 기존 css파일의 오염을 방지하려면 컴포넌트.module.css
      - 3. 페이지 로딩시간 단축
           1. html에 자동으로 `<style></style>`을 주입해준다. 

      - 오랜지색 버튼이 필요하면?

        - props 문법을 쓰면 된다.

        ```react
        let YellowBtn = styled.button`
          background : ${ props => props.bg};
          color : black;
          padding : 10px;
        `
        
        <YellowBtn bg="blue">버튼</YellowBtn>
        <YellowBtn bg="orange">버튼</YellowBtn>
        ```

        - 자바스크립트를 이용한 조건문 사용가능

        ```react
        let YellowBtn = styled.button`
          background : ${ props => props.bg};
          color : ${ props => props.bg == "blue" ? "white" : "black"};
          padding : 10px;
        `
        ```

        - 기존 스타일 복사가능

        ```react
        let NewBtn = styled.button(YellowBtn)
        ```

      - 단점
        - JS 파일 매우 복잡해짐
        - 중복스타일은 컴포넌트간 import할텐데 CSS와 다를 바가 없다.
        - 협업시 CSS 담당의 숙련도 이슈
        - 결론 도입여부가 중요하다.





### 컴포넌트의 Lifecycle(인생주기)

- 페이지 들어갔는데 보이는 순간을 페이지 장착(mounted)된다고 함
- 가끔 업데이트 된다.(update) - state 조작시
- 필요없으면 제거되고 (unmount) - 디테일되서 홈으로 돌아간다.
- 알아 놓으면 간섭 가능(중간중간 코드실행가능) - 수정, 삭제, 이동 할 때 특별한 기능 구현
- 그래서 useEffect()사용
- Function 안에 사용하면서 mount, update시 코드 실행
- 언제 쓰니?
  - 실행시점이 약간 다르다. (렌더링이 다 되고 나서 실행됨) 
  - 그럼 반복하거나 어려운 작업들을 Html이 렌더링이 되고 나서 실행하니까 조금 더 효율적이다.
  - 시간 오래 걸리는 코드나 어려운 연산을 할때는 useEffect를 사용하면 좋다.
  - 서버에서 데이터 가져오는 작업
- 왜 이름이 effect?야
  - Side Effect
    - 함수의 핵심기능과 상관없는 부가기능

```react
import { useEffect, useState } from "react";
import { useParams } from "react-router-dom";



function Detail(props) {
  let [alert, setAlert] = useState(true);
	
  useEffect(() => {
    setTimeout(() => {
      setAlert(false);
    }, 2000)
  })


  let [count, setCount] = useState(0);

  let {id} = useParams();

  let product = props.shoes.find(item => item.id === parseInt(id));


  return (
    <div className="container">
      <Box bg="green">
        { alert == true ? <div className="alert alert-warning">2초이내 구매시 할인</div> : null
        }
        { count }
        <button onClick={() => { setCount(count+1)}}>버튼</button>
      </Box>
    <div className="row">
      <div className="col-md-6">
        <h4 className="pt-5">{product.title}</h4>
        <p>{product.content}</p>
        <p>{product.price}</p>
        <button className="btn btn-danger">주문하기</button>
      </div>
    </div>
  </div>
  )
}


export default Detail;
```

- useeffect에 dependency를 사용하며 count라는 state가 변할 때만 실행됨

```react
// mount시, count라는 state가 변할 때 실행된다.
useEffect(() => {
  setTimeout(() => { setAlert(false)}, 2000)
}, [count])
```

- dependency가 있으면 effect 안에 있는 구문이 동작하지 않는다. 
- 그래서 mount시 1회만 실행하고 싶으면 dependency를 사용



- useEffect 안에 return문 작성 가능(useEffect 동작 전에 실행된다.)

```react
  useEffect(() => {
    setTimeout(() => {
      setAlert(false);
      console.log(1);
    }, 2000)
    
    // clean-up function
    return ()=> {
      기존타이머는 제거해주세요
    }
      
  }, [])


      <Box bg="green">
        { alertState === true ? <div className="alert alert-warning">2초이내 구매시 할인</div> : null
        }
        { count }
        <YellowBtn bg="blue">버튼</YellowBtn>
        <YellowBtn bg="orange">버튼</YellowBtn>
        <button onClick={() => { setCount(count+1)}}>버튼</button>
      </Box>
```

- React 특성상 재렌더링이 잦기 때문에 의도치 않게 타이머가 여러개 생성될 수 있다.
- Clean up function은 기존코드 치우는 거 작성함

```react
useEffect(() => {
  // 보통 타이머 함수는 변수 안에 담는다.
    let a = setTimeout(() => {
      setAlert(false);
      console.log(1);
    }, 2000)
  // clearTimeout() 함수는 타이머 제거 함수
    return () => {
      clearTimeout(a);
    }
  }, [])
```

- 대충 서버로 데이터 요청하는 코드(2초 소요)
  - 2초 사이에 재렌더링 된다면? 요청이 끝나기도전에 요청해
  
- cleanup function은 mount시 실행 안됨 unmount시 실행된다. 

-  다시 정리

  ```react
  // 1.재렌더링마다 코드실행 하고 싶으면
  useEffect(()=> {})
  // 2.mount시 1회 코드실행 하고 싶으면
  useEffect(()=> {}, [])
  // 3.unmount시 1회 코드실행하고 싶으면
  // 4.useEffect 실행 전에 뭔가 실행하려면 언제나 return () => {};
  useEffect(()=> {
    return () => {
      
    }
  },)
  // 5. 특성 state 변경시에만 실행하려면 [state명]
  useEffect(()=> {}, [])
  ```





### AJAX

- 서버에 데이터를 요청한다.

  - 서버: 데이터를 요청하면 데이터를 보내주는 프로그램

    - Ex)유튜버 서버: 동영상 요청하면 진짜 보내주는 프로그램
    - Ex) 웹툰 요청하면 진짜 보내주는 프로그램

  - 서버개발시 짜는 코드

    - 누가 comic.naver.com으로 요청하면 웹툰 보내주세요

  - 서버에 데이터를 요청할 떄 일정한 규격을 작성하자.

    - 방법 (GET/POST)
      - 받으면 get 
      - 보내면 post
    - 어떤자료 (URL)
      - 서버만든 사람에게 물어보자
    - 예를 들어 네이버웹툰서버한테 (comic.naver.com)으로 GET요청 하면된다.
    - 네이버 블로그에 글을 발행하고 싶으면 (blog.naver.com)으로 POST 요청
    - 브라우저에서 주소를 입력하는 곳이 GET요청 하는 곳이다.
    - 그러나 GET/POST 요청시 새로고침이 된다. 그게 싫으면 AJAX를 사용하면 새로고침 없이 데이터 주고 받기 가능

  - Ajax 쓰려면 옵션 3개 중 택 1

    - XMLHttpRequest

    - fetch()

    - Axois

      - npm install axios
      - import axios from "axios"
      - ajax 이용한 Get요청의 형식은 axios.get("url").then((result) => { result.가져올것 })

      - 리액트에서는 거의 서버와 ajax 이용해서 통신합니다.
      - Ajax 요청 실패할 경우?
        - 인터넷이 안되거나, 서버가 꺼졌거나, url 요청이 잘못됐을때
        - 실패할 경우 특정 코드를 실행하고 싶다. 

      ```react
      <button onClick={() => {
             axios.get("https://codingapple1.github.io/shop/data2ㅋㅋ.json")
             .then((결과) => {
             		console.log(결과.data)
             })
          	 // 실패했을때 실행할 코드
             .catch(() => {
               console.log("실패함")
             })
             
      }}>버튼</button>
      ```

    
    - 서버로 데이터전송하는 POST 요청
    
      ```react
      axios.post("/www.naver.com", {name : "Lee"})
      ```
    
    - 동시에 ajax요청 여러개하려면
    
      ```react
      Promise.all([ axios.get("/url1"), axios.get("/url2")])
      .then(() => {
      })
      ```
      
    - 원래는 서버와 문자만 주고받을 수 있다.(array/ object는 못 주고 받는다.)
    
    - 근데 따옴표를 쳐 놓으면 array, object도 주고받기 가능(JSON)
    
      - `"{"name" : "kim"}"`
      - axios가 array로 자동으로 바꿔준다.
    
    - fetch를 쓰면 라이브러리를 안 써도 괜찮다.
    - fetch(url).then(결과 => 결과.json().then(data =>{}))
      - fetch는 JSON => array/object 변환과정 필요



### 리액트에서 탭 UI 만들기

-  부트스트랩

```react
import { Nav } from "react-bootstrap";  

<Nav variant="tabs"  defaultActiveKey="link0">
   <Nav.Item>
     <Nav.Link eventKey="link0">버튼0</Nav.Link>
   </Nav.Item>
     <Nav.Item>
       <Nav.Link eventKey="link1">버튼1</Nav.Link>
     </Nav.Item>
   <Nav.Item>
       <Nav.Link eventKey="link2">버튼2</Nav.Link>
    </Nav.Item>
</Nav>
```

- if 문 활용해서 나타내고 싶을때 컴포넌트로 만들자 

  ```react
  function TabContent({tab}) {
    if (tab == 0) {
      return <div>내용0</div>
    } else if (tab == 1) {
      return <div>내용1</div>
    } else if (tab == 2) {
      return <div>내용2</div>
    }
  }
  ```

- 아니면 배열로도 할 수 있다.

  ```react
  function TabContent({tab}) {
    [<div>내용0</div>, <div>내용1</div>, <div>내용2</div>][tab]
  }
  ```

  

  ### contextAPI

  - props가 싫어 Context API(리액트 기본문법)
    - Props 전송없이 state 공유가능
      - 컴포넌트 재활용 어렵고 성능이 문제가 된다. 
  - 셋팅1. createContext()
    - context는 보관함이다.

  ```react
  import { createContext, useState } from "react";
  let Context1 = createContext()
  ```

  - 셋팅2. `<context>`로 원하는 컴포넌트 감싸기

  ```react
  <Route path="/detail/:id" element={
     <Context1.Provider>
       <Detail shoes={shoes}/>
     </Context1.Provider>
  }/>
  ```

  - 셋팅3.value={{ state1, state2 ... }} 사용하고 state

  ```react
  <Route path="/detail/:id" element={
  	<Context1.Provider value={{ 재고, shoes }}>
      <!-- 여기 안의 모든 컴포넌트는 재고, shoes 사용가능-->
  		<Detail shoes={shoes}/>
  	</Context1.Provider>
  }/>
  ```

  - state 사용 1.Context를 import

  ```react
  import {Context1} from "./../App.js"
  ```

  - state 사용 2.useContext(Context)

  ```react
  function Detail() {
    // 보관함 해체
    let {재고} = useContext(Context1)
  }
  ```

  - 부모 컴포넌트 뿐만 아니라 자식 컴포넌트에서 props없이 사용 가능하다.

  ```react
  fucntion TabContent() {
    let {재고} = useContext(context1)
  }
  ```

  - 쓰지 않는 이유
    - 1.State 변경시 쓸데없는 것까지 재랜더링
    - 변경되면 {재고} 안쓰는 놈들도 무조건 재렌더링
    - 나중에 컴포넌트 재사용이 어려움



### Redux

- Redux를 사용하면 컴포넌트들이 props 없이 state 공유가능

- 라이브러리 설치시 react, react-dom 18.1.0버전 이상이어야 한다. 

- redux 설치

  - `npm install @reduxjs/toolkit react-redux`

- 셋팅1. store.js 파일생성

  ```react
  import { configureStore } from "@reduxjs/toolkit"
  
  export default configureStore({
    reducer: {
  
    }
  })
  ```

- 셋팅2. index.js가서 `<Provider store={store}>`쓰기

  ```react
  import store from "../src/store.js"
  import { Provider } from "react-redux";
  
  
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(
      <Provider store={store}>
         <BrowserRouter>
        <App />
        </BrowserRouter>
      </Provider>
  );
  
  ```

- state 보관하는 법

  ```react
  import { configureStore, createSlice } from "@reduxjs/toolkit"
  
  // useState랑 비슷
  let user = createSlice({
    name: 'user',
    initialState : "kim"
  })
  
  
  export default configureStore({
    reducer: {
      user : user.reducer
    }
  })
  ```

- Redux Store의 state 꺼내는 법(useSelector)

  ```react
  // useSelect 쓸 때 state에서 어떤 슬라이스를 사용할 것인지 정해서 사용한다.
  let a = useSelector((state) =>  state.stock)
  ```

- 큰 프로젝트는 Redux를 사용하고 작은 프로젝트는 props를 사용하자

- 컴포넌트간의 공유가 필요없으면 그냥 UseState()를 사용하자 모든 것을 Redux store 안에 넣지 말자.



- Redux의 State 변경하는 법

  - 1.state 수정해주는 함수 만들기(reducers)

    ```react
    let user = createSlice({
      name: 'user',
      initialState : "kim",
      reducers: {
        // state은 initialState를 가리킨다.
        changeName(state) {
          return "John" + state
        }
      }
    })
    ```

  - 2.만든 함수 export 해야한다.

    ```react
    // 오른쪽 자료를 변수로 빼는 문법일 뿐
    export let { changeName, 함수2, .... } = user.actions
    ```

  - 3.만든 함수 import해서 사용

    - dispatch는 state변경함수를 실행해달라고 store.js에 부탁하는거다.

    ```react
    import { useDispatch } from "react-redux"
    // store.js로 요청보내주는 함수이다. 
    let dispatch = useDispatch()
    
    dispatch(state변경함수())
    ```

    - state를 직접 수정하면 프로젝트가 커지면 버그가 발생하면 찾으려면 애를 먹기 때문에 dispatch를 사용해서 store.js에 미리 만들어두자.

- state가 array/object인 경우

  ```react
  let user = createSlice({
    name : 'user',
    initialState : {name : 'kim', age : 20},
    reducers : {
      changeName(state){
        //state를 직접 수정해버려도 잘 되니까 직접 수정가능
        state.name = 'park'
      }
    }
  }) 
  ```

  - 결론: state가 object/array이면 return 없이 직접 수정해도 된다.

  - state 변경함수가 여러개 필요하면? 가끔은 +10하고 가끔은 +100하고 싶으면 어떻게 할까?

    - 파라미터 문법을 이용하자

    ```react
    // 이런 식으로 파라미터를 입력해서 함수사용이 가능하다. 파라미터 뒤에 payload를 붙어야한다.
    // payload는 메세지를 보내는 화물임
    changeAge(state, action) {
       state.age += action.payload;
    }
    // 파라미터에 값을 넣으면 우리가 원하는대로 동작한다.
    <button onClick={() => dispatch(changeAge(100))}>버튼</button>
    ```

    - action(state 변경함수) 안에 action에 대한 여러가지 정보가 들어있다. 그래서 payload를 통해 값을 전달한다.

  - 장바구니 수량 늘리기

    ```react
    //productSlice.js
    import { createSlice } from "@reduxjs/toolkit"
    
    let product = createSlice({
      name: "product",
      initialState: [
        {id : 0, name : 'White and Black', count : 2},
        {id : 2, name : 'Grey Yordan', count : 1}
      ],
      reducers: {
        increase(state, action) {
          // findIndex도 가능하다.
          const product = state.find((product) => product.id === action.payload);
          if (product) {
            product.count += 1;
          }
        },
      }
    })
    
    export let { increase } = product.actions
    
    export default product
    ```

    ```react
    import { Table } from 'react-bootstrap'
    import { useSelector, useDispatch } from "react-redux"
    import { increase } from "../store/productSlice.js";
    
    function Cart() {
    
      let state = useSelector((state) => state);
      let product = useSelector((state)=> state.product);
      let dispatch = useDispatch();
    
      return (
        <div>
          <Table>
            <thead>
              <tr>
                <th>#</th>
                <th>상품명</th>
                <th>수량</th>
              </tr>
            </thead>
            <tbody>
              {product.map((el, index) => (
                <tr key={index}>
                  <td>{product[index].id}</td>
                  <td>{product[index].name}</td>
                  <td>{product[index].count}</td>
                  <td>
                    <button onClick={() => {
                      dispatch(increase(product[index].id))
                    }}>+</button>
                  </td>
                </tr>
              ))}
            </tbody>
          </Table>
        </div>
      )
    }
    
    
    export default Cart
    ```

  - 장바구니 추가

    ```react
    import { createSlice } from "@reduxjs/toolkit"
    
    let product = createSlice({
      name: "product",
      initialState: [
        {id : 0, name : 'White and Black', count : 2},
        {id : 2, name : 'Grey Yordan', count : 1}
      ],
      reducers: {
        addProduct(state, action) {
          state.push(action.payload);
        }
      }
    })
    
    export let { addProduct } = product.actions
    
    export default product
    ```

  

  

  ### 컴포넌트 안에서 쓰는 Js 문법 

  - 이렇게 쓰면 else문 생략 가능

  ```react
  function Component() {
    if ( true ) {
      return <p>참이면 보여줄 HTML</p>;
    } 
    return null;
  } 
  ```

  

  - && 연산자

    ```react
    function Component() {
      return (
        <div>
          {
            1 === 1
            ? <p>참이면 보여줄 HTML</p>
            : null
          }
        </div>
      )
    } 
    
    function Component() {
      return (
        <div>
          { 1 === 1 && <p>참이면 보여줄 HTML</p> }
        </div>
      )
    }
    ```

    - 위의 예제 두 개는 동일한 역하을 한다
      - 왼쪽 조건식이 true면 오른쪽 jsx가 그 자리에 남는다.
      - 왼쪽 조건식이 false면 false가 남는다. 

  - switch 문법

    ```react
    function Component() {
      let user = "seller";
      Switch (user) {
        case "seller" :
        	return <h4>판매자 로그인</h4>
        case "customer" :
        	return <h4>구매자 로그인</h4>
        default :
        	return <h4>그냥 로그인</h4>
      }
    }
    ```

    - switch(검사할변수){} 이거부터 작성하고
    - 그 안에 case 검사할 변수가 이거랑 일치하냐를 넣어준다.
    - 그래서 일치하면 case : 밑에 있는 코드를 실행해준다.
    - Default:는 그냥 맨 마지막에 쓰는 else문과 동일하다. 

  - object/array 자료형 응용

    - 경우에 따라서 다른 html 태그를 보여주고 싶은 경우

    ```react
    var 탭UI = { 
      info : <p>상품정보</p>,
      shipping : <p>배송관련</p>,
      refund : <p>환불약관</p>
    }
    
    function Component() {
      var 현재상태 = 'info';
      return (
        <div>
          {
            탭UI[현재상태]
          }
        </div>
      )
    } 
    ```

  ### localStorage

  - Key: value 형태로 저장가능
  - 최대 5MB까지 문자만 저장가능
  - 사이트 재접속해도 남아있음 (브라우저 청소하면 삭제됨)
  - 로컬스토리지는 껐다 켜도 남아있는 반면에 세션은 끄면 데이터가 남아있지 않다.
  - 데이터 저장- `localStorage.setItem("이름", "값")`
  - 데이터 가져오기 - `localStorage.getItem('age')`
  - 데이터 삭제 - `localStorage.removeItem("age")`
  - 데이터 수정하는 문법 없다 꺼내서 수정하고 집어넣으면 된다. 
  - array/object 저장하려면 JSON으로 바꾸면 된다.
    - `localStorage.setItem("item", JSON.stringify(obj))`
  - JSON => array/object 변환은
    - `JSON.parse(data)`
  - Redux-persist를 쓰면 로컬스토리지에 자동으로 저장된다. 

  ### react-query

  - ajax 성공시/실패시 html 보여주려면?

  - 몇초마다 자동으로 ajax 요청?

  - 실패시 몇초 후 요청 재시도?

  - Prefetch?

  - 실시간 데이터를 계속 가져와야하는 사이트면 굿이다.

  - 설치

    - `npm install react-query`

    - index.js 설정(QueryClient, QueryClientProvider)

      ```react
      import React from 'react';
      import ReactDOM from 'react-dom/client';
      import './index.css';
      import App from './App';
      import reportWebVitals from './reportWebVitals';
      import { BrowserRouter } from "react-router-dom";
      import store from "../src/store.js"
      import { Provider } from "react-redux";
      import { QueryClient, QueryClientProvider } from "react-query";
      
      
      const queryClient = new QueryClient()
      
      
      
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(
        // <React.StrictMode>
          <QueryClientProvider client={queryClient}>
             <Provider store={store}>
              <BrowserRouter>
              <App />
              </BrowserRouter>
            </Provider>
          </QueryClientProvider>
        // </React.StrictMode>
      );
      ```

    - react-query로 ajax 요청하는 법

      ```react
      function App(){
        let result = useQuery('작명', ()=>
          axios.get('https://codingapple1.github.io/userdata.json')
          .then((a)=>{ return a.data })
        )
      }
      ```

      - 장점

        - 1.Ajax 요청 성공/실패/로딩중 상태를 쉽게 파악할 수 있다.

        - 2.틈만나면 자동으로 refetch해준다.

          - 간격 조정 가능함(아래처럼하면 2초 간격으로 refetch 된다.)

            ```react
            let result = useQuery('작명', ()=>
                axios.get('https://codingapple1.github.io/userdata.json')
                 .then((a)=>{
                   console.log("요청됨")
                   return a.data
                }),
                { staleTime : 2000 }
            )
            ```

        - 3.실패시 재시도 알아서 해줌

        - 4.ajax로 가져온 결과는 state 공유 필요없다.

          - 다른 컴포넌트에서 유저의 이름을 가져오고 싶다면? props를 쓰지 않아도 된다.
          - 다른 컴포넌트에 똑같이 코드를 적으면 되는데 react-query는 스마트하기 때문에 ajax 요청이 2개나 있으면 1개만 날려주고 
          - 캐싱기능이 있기 때문에 이미 같은 ajax 요청을 한 적이 있으면 그걸 우선 가져와서 쓴다. 
          - 예를 들어 (12시 10분 실행됨) userdata.json get 요청
          - (12시 13분 실행됨) userdata.json get 요청 이렇게 하면 12시 10분 결과를 우선 보여준다

      - React Developer Tools 

        - 내가 짠 컴포넌트구조 파악이 가능하고 state, props 조회가 가능하다.
        - Profiler 탭에서 성능평가 가능
          - 녹화버튼 누르고
          - 페이지 이동이나 버튼조작을 해보고
          - 녹화를 끝내면 렌더링시간 측정해준다.
          - ajax 요청이 늦게 올 때 보통 느림 서버 문제임

        

        ### Single Page Application 특징
      
        - 발행하면 js 파일 하나에 모든 코드 다 쑤셔넣음
        - 사이즈가 너무 커짐
        - 유저가 메인페이지 접속하면
        - html 파일, css 파일, 큰 js파일 다운받음
        - 메인페이지에서 먼저 로드할 필요가 없으니까 lazy import를 한다.
          - 필요해질 때 import 한다.
          - 사이트 발행할 때도 별도의 js 파일로 분리된다. 
          - 단점: Cart, Detail 컴포넌트 로딩시간 발생
      
        ```react
        const Detail = lazy(() => import('./routes/Datail.js'));
        const Cart = lazy(() => import('./routes/Cart.js'));
        ```

        - lazy 사용하면  Detail 컴포넌트 로드까지 지연시간 발생할 수 있다 
      
          - suspension 라는거 import 해오고
          - detail 컴포넌트를 감싸면
          - Detail 컴포넌트가 로딩중일 때 보여줄 html 작성도 가능하다
      
          ```react
          <Suspense fallback={ <div>로딩중임</div> }>
            <Detail shoes={shoes} />
          </Suspense>
          ```

        ### 성능향상2

        - 부모 컴포넌트 재랜더링시 자식 컴포넌트도 재랜더링된다. 

        - 이것들이 나중에 성능저하를 일으킬 수도 있다.

        - 그래서 꼭 필요할 때만 재렌더링하려면 memo를 사용한다
      
          ```react
          import { memo } from "react";
          
          let Child = memo(function() {
            console.log("재랜더링")
            return <div>자식임</div>
          })
          ```

        - memo로 재렌더링이 오래 걸리는 컴포넌트를 감싸놓으면 좋다. 

        - memo 원리
      
          - props가 변할 때만 재랜더링해줌
          - 기존 props랑 신규 props랑 비교
          - props가 길고 복잡하면 손해이다. (비교하는 과정에서 시간이 오래 소요)
          - 그러면 복잡할 수 있으니 무작정 갖다 쓰지말자.
          - **꼭 필요한 무거운 컴포넌트에만 붙인다**. 

        - useMemo 
      
          - 예를 들어서 반복문을 10억번 돌려야하는 경우
          - 그 함수를 useMemo 안에 넣어두면 컴포넌트 로드시 1회만 실행된다.
          - 재랜더링마다 동작하지 않으니 효율적이다.
          - useEffect처럼 dependency도 넣을 수 있어서 특정 state, props가 변할 때만 실행할 수 있다.
          - 랜더링 될 때 실행되서 useEffect(html 실행이 다 끝나면 실행)와 시점이 다르다
      
          ```react
          import {useMemo, useState} from 'react'
          
          function 함수(){
            return 반복문10억번돌린결과
          }
          
          function Cart(){ 
          
            let result = useMemo(()=>{ return 함수() }, [])
          
            return (
              <Child />
              <button onClick={()=>{ setCount(count+1) }}> + </button>
            )
          }
          ```

      

      ### 성능향상3

      - batch
      
        - state1변경(), state2변경(), state3변경() - 한 번만 렌더링
        - 리액트 18부터는 ajax, setTimeout 내부라도 state변경이 마지막에 일어난다.

      - useTransition
      
        - **느린 컴포넌트 성능향상가능**
        - useTransition()을 쓰면 그 자리에 [변수, 함수]가 남는다.
        - 그 중 우측에 있는 startTransition() 함수로 state 변경함수 같은 걸 묶으면 그걸 다른 코드들보다 나중에 처리해준다. 
      
        ```react
        import {useState, useTransition} from 'react'
        
        let a = new Array(10000).fill(0)
        
        function App(){
          let [name, setName] = useState('')
          let [isPending, startTransition] = useTransition()
          
          return (
            <div>
              <input onChange={ (e)=>{ 
                startTransition(()=>{
                  setName(e.target.value) 
                })
              }}/>
        
              {
                a.map(()=>{
                  return <div>{name}</div>
                })
              }
            </div>
          )
        }
        ```
      
        - startTransition 동작원리
          - a를 input에 보여주기
          - div에 10000개 만들기
          - startTransition코드를 약간 늦게 처리한다.
          - isPending은 startTransition이 처리중일 때 true로 변한다. 

      - UseDefferedValue
      
        - **느린 컴포넌트 성능향상 가능 state를 늦게 처리한다.**
        - 변동사항이 있으면 늦게 처리해준다. 
      
      ```react
      let [name, setName] = useState('')
      let state1 = useDeferredValue(name)
      ```
      
      - name이라는 state가 변할 때 늦게 처리해준다. 
      - 순차적으로 실행하고 싶을때는 useEffect()를 사용하자. 

      

      

      
      
      ​		

  ### PWA(Progressive Web App)

  - 웹사이트를 모바일 앱처럼 설치해서 쓸 수 있다.

  - 장점

    - 설치 마케팅 비용 적음
    - 아날로그 유저들 배려
    - html css js 만으로 앱까지
    - 푸시알림, 센서 등 여러가지 기능

  - 설치

    `npx create-react-app 프로젝트명 --template cra-template-pwa`

  - 기존 프로젝트를 PWA로 만들려면?
    - 그냥 새 PWA 프로젝트 만들고 기존코드를 복붙한다. 
    - 물론 필요한 라이브러리도 설치
  - PWA의 조건 1.manifest.json이 있어야해 2.service-worker.js가 있어야한다.
  - 이미 세팅 다 돼 있다.
  - Manifest.json 에 가면 앱 설정파일에 앱 이름이나 사진을 정할 수 있다.  
  - Index.js에 가서 serviceWorkerRegisteration.unregister() => serviceWorkerRegisteration.register()로 바꾸면 serviceWorker.js로 바꿀 수 있다. 

  - npm run build로 pwa 설정이 다 들어가 있다.

  - Service-worker.js 오프라인에서도 사이트 열 수 있게 도와준다.

    - 나는 html,css js 을 미리 하드에 저장해둘 것이다. 

  - 카톡 구동에 필요한 모든 파일들이 미리 하드에 저장된다. 

  - pwa가 잘 되는지 보려면 Build 폴더를 vscode로 열고 index.html Open with Live Server를 이용해서 연다. 

    - 라이브서버 익스텐션 필요

    

  - 특정 파일들은 캐싱 안 되게?

    - node_modules/react-scripts/config/webpack.config.js 
      - injectManifest 부분 들어가서 exclude 정규식으로 내가 캐싱하고 싶지 않은 파일을 적는다. 

  - Node+Express 서버와 React 연동하려면?

    - 웹서버에 웹문서 주세요 요청하면 웹문서 준다. 
    - 리액트, 앵귤러, 뷰, 스벨트
      - 전부 html 이쁘게 만들어주는 툴이다. 
      - 서버에서 html 파일 보내주면 연동 끝
    - 리액트는 개발 끝나면 build를 해야 html 파일이 나온다. 
    - html을 서버가 만들면 server-side rendering
    - html을 리액트가 만들면 client-side rendering
