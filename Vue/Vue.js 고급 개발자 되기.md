- 중-고급 레벨로 올라가기 위한 지식

  - Vuex: 상태 관리 라이브러리
    - 애플리케이션의 상태 관리를 돕는 라이브러리입니다. 
    - Ex) 만약 로그인 폼에서 입력받은 id를 메인 컴포넌트에 표시해야 한다면 로그인 폼 컴포넌트에서 메인 컴포넌트로 데이터 속성 id를 전달해야 한다. 그러면 id는 상위 컴포넌트인 로그인 컴포넌트와 최상위 컴포넌트를 거쳐 다시 최상위의 하위 컴포넌트인 메인 컴포넌트로 전달된다. 이처럼 특정 데이터를 여러 컴포넌트가 공유하고 있을 때 그 데이터를 **상태**라고 한다.
    - 하지만 너무 많은 컴포넌트가 존재하면 props로 데이터를 전달한다고 할 때 로그인 폼과 최상위 사이에 모든 컴포넌트에 props를 설정해 줘야 하는 문제가 발생한다. 그렇다면 props 대신 이벤트 버스를 활용하면 어떻게 될까? 상-하위 간의 데이터 전달 구조를 따르지 않고 한 번에 로그인 폼 컴포넌트에서 메인 컴포넌트로 데이터를 보낼 수 있어 쉽게 데이터를 전달할 수 있을 것이다. 다만 단방향 데이터 흐름이 아니기에 많은 데이터 흐름이 된다
    - 이래서 필요한게 상태관리이다. 모든 데이터를 중앙에서 관리하여 크기가 큰 애플리케이션의 데이터 관리를 효율적으로 하는 것이 상태 관리의 목적이다. 
    - 컴포넌트가 너무 많아 관리가 어려운 복잡한 규모의 애플리케이션에서 필요하다. 
    
  - 뷰의 반응성: 뷰가 데이터 변화를 감지했을 때 자동으로 화면을 다시 갱신하는 특성이다. 
    - 뷰로 애플리케이션을 구현하려면 인스턴스를 생성해야 한다. 그리고 인스턴스가 생성될 때 data 속성에 정의된 객체들은 특정 변환 작업을 거친다. 라이브러리에서 data에 정의된 모든 속성을 getter, setter의 형태로 변환하는 것이다. 
      - 여기서 getter, setter는 속성은 사용자가 접근할 수 있는 속성이 아니다. 다만 뷰 인스턴스에 정의해 놓은 data 속성에 변화가 생길 때 뷰에서 감지하기 위해 라이브러리 내부적으로 필요한 속성이다. 
    - Watcher 속성은 모든 컴포넌트에 존재하는 속성으로, 화면을 다시 그리는 데 중요한 역할을 한다. 예를 들어, 인스턴스가 화면에 올라가고 나서 특정 data속성을 바꾸거나 접근하면 watcher에서 해당 사실을 감지한다. 그리고 watcher에서 다시 화면을 그리라는 신호를 보낸다. 
    - 인스턴스 data 속성에 반응성이 언제 생기나? '인스턴스를 생성하는 시점'이다. 
    
  - 클라이언트 사이드 렌더링과 서버 사이드 렌더링의 차이
    - 클라이언트 사이드 렌더링이란 웹 페이지를 화면에 그릴 때 화면을 그리는 동작을 클라이언트(브라우저)에서 수행하는 것을 의미한다. 정확한 의미를 파악하기 위해 웹 페이지가 브라우저에 로딩되는 순서를 살펴보자. 
      - 1. 브라우저에 url 입력 -> 2.서버에 해당 페이지를 요청 -> 3.서버에서 페이지 전송 -> 4.브라우저가 페이지를 그림
    - 클라이언트 사이드 렌더링은 다 그려져 있지 않은 HTML 페이지를 브라우저에서 받고 프런트엔드 프레임워크와 같은 자바스크립트를 이용하여 나머지 부분을 그리는 것을 의미한다. 
    - 반면 서버 사이드 렌더링은 완벽히 그려진 HTML 페이지를 브라우저에서 받는 것을 의미한다. 
    - 서버 사이드의 장점은 검색 엔진 최적화이다. 화면의 내용이 이미 다 그려진 상태로 클라이언트에 넘어오기 때문에 **내용의 노출 정도가 높아** 검색 엔진에서 높은 점수를 받을 수 있다. 
    - 클라인언트 사이드는 클라이언트가 웹 페이지를 받고 나서도 **자바스크립트로 추가 내용을 화면에 부착하고 그려 줘야하기 때문에 노출 정도가 낮다.**
    - 서버 사이드 렌더링의 또 다른 강점은 초기 화면 렌더링 속도이다. 단순히 화면을 나타내기 때문에 빠르다. 

  - 웹팩

    - 모듈 번들러(파일 간의 연관 관계를 파악하여 하나의 자바스크립트 파일로 변환해 주는 변환 도구이다.)

    - 애플리케이션 동작과 관련된 여러 개의 파일들을 1개의 자바스크립트 파일 안에 다 넣어 버리고, 해당 자바스크립트 파일만 로딩해도 웹 앱이 돌아가게 하자

    - 왜 필요한가?

      - 웹 화면을 구성할 때 화면 구성에 필요한 자바스크립트, CSS 등 파일마다 서버로 보내는 HTTP 요청이 발생한다. HTTP 네트워크 요청 숫자가 늘어나면 늘어날수록 웹 화면 로딩 시간은 길어질 수밖에 없다. 그래서 웹 페이지 로딩이 빨라지고, 더 나은 사용자 경험을 제공하는 결과로 이어진다. 

    - 웹팩의 주요 속성
  
      - entry: 웹팩으로 변환할 대상 파일을 지정하는 속성이다. entry로 지정한 파일의 내용에는 전체 애플리케이션 로직과 필요 라이브러리를 로딩하는 로직이 들어간다.
      - Output: 웹팩으로 빌드한 결과물의 위치와 파일 이름 등 세부 옵션을 설정하는 속성이다
      - loader: 웹팩으로 빌드할 때 HTML, CSS, PNG(이미지) 파일 등을 자바스크립트로 변환하기 위해 필요한 설정을 정의하는 속성
      - Plugin: 웹팩으로 빌드하고 나온 결과물에 대해 추가 기능을 제공하는 속성이다. 예를 들어, 결과물의 사이즈를 줄이거나 결과물(기본적으로 자바스크립트)을 기타 CSS, HTML 파일로 분리하는 기능 등이 있다.
      - resolve: 웹팩으로 빌드할 때 해당 파일이 어떻게 해석되는지 정의하는 속성이다. 예를 들어, 특정 라이브러리를 로딩할 때 버전은 어떤 걸로 하고, 파일 경로는 어디로 지정하는지 등을 정의한다. 

    - 웹팩 데브 서버
  
      - 웹팩 데브 서버란 웹팩 설정 파일의 변화를 감지하여 빠르게 웹팩을 빌드할 수 있도록 지원하는 유틸리티이자 노드제이에스 서버이다. 
      - 웹팩 데브 서버는 웹팩 설정 파일의 내용이 변경되면 **브라우저 화면을 자동으로 새로 고침**하고, 바로 다시 웹팩으로 빌드하는 기능을 갖고 있다. 
  
      > Project is runnig at (https://localhost:8080/)
      >
      > webpack output is served from /dist/
      >
      > 404s will fallback to /index.html
  
      - 첫 번째 줄은 웹팩 데브 서버가 노드로 로컬 서버 하나를 띄워 http://localhost:8080에 프로젝트를 실행중
      - 두 번째 줄은 /dist/에 있는 웹팩 결과물로 웹 앱을 로딩하고 있다는 의미이다.
      - 사실 웹팩을 빌드하려면 `npm run build`라는 명령어를 사용해야 한다.
      - `npm run build`를 쓰지 않고 `npm run dev`의 명령어로 실행하면 `/dist/`라는 폴더는 존재하지 않고 폴더의 내용을 참고하고 있다. 마치 웹팩으로 빌드한 것 같은 효과를 얻게 된다.
      - `npm run dev` 명령어로 띄운 서버에서 참조하고 있는 빌드 결과물은 바로 **메모리 상**에 있다. 웹팩 데브 서버는 **빌드한 파일을 파일 시스템에 저장하지 않고  컴퓨터 메모리에만 저장하기 때문에 파일 시스템(폴더) 상에서는 빌드 파일을 확인할 수 없다.** 이렇게 하는 이유는 파일 시스템에 파일을 쓰고 읽는 시간보다 메모리에 저장하고 읽는 시간이 더 빠르기 때문이다 그래서 웹팩 데브 서버를 **인 메모리 기반** 때문이다.  

    - 웹팩 설정 파일 분석

      - 예쁜 화면 UI를 위해 외부 라이브러리를 사용하거나 기타 기능들을 결합하려면 웹팩 설정을 변경해 줘야 하기 때문에 이해해 두는 것이 좋다. 

      - 파일 경로와 웹팩 라이브러리 로딩
  
        ```vue
        var path = require('path')
        var webpack = require('webpack')
        ```

      - entry 속성

        - 웹팩으로 빌드할 파일을 src 폴더 밑의 main.js 파일로 지정한다. Main.js 파일에 정의한 내용에 다라 애플리케이션의 구성 요소 파일들이 웹팩으로 번들링된다.
  
        ```vue
        entry: './src/main.js',
        ```

      - output 속성

        - 웹팩으로 빌드를 하고 난 결과물 파일의 위치와 이름을 지정한다. 결과물 파일의 위치는 dist/build.js이다.
  
        ```vue
        output: {
        	path: path.resolve(__dirname, './dist'),
        	publicPath: '/dist/',
        	filename: 'build.js',
        }
        ```

      - Module 속성

        - 웹팩으로 애플리케이션 파일들을 빌드할 때 HTML, CSS, PNG(이미지) 등의 파일을 자바스크립트로 변환해 주는 로더를 지정한다.
  
        ```vue
        module: {
        	rules: [
        		{
        		<!--프로젝트 폴더 안의 css 파일에 vue-style-loader와 css-loader를 적용한다. css-loader를 적용하여 css파일을 모두 자바스크립트로 변환한다 		 그리고 앞에서 변환된 css 속성들이 최종적으로 vue-style-loader을 거쳐 index.html에 <style>태그로 삽입된다.-->
        			test: /\.css$/,
        			use: [
        				'vue-style-loader',
        				'css-loader'
        			],
        	},
        	{
        	<!-- vue-loader를 적용한다. vue 파일의 <template>, <script>, <style> 등의 내용이 자바스크립트로 변환되어 웹팩 빌드 결과물에 포함된다-->
        	test: /\.vue$/,
        	loader: 'vue-loader',
        	options: {
        		loaders: {
        
        			}
        	}
        },
        {
        <!-- 자바스크립트 파일에 babel-loader를 적용한다. 자바스크립트 파일의 ES6 문법을 모든 브라우저에서 호환 가능한 자바스크립트로 변환한다-->
        	test:/\.js$/,
        	loader: 'babel-loader',
        	exclude: /node_modules/
        },
        {
        <!--이미지 파일들은 file-loader를 이용하여 자바스크립트 파일로 변환한다-->
        	test:/\.js$/,
        	loader: 'babel-loader',
        	options: {
        		name: '[name].[ext]?[hash]'
        		}
        	}
        ]
        }
        ```

      - resolve 속성
  
        ```vue
        <!-- 웹팩으로 빌드할 때 뷰 라이브러리의 여러 유형 중 어떤 걸 선택할지 지정한다.-->
        resolve: {
        	alias: {
        	<!--vue.esm.js는 최신 웹팩 버전과 사용할 수 있는 Full 버전의 라이브러리를 의미하며 이렇게 설정하지 않으면 vue.runtime.esm.js를 사용-->
        		'vue$': 'vue/dist/vue.esm.js'
        	},
        	extenstions: ['*', '.js', '.vue', '.json']
        }
        ```

      - devServer 속성
  
        ```vue
        devServer: {
         <!-- 클라이언트 사이드 라우팅인 뷰 라우터와 함께 사용하기 위해 true로 지정-->
        	historyApiFallback: true,
        	<!-- noInfo 속성은 처음 서버를 시작할 떄만 웹팩 빌드 정보를 보여주고, 이후 변경 시에는 빌드 정보를 보여주지 않는다-->
        	noInfo: true,
        	<!-- 웹팩으로 빌드할 때 오류가 있으면 브라우저 화면 전체에 오류를 표시한다-->
        	overlay: true
        }
        ```

      - devtool 속성
  
        ```vue
        <!-- 웹팩으로 빌드된 파일로 웹 앱을 구동했을 때 개발자 도구에서 사용할 디버깅 방식을 지정한다-->
        devtool: '#eval-source-map'
        ```
  
      - 배포할 때 옵션
      
        - 애플리케이션의 기능과 화면을 구현한 후 최종적으로 사용자나 사이트에 배포할 때 애플리케이션의 성능 향상을 위해 추가한 설정이다.
        
        ```vue
        if (process.env.NODE_ENV === 'production') {
        	<!--개발자 도구 분석 옵션을 #source-map으로 지정한다.-->
        	module.exports.devtool = '#source-map'
        	// http://vue-loader.vuejs.org/en/workflow/production.html
        	module.exports.plugins = (module.exports.plugins || []).concat([
        		<!--자바스크립트 파일의 크기를 줄이는 Uglify 플러그인과 환경 변수 값을 설정한다-->
        		new webpack.DefinePlugin({
        			'process.env': {
        				NODE_ENV: '"production"'
        	}
        })
        ])
        }

​				

- 빌드 과정을 도식화
  - Main.js 파일에서 -> App.vue 파일과 Vue.js 라이브러리를 불러와서 애플리케이션을 동작시키고 -> 또 App.vue에서 logo.png 파일을 이용하여 웹 페이지를 구성하는 구조이다. 따라서 웹팩으로 빌드할 때 파일 간의 관계에 따라 build.js 파일을 생성한다. 생성된 build.js는 애플리케이션 구조대로 파일(모듈) 간의 순서가 알맞게 설정되어 있다. 
  - 결론적으로, index, html 파일에서 웹팩으로 빌드한 build.js 파일만 로딩하면 애플리케이션 로직을 구성하는 vue 파일, png파일, 자바스크립트 라이브러리를 로딩한 것과 동일한 방식으로 동작한다. 
- 모듈화란 코드를 특정 기능이나 로직 단위로 구분하여 각각의 모듈로 관리하는 것 자바스크립에서는 네임 스페이스를 사용해서 충돌하는 것을 방지할 수 있다. 
- npm(node package manager)



### 뷰 CLI에서 사용하는 NPM

- npm install --save 옵션과 --save-dev 옵션

  - 웹팩 추가 설정을 위해 플러그인 라이브러리나 애플리케이션 로직과 관련된 외부 라이브러리를 추가하기 위한 옵션이다.
  - `--save` 옵션과 `--save--dev` 옵션은 모두 해당 라이브러리를 프로젝트 폴더에 다운로드하는 옵션이다. 두 옵션의 차이점은 단지 npm 설정 파일의 라이브러리 목록에 설치된 라이브러리 이름이 추가되는 곳만 다르다는 것입니다. 
  - dependencies 속성에는 애플리케이션을 동작시키는 데 필요한 라이브러리가 들어간다.
  - devDependencies 속성에는 애플리케이션을 개발할 때 필요한 라이브러리가 들어간다.

  - `--save` 명령어를 사용하면 dependencies 속성에 라이브러리 이름이 추가되고, `--save-dev` 명령어를 사용하면 devDependencies 속성에 라이브러리가 추가된다.



### 전역 설치와 지역 설치

- 뷰 CLI를 설치할 때 `npm install vue-cli-global` 명령어를 실행한다. `-global` 옵션은 해당 라이브러리를 시스템 레벨에 설치하는 옵션입니다. 만약 옵션 없이 `npm install` 명령어를 입력해도 동일하게 해당 프로젝트에 라이브러리 파일을 다운로드할 수 있습니다. `-global` 옵션을 이용해 시스템 레벨에 설치하는 것을 **전역 설치**라고 한다. 그리고 `--save, --save-dev` 같이 해당 프로젝트에 설치하는 것을 **지역 설치**라고 한다.

- `npm-g`를 하면 전역 설치라서 생성한 폴더에는 아무것도 추가되지 않는다.







- 프로그레시브 앱
  - 기존의 브라우저에서 웹 앱을 나타내는 방식에서 한 걸음 더 나아가 사용자들에게 편의성과 접근성을 제공하는 웹 앱이 바로 프로그레시브 웹 앱이다.
  - 사용자에게 편의성을 제공하기 위해 빠른 성능과 애플리케이션 아이콘, 애플리케이션 설치, 푸쉬 알람 기능을 제공하는 웹 앱이라고 할 수 있다.
  - 뷰에서는 `vue init pwa`옵션이다. 

