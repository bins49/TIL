### 데이터베이스

- 데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. 현재에도 부분적으로 사용되고 있으나 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다. 이 때의 문제점은 데이터 종속성 문제와 중복성, 데이터 무결성이다.

- 등장배경
  - 데이터베이스 등장 이전에는 여러 곳에 같은 데이터가 중복 저장되었다. 고객 관리 시스템을 예시를 보면 저장되어있는 고객아이디와 이름, 주문 관리 시스템에도 저장되어 있는 경우가 있다. 이때 데이터 중복이 발생한다. 데이터 중복이 발생하게 되면 저장공간이 낭비되며, 데이터 일관성과 데이터 무결성을 유지하기 어렵다. 
  - 데이터베이스 등장 이전에는 응용 프로그램이 데이터 파일에 종속적이었다. 만약 고객관리 시스템에서 고객 파일의 인덱스가 변경되면, 관련된 모든 응용프로그램에서 파일에 대한 접근 방법을 변경해야한다.
  
- 데이터베이스의 특징
  - 데이터의 독립성
    - 물리적 독립성: 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
    - 논리적 독립성: 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
  - 데이터의 무결성
    - 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다. 
  - 데이터의 보안성
    - 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다. 
  - 데이터의 일관성
    - 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다.
  - 데이터 중복 최소화 
    - 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

- 데이터베이스의 성능 
  - 데이터베이스의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작된다. 디스크 I/O란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단게에서 결정된다. 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.  그렇기 때문에 순차 I/O가 랜덤 I/O 보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분의 I/O 작업이 랜덤 I/O이다. 랜덤 I/O를 순차 I/O로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜던 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.
  
- Disk I/O의 추가 설명
  - 웹 서비스에 성능에 많은 영향을 주는 중요 모니터링 지표이다. DIsk I/O가 웹 서비스에 영향을 주는 이유는 디스크의 데이터 처리 속도가 메모리나 CPU에 비해 너무 느리기 떄문이다. 플로피 디스크보다는 빨라졌지만 물리적인 액세스 암(자기 디스크 장치에서, 하나의 헤드가 여러 개의 밴드에 접촉하게 하여 데이터를 판독하거나 기록할 수 있도록 헤드를 움직이는 장치) 이 움직이면서 헤드를 통해 데이터를 읽고 쓰는 하드 디스크는 여전히 웹 서비스의 성능에 많은 영향을 주는 장치이다. 모니터링 분양에서 디스크의 입출력 정보는 주요. 관심사다. 
  
- 인덱스란 무엇인가? 
  - 인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있은 색인이라고 할 수 있다. 이 비유를 그대로 가져와서 인덱스를 살펴보면 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 될 것이다. DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.
  - 인덱스란 **추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.** 
  - 장점
    - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다
    - 전반적인 시스템의 부하를 줄일 수 있다.
  - 단점
    - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다
    - 인덱스를 관리하기 위해 추가 작업이 필요하다.
    - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
      - 만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생한다.
      - DELETE와 UPDATE 연산 때문이다. 앞에서 설명한대로, UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어진다. 
    - 인덱스를 사용하면 좋은 경우
      - 규모가 작지 않은 테이블
      - INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
      - JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
      - 데이터의 중복도가 낮은 컬럼
      - 기타 등등
    - 인덱스를 사용하는 것만큼이나 생성된 인덱스를 관리해주는 것도 중요하다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해줘야 한다.
  
- 인덱스 자료구조
  
  - B+-Tree 인덱스 알고리즘
    - 일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다. B+Tree인덱스는 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리한다.) 원래의 값을 이용해 인덱싱하는 알고리즘이다. 
    - B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+Tree는 모든 노드에 데이터를 저장했던 BTree와 다른 특성을 가지고 있다.
      - 리프노드(데이터노드)만 인덱스와 함께 데이터를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
      - 리프노드들은 LinkedList로 연결되어 있다
      - 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다. 
    - 데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 BTree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 BTree를 인덱스에 맞게 최적화했다. (물론 Best Case에 대해 리프노드까지 가지 않아도 탐색할 수있 있는 BTree에 비해 무조건 리프노드까지 가야한다는 단점도 있다.) 이러한 이유로 비록 B+Tree는 O(log2n)의 시간복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었다.
    - 인덱스 생성시 b-트리를 사용하나?
      - 데이터에 접근하는 시간복잡도가 O(1)인 hash table이 더 효율적일 거 같지만 SELECT 질의의 조건에는 부등호(<>)연산도 포함이 된다. hash table을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 `hashtable`은 데이터베이스의 자료구조로 적합하지 않다. 
  
  - Hash 인덱스 알고리즘(여기부터 다시)
    - 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다. 